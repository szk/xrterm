{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/WebglUtils.ts","webpack:///./xterm/src/common/buffer/Constants.ts","webpack:///./src/RenderModel.ts","webpack:///./xterm/src/common/TypedArrayUtils.ts","webpack:///./xterm/src/common/buffer/AttributeData.ts","webpack:///./src/renderLayer/BaseRenderLayer.ts","webpack:///./src/atlas/CharAtlasCache.ts","webpack:///./src/atlas/CharAtlasUtils.ts","webpack:///./xterm/src/browser/renderer/atlas/Constants.ts","webpack:///./xterm/src/common/buffer/CellData.ts","webpack:///./src/AframeAddon.ts","webpack:///./src/AframeRenderer.ts","webpack:///./src/AframeGlyphRenderer.ts","webpack:///./src/TypedArray.ts","webpack:///./src/renderLayer/LinkRenderLayer.ts","webpack:///./src/atlas/WebglCharAtlas.ts","webpack:///./xterm/src/browser/Color.ts","webpack:///./src/renderLayer/CursorRenderLayer.ts","webpack:///./xterm/src/common/input/TextDecoder.ts","webpack:///./src/RectangleRenderer.ts","webpack:///./xterm/src/common/Lifecycle.ts","webpack:///./xterm/src/common/EventEmitter.ts"],"names":["root","factory","exports","module","define","amd","a","i","window","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","createShader","gl","type","source","shader","throwIfFalsy","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","getShaderInfoLog","deleteShader","Error","PROJECTION_MATRIX","Float32Array","vertexSource","fragmentSource","program","createProgram","attachShader","VERTEX_SHADER","FRAGMENT_SHADER","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","max","newLength","Math","min","length","newArray","DEFAULT_COLOR","DEFAULT_ATTR","CHAR_DATA_ATTR_INDEX","CHAR_DATA_CHAR_INDEX","CHAR_DATA_WIDTH_INDEX","CHAR_DATA_CODE_INDEX","NULL_CELL_CHAR","NULL_CELL_WIDTH","NULL_CELL_CODE","WHITESPACE_CELL_CHAR","WHITESPACE_CELL_WIDTH","WHITESPACE_CELL_CODE","RENDER_MODEL_INDICIES_PER_CELL","RENDER_MODEL_BG_OFFSET","RENDER_MODEL_FG_OFFSET","COMBINED_CHAR_BIT_MASK","this","cells","Uint32Array","lineLengths","selection","hasSelection","columnSelectMode","viewportStartRow","viewportEndRow","viewportCappedStartRow","viewportCappedEndRow","startCol","endCol","cols","rows","indexCount","fill","fillFallback","array","start","end","b","result","constructor","set","fg","bg","extended","ExtendedAttrs","toColorRGB","fromColorRGB","clone","newObj","AttributeData","isInverse","isBold","isUnderline","isBlink","isInvisible","isItalic","isDim","getFgColorMode","getBgColorMode","isFgRGB","isBgRGB","isFgPalette","isBgPalette","isFgDefault","isBgDefault","isAttributeDefault","getFgColor","getBgColor","hasExtendedAttrs","updateExtended","isEmpty","getUnderlineColor","underlineColor","getUnderlineColorMode","isUnderlineColorRGB","isUnderlineColorPalette","isUnderlineColorDefault","getUnderlineStyle","underlineStyle","_container","id","zIndex","_alpha","_colors","_scaledCharWidth","_scaledCharHeight","_scaledCellWidth","_scaledCellHeight","_scaledCharLeft","_scaledCharTop","_canvas","document","createElement","classList","add","style","toString","_initCanvas","appendChild","removeChild","_charAtlas","dispose","_ctx","getContext","alpha","_clearAll","terminal","startRow","endRow","colorSet","_refreshCharAtlas","oldCanvas","cloneNode","replaceChild","onGridChanged","acquireCharAtlas","warmUp","dim","scaledCellWidth","scaledCellHeight","scaledCharWidth","scaledCharHeight","scaledCharLeft","scaledCharTop","width","scaledCanvasWidth","height","scaledCanvasHeight","canvasWidth","canvasHeight","x","y","fillRect","devicePixelRatio","lineWidth","strokeRect","clearRect","fillStyle","background","css","cell","font","_getFont","textBaseline","_clipRow","fillText","getChars","beginPath","rect","clip","getOption","charAtlasCache","colors","newConfig","generateConfig","entry","ownedByIndex","ownedBy","indexOf","configEquals","config","atlas","splice","push","newEntry","WebglCharAtlas","index","NULL_COLOR","rgba","clonedColors","foreground","cursor","cursorAccent","selectionTransparent","selectionOpaque","ansi","slice","contrastCache","fontFamily","fontSize","fontWeight","fontWeightBold","allowTransparency","drawBoldTextInBrightColors","minimumContrastRatio","colorCode","INVERTED_DEFAULT_COLOR","DIM_OPACITY","CHAR_ATLAS_CELL_SPACING","content","combinedData","fromCharData","obj","CellData","setFromCharData","isCombined","getWidth","stringFromCodePoint","getCode","charCodeAt","combined","code","second","getAsCharData","_gl_three","log","element","_terminal","_core","_renderService","_colorManager","_renderer","AframeRenderer","_size","AFRAME","THREE","Vector3","dimensions","renderService","setRenderer","_createRenderer","onResize","undefined","textureAtlas","bufferGeometry","shaderMaterial","clearCharAtlas","updateRows","Disposable","super","_model","RenderModel","_workCell","_onRequestRedraw","EventEmitter","_renderLayers","LinkRenderLayer","screenElement","CursorRenderLayer","actualCellWidth","actualCellHeight","_devicePixelRatio","_updateDimensions","_gl","_rectangleRenderer","RectangleRenderer","_glyphRenderer","AframeGlyphRenderer","onCharSizeChanged","_isAttached","body","contains","event","getBufferGeometry","_atlasTexture","forEach","cacheCanvas","setColors","reset","updateSelection","clear","clearSelection","resize","setDimensions","onBlur","onFocus","onSelectionChanged","_updateSelectionModel","fire","onCursorMove","onOptionsChanged","setAtlas","clearTexture","_updateModel","handler","joinerId","_charSizeService","beginFrame","debug","updateAtlas","row","buffer","ydisp","line","lines","loadCell","chars","updateCell","updateBackgrounds","active","viewportY","floor","ceil","round","_dimensions","_activeBuffer","_vertices","count","attributes","pos_attributes","uv_attributes","norm_attributes","attributesBuffers","selectionAttributes","positions","uvs","idx","byteLength","createTexture","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","Uint8Array","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","_aframebuffergeometry","BufferGeometry","_aframe_pos_att","BufferAttribute","_aframe_uv_att","usage","DynamicDrawUsage","setAttribute","dynamic","position","needsUpdate","uv","setIndex","_updateCell","pos_array_","uv_array_","idx_array_","x_","y_","code_","bg_","fg_","offset","uv_idx","rasterizedGlyph","_atlas","getRasterizedGlyphCombinedChar","getRasterizedGlyph","fn_scale","v_spc","h_spc","top","bottom","size","left","right","idx_o","uv_top","texturePositionClipSpace","uv_bottom","sizeClipSpace","uv_left","uv_right","array_","offset_","toFixed","newCount","renderModel","isSelectionVisible","generateMipmap","_aframeshadermaterial","model","_updateSelectionRange","startRowEndCol","middleRowsCount","workCell","_getColorFromAnsiIndex","arr","c2","getLine","getCell","sliceFallback","BaseRenderLayer","container","linkifier","onShowLinkUnderline","e","_onShowLinkUnderline","onHideLinkUnderline","_onHideLinkUnderline","linkifier2","_state","_clearCurrentLink","_clearCells","x1","y1","middleRowCount","y2","x2","is256Color","_fillBottomLineAtCells","TEXTURE_CAPACITY","TEXTURE_HEIGHT","TRANSPARENT_COLOR","NULL_RASTERIZED_GLYPH","texturePosition","toPaddedHex","_config","_didWarmUp","_cacheMap","_cacheMapCombined","_currentRowY","_currentRowX","_currentRowHeight","hasCanvasChanged","_workBoundingBox","_workAttributeData","_cacheCtx","_tmpCanvas","TMP_CANVAS_GLYPH_PADDING","_tmpCtx","parentElement","_doWarmUp","_drawToCache","rasterizedGlyphSet","rasterizedGlyphSetBg","bgColorMode","bgColor","inverse","fgColorMode","fgColor","bold","minimumContrastCss","_getMinimumContrastCss","channels","toCss","substr","adjustedColor","getCss","bgRgba","_resolveBackgroundRgba","fgRgba","_resolveForegroundRgba","ensureContrastRatio","setCss","codeOrChars","String","fromCharCode","save","italic","temp","temp2","backgroundColor","_getBackgroundColor","globalCompositeOperation","fontStyle","_getForegroundCss","globalAlpha","restore","imageData","getImageData","color","g","data","clearColor","_findGlyphBoundingBox","clippedImageData","_clipImageData","putImageData","boundingBox","found","alphaOffset","clippedData","Uint8ClampedArray","oldOffset","newOffset","ImageData","rgb","contrastRatio","l1","l2","toRgba","blend","fgR","fgG","fgB","bgR","bgG","bgB","isOpaque","ratio","toColor","opaque","rgbaColor","toChannels","opacity","parseInt","relativeLuminance2","rs","gs","bs","pow","relativeLuminance","reduceLuminance","cr","increaseLuminance","bgL","fgL","_onRequestRefreshRowsEvent","_cell","isFocused","_cursorRenderers","_renderBarCursor","_renderBlockCursor","_renderUnderlineCursor","_clearCursor","_cursorBlinkStateManager","pause","cursorY","resume","CursorBlinkStateManager","_render","restartBlinkAnimation","isPaused","triggeredByAnimationFrame","_coreService","isCursorInitialized","isCursorHidden","baseY","viewportRelativeCursorY","cursorX","isTerminalFocused","cursorStyle","_renderBlurCursor","isCursorVisible","_fillLeftLineAtCell","_fillCells","_fillCharTrueColor","strokeStyle","_strokeRectAtCell","_renderCallback","_restartInterval","_blinkStartTimeout","_blinkInterval","clearInterval","clearTimeout","_animationFrame","cancelAnimationFrame","_animationTimeRestarted","Date","now","requestAnimationFrame","timeToStart","setTimeout","time","setInterval","activeElement","textarea","hasFocus","codePoint","codepoint","_interim","decode","input","target","startPos","StringToUtf32","interim","byte1","byte2","byte3","byte4","discardInterim","cp","pos","tmp","missing","fourStop","Utf8ToUtf32","BYTES_PER_RECTANGLE","BYTES_PER_ELEMENT","_program","_resolutionLocation","getUniformLocation","_projectionLocation","_vertexArrayObject","createVertexArray","bindVertexArray","unitQuadVertices","unitQuadVerticesBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","enableVertexAttribArray","vertexAttribPointer","FLOAT","unitQuadElementIndices","elementIndicesBuffer","ELEMENT_ARRAY_BUFFER","_attributesBuffer","vertexAttribDivisor","_updateCachedColors","useProgram","uniformMatrix4fv","uniform2f","canvas","DYNAMIC_DRAW","drawElementsInstanced","TRIANGLES","_updateViewportRectangle","_bgFloat","_colorToFloat32Array","_selectionFloat","_addRectangleFloat","INDICES_PER_RECTANGLE","vertices","rectangleCount","currentStartX","currentBg","currentFg","currentInverse","modelIndex","_updateRectangle","startX","endX","expandFloat32Array","_addRectangle","_disposables","_isDisposed","register","unregister","disposeArray","disposables","_listeners","_disposed","_event","listener","arg1","arg2","queue","from","to"],"mappings":"CAAA,SAA2CA,EAAMC,GAChD,GAAsB,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,SACb,GAAqB,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,OACP,CACJ,IAAIK,EAAIL,IACR,IAAI,IAAIM,KAAKD,GAAuB,iBAAZJ,QAAuBA,QAAUF,GAAMO,GAAKD,EAAEC,IAPxE,CASGC,QAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUT,QAGnC,IAAIC,EAASM,EAAiBE,GAAY,CACzCJ,EAAGI,EACHC,GAAG,EACHV,QAAS,IAUV,OANAW,EAAQF,GAAUG,KAAKX,EAAOD,QAASC,EAAQA,EAAOD,QAASQ,GAG/DP,EAAOS,GAAI,EAGJT,EAAOD,QA0Df,OArDAQ,EAAoBK,EAAIF,EAGxBH,EAAoBM,EAAIP,EAGxBC,EAAoBO,EAAI,SAASf,EAASgB,EAAMC,GAC3CT,EAAoBU,EAAElB,EAASgB,IAClCG,OAAOC,eAAepB,EAASgB,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhET,EAAoBe,EAAI,SAASvB,GACX,oBAAXwB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAepB,EAASwB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAepB,EAAS,aAAc,CAAE0B,OAAO,KAQvDlB,EAAoBmB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQlB,EAAoBkB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAvB,EAAoBe,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOlB,EAAoBO,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRtB,EAAoB0B,EAAI,SAASjC,GAChC,IAAIgB,EAAShB,GAAUA,EAAO4B,WAC7B,WAAwB,OAAO5B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAO,EAAoBO,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRT,EAAoBU,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG5B,EAAoB+B,EAAI,GAIjB/B,EAAoBA,EAAoBgC,EAAI,I,+BCpDrD,SAAgBC,EAAaC,EAA2BC,EAAcC,GACpE,MAAMC,EAASC,EAAaJ,EAAGD,aAAaE,IAC5CD,EAAGK,aAAaF,EAAQD,GACxBF,EAAGM,cAAcH,GAEjB,GADgBH,EAAGO,mBAAmBJ,EAAQH,EAAGQ,gBAE/C,OAAOL,EAGTM,QAAQC,MAAMV,EAAGW,iBAAiBR,IAClCH,EAAGY,aAAaT,GAYlB,SAAgBC,EAAgBpB,GAC9B,IAAKA,EACH,MAAM,IAAI6B,MAAM,2BAElB,OAAO7B,E,+IA/CI,EAAA8B,kBAAoB,IAAIC,aAAa,CAChD,EAAG,EAAG,EAAG,EACT,GAAI,EAAG,EAAG,EACV,EAAG,EAAG,EAAG,GACR,EAAG,EAAG,EAAG,IAGZ,yBAA8Bf,EAA2BgB,EAAsBC,GAC7E,MAAMC,EAAUd,EAAaJ,EAAGmB,iBAKhC,GAJAnB,EAAGoB,aAAaF,EAASd,EAAaL,EAAaC,EAAIA,EAAGqB,cAAeL,KACzEhB,EAAGoB,aAAaF,EAASd,EAAaL,EAAaC,EAAIA,EAAGsB,gBAAiBL,KAC3EjB,EAAGuB,YAAYL,GACClB,EAAGwB,oBAAoBN,EAASlB,EAAGyB,aAEjD,OAAOP,EAGTT,QAAQC,MAAMV,EAAG0B,kBAAkBR,IACnClB,EAAG2B,cAAcT,IAGnB,iBAaA,8BAAmChB,EAAsB0B,GACvD,MAAMC,EAAYC,KAAKC,IAAoB,EAAhB7B,EAAO8B,OAAYJ,GACxCK,EAAW,IAAIlB,aAAac,GAClC,IAAK,IAAIlE,EAAI,EAAGA,EAAIuC,EAAO8B,OAAQrE,IACjCsE,EAAStE,GAAKuC,EAAOvC,GAEvB,OAAOsE,GAGT,kB,2UC/Ca,EAAAC,cAAgB,IAChB,EAAAC,aAAe,IAAa,EAAAD,eAAiB,EAE7C,EAAAE,qBAAuB,EACvB,EAAAC,qBAAuB,EACvB,EAAAC,sBAAwB,EACxB,EAAAC,qBAAuB,EAOvB,EAAAC,eAAiB,GACjB,EAAAC,gBAAkB,EAClB,EAAAC,eAAiB,EAOjB,EAAAC,qBAAuB,IACvB,EAAAC,sBAAwB,EACxB,EAAAC,qBAAuB,I,+MCvBpC,aAEa,EAAAC,+BAAiC,EACjC,EAAAC,uBAAyB,EACzB,EAAAC,uBAAyB,EAEzB,EAAAC,uBAAyB,WAEtC,oBAKE,cACEC,KAAKC,MAAQ,IAAIC,YAAY,GAC7BF,KAAKG,YAAc,IAAID,YAAY,GACnCF,KAAKI,UAAY,CACfC,cAAc,EACdC,kBAAkB,EAClBC,iBAAkB,EAClBC,eAAgB,EAChBC,uBAAwB,EACxBC,qBAAsB,EACtBC,SAAU,EACVC,OAAQ,GAIL,OAAOC,EAAcC,GAC1B,MAAMC,EAAaF,EAAOC,EAAO,EAAAlB,+BAC7BmB,IAAef,KAAKC,MAAMnB,SAC5BkB,KAAKC,MAAQ,IAAIC,YAAYa,GAC7Bf,KAAKG,YAAc,IAAID,YAAYY,IAIhC,QACL,EAAAE,KAAKhB,KAAKC,MAAO,EAAG,GACpB,EAAAe,KAAKhB,KAAKG,YAAa,EAAG,GAGrB,iBACLH,KAAKI,UAAUC,cAAe,EAC9BL,KAAKI,UAAUG,iBAAmB,EAClCP,KAAKI,UAAUI,eAAiB,EAChCR,KAAKI,UAAUK,uBAAyB,EACxCT,KAAKI,UAAUM,qBAAuB,EACtCV,KAAKI,UAAUO,SAAW,EAC1BX,KAAKI,UAAUQ,OAAS,K,6BClC5B,SAAgBK,EAAmCC,EAAUpF,EAAeqF,EAAmBC,GAK7F,QAL0E,IAAAD,MAAA,QAAmB,IAAAC,MAAcF,EAAMpC,QAK7GqC,GAASD,EAAMpC,OACjB,OAAOoC,EAETC,GAASD,EAAMpC,OAASqC,GAASD,EAAMpC,OAErCsC,EADEA,GAAOF,EAAMpC,OACToC,EAAMpC,QAELoC,EAAMpC,OAASsC,GAAOF,EAAMpC,OAErC,IAAK,IAAIrE,EAAI0G,EAAO1G,EAAI2G,IAAO3G,EAC7ByG,EAAMzG,GAAKqB,EAEb,OAAOoF,E,uFAzBT,gBAA2CA,EAAUpF,EAAeqF,EAAgBC,GAElF,OAAIF,EAAMF,KACDE,EAAMF,KAAKlF,EAAOqF,EAAOC,GAE3BH,EAAaC,EAAOpF,EAAOqF,EAAOC,IAG3C,iBAwBA,kBAA6C5G,EAAM6G,GACjD,IAAMC,EAAS,IAAK9G,EAAE+G,YAAoB/G,EAAEsE,OAASuC,EAAEvC,QAGvD,OAFAwC,EAAOE,IAAIhH,GACX8G,EAAOE,IAAIH,EAAG7G,EAAEsE,QACTwC,I,qHCxCT,8BAsBS,KAAAG,GAAK,EACL,KAAAC,GAAK,EACL,KAAAC,SAAW,IAAIC,EAwFxB,OA/GgB,EAAAC,WAAd,SAAyB/F,GACvB,MAAO,CACLA,IAAU,GAAuB,IACjCA,IAAU,EAAyB,IAC3B,IAARA,IAIU,EAAAgG,aAAd,SAA2BhG,GACzB,OAAmB,IAAXA,EAAM,KAAa,IAAmC,IAAXA,EAAM,KAAa,EAAoC,IAAXA,EAAM,IAGhG,YAAAiG,MAAP,WACE,IAAMC,EAAS,IAAIC,EAInB,OAHAD,EAAOP,GAAKzB,KAAKyB,GACjBO,EAAON,GAAK1B,KAAK0B,GACjBM,EAAOL,SAAW3B,KAAK2B,SAASI,QACzBC,GASF,YAAAE,UAAP,WAA+B,OAAiB,SAAVlC,KAAKyB,IACpC,YAAAU,OAAP,WAA+B,OAAiB,UAAVnC,KAAKyB,IACpC,YAAAW,YAAP,WAA+B,OAAiB,UAAVpC,KAAKyB,IACpC,YAAAY,QAAP,WAA+B,OAAiB,UAAVrC,KAAKyB,IACpC,YAAAa,YAAP,WAA+B,OAAiB,WAAVtC,KAAKyB,IACpC,YAAAc,SAAP,WAA+B,OAAiB,SAAVvC,KAAK0B,IACpC,YAAAc,MAAP,WAA+B,OAAiB,UAAVxC,KAAK0B,IAGpC,YAAAe,eAAP,WAAkC,OAAiB,SAAVzC,KAAKyB,IACvC,YAAAiB,eAAP,WAAkC,OAAiB,SAAV1C,KAAK0B,IACvC,YAAAiB,QAAP,WAAkC,OAA0C,WAAxB,SAAV3C,KAAKyB,KACxC,YAAAmB,QAAP,WAAkC,OAA0C,WAAxB,SAAV5C,KAAK0B,KACxC,YAAAmB,YAAP,WAAkC,OAA0C,WAAxB,SAAV7C,KAAKyB,KAAqF,WAAxB,SAAVzB,KAAKyB,KAChG,YAAAqB,YAAP,WAAkC,OAA0C,WAAxB,SAAV9C,KAAK0B,KAAqF,WAAxB,SAAV1B,KAAK0B,KAChG,YAAAqB,YAAP,WAAkC,OAA0C,IAAxB,SAAV/C,KAAKyB,KACxC,YAAAuB,YAAP,WAAkC,OAA0C,IAAxB,SAAVhD,KAAK0B,KACxC,YAAAuB,mBAAP,WAAuC,OAAmB,IAAZjD,KAAKyB,IAAwB,IAAZzB,KAAK0B,IAG7D,YAAAwB,WAAP,WACE,OAAkB,SAAVlD,KAAKyB,IACX,KAAK,SACL,KAAK,SAAqB,OAAiB,IAAVzB,KAAKyB,GACtC,KAAK,SAAqB,OAAiB,SAAVzB,KAAKyB,GACtC,QAA0B,OAAQ,IAG/B,YAAA0B,WAAP,WACE,OAAkB,SAAVnD,KAAK0B,IACX,KAAK,SACL,KAAK,SAAqB,OAAiB,IAAV1B,KAAK0B,GACtC,KAAK,SAAqB,OAAiB,SAAV1B,KAAK0B,GACtC,QAA0B,OAAQ,IAK/B,YAAA0B,iBAAP,WACE,OAAiB,UAAVpD,KAAK0B,IAEP,YAAA2B,eAAP,WACMrD,KAAK2B,SAAS2B,UAChBtD,KAAK0B,KAAM,UAEX1B,KAAK0B,IAAM,WAGR,YAAA6B,kBAAP,WACE,GAAe,UAAVvD,KAAK0B,KAA+B1B,KAAK2B,SAAS6B,eACrD,OAAuC,SAA/BxD,KAAK2B,SAAS6B,gBACpB,KAAK,SACL,KAAK,SAAqB,OAAsC,IAA/BxD,KAAK2B,SAAS6B,eAC/C,KAAK,SAAqB,OAAsC,SAA/BxD,KAAK2B,SAAS6B,eAC/C,QAA0B,OAAOxD,KAAKkD,aAG1C,OAAOlD,KAAKkD,cAEP,YAAAO,sBAAP,WACE,OAAkB,UAAVzD,KAAK0B,KAA+B1B,KAAK2B,SAAS6B,eACvB,SAA/BxD,KAAK2B,SAAS6B,eACdxD,KAAKyC,kBAEJ,YAAAiB,oBAAP,WACE,OAAkB,UAAV1D,KAAK0B,KAA+B1B,KAAK2B,SAAS6B,eACE,WAAxB,SAA/BxD,KAAK2B,SAAS6B,gBACfxD,KAAK2C,WAEJ,YAAAgB,wBAAP,WACE,OAAkB,UAAV3D,KAAK0B,KAA+B1B,KAAK2B,SAAS6B,eACE,WAAxB,SAA/BxD,KAAK2B,SAAS6B,iBAC8C,WAAxB,SAA/BxD,KAAK2B,SAAS6B,gBACpBxD,KAAK6C,eAEJ,YAAAe,wBAAP,WACE,OAAkB,UAAV5D,KAAK0B,KAA+B1B,KAAK2B,SAAS6B,eACE,IAAxB,SAA/BxD,KAAK2B,SAAS6B,gBACfxD,KAAK+C,eAEJ,YAAAc,kBAAP,WACE,OAAiB,UAAV7D,KAAKyB,GACG,UAAVzB,KAAK0B,GAA4B1B,KAAK2B,SAASmC,eAAiB,EACjE,GAER,EAhHA,GAAa,EAAA7B,gBAuHb,iBACE,WAES6B,EAEAN,QAFA,IAAAM,MAAA,QAEA,IAAAN,OAA0B,GAF1B,KAAAM,iBAEA,KAAAN,iBAcX,OAXS,YAAAzB,MAAP,WACE,OAAO,IAAIH,EAAc5B,KAAK8D,eAAgB9D,KAAKwD,iBAO9C,YAAAF,QAAP,WACE,OAA+B,IAAxBtD,KAAK8D,gBAEhB,EAnBA,GAAa,EAAAlC,iB,uGCzHb,aAMA,OAEA,wBAYE,YACUmC,EACRC,EACAC,EACQC,EACEC,GAJF,KAAAJ,aAGA,KAAAG,SACE,KAAAC,UAdJ,KAAAC,iBAA2B,EAC3B,KAAAC,kBAA4B,EAC5B,KAAAC,iBAA2B,EAC3B,KAAAC,kBAA4B,EAC5B,KAAAC,gBAA0B,EAC1B,KAAAC,eAAyB,EAW/BzE,KAAK0E,QAAUC,SAASC,cAAc,UACtC5E,KAAK0E,QAAQG,UAAUC,IAAI,SAASd,WACpChE,KAAK0E,QAAQK,MAAMd,OAASA,EAAOe,WACnChF,KAAKiF,cACLjF,KAAK+D,WAAWmB,YAAYlF,KAAK0E,SAG5B,UACL1E,KAAK+D,WAAWoB,YAAYnF,KAAK0E,SAC7B1E,KAAKoF,YACPpF,KAAKoF,WAAWC,UAIZ,cACNrF,KAAKsF,KAAO,EAAApI,aAAa8C,KAAK0E,QAAQa,WAAW,KAAM,CAACC,MAAOxF,KAAKkE,UAE/DlE,KAAKkE,QACRlE,KAAKyF,YAIF,iBAAiBC,IACjB,OAAOA,IACP,QAAQA,IACR,aAAaA,IACb,cAAcA,EAAoBC,EAAkBC,IACpD,mBAAmBF,EAAoBvE,EAAqCC,EAAmCd,GAA4B,IAE3I,UAAUoF,EAAoBG,GACnC7F,KAAK8F,kBAAkBJ,EAAUG,GAGzB,iBAAiBH,EAAoBF,GAE7C,GAAIA,IAAUxF,KAAKkE,OACjB,OAIF,MAAM6B,EAAY/F,KAAK0E,QACvB1E,KAAKkE,OAASsB,EAEdxF,KAAK0E,QAAU1E,KAAK0E,QAAQsB,YAC5BhG,KAAKiF,cACLjF,KAAK+D,WAAWkC,aAAajG,KAAK0E,QAASqB,GAG3C/F,KAAK8F,kBAAkBJ,EAAU1F,KAAKmE,SACtCnE,KAAKkG,cAAcR,EAAU,EAAGA,EAAS5E,KAAO,GAQ1C,kBAAkB4E,EAAoBG,GACxC7F,KAAKoE,kBAAoB,GAAKpE,KAAKqE,mBAAqB,IAG5DrE,KAAKoF,WAAa,EAAAe,iBAAiBT,EAAUG,EAAU7F,KAAKoE,iBAAkBpE,KAAKqE,mBACnFrE,KAAKoF,WAAWgB,UAGX,OAAOV,EAAoBW,GAChCrG,KAAKsE,iBAAmB+B,EAAIC,gBAC5BtG,KAAKuE,kBAAoB8B,EAAIE,iBAC7BvG,KAAKoE,iBAAmBiC,EAAIG,gBAC5BxG,KAAKqE,kBAAoBgC,EAAII,iBAC7BzG,KAAKwE,gBAAkB6B,EAAIK,eAC3B1G,KAAKyE,eAAiB4B,EAAIM,cAC1B3G,KAAK0E,QAAQkC,MAAQP,EAAIQ,kBACzB7G,KAAK0E,QAAQoC,OAAST,EAAIU,mBAC1B/G,KAAK0E,QAAQK,MAAM6B,MAAWP,EAAIW,YAAP,KAC3BhH,KAAK0E,QAAQK,MAAM+B,OAAYT,EAAIY,aAAP,KAGvBjH,KAAKkE,QACRlE,KAAKyF,YAGPzF,KAAK8F,kBAAkBJ,EAAU1F,KAAKmE,SAY9B,WAAW+C,EAAWC,EAAWP,EAAeE,GACxD9G,KAAKsF,KAAK8B,SACRF,EAAIlH,KAAKsE,iBACT6C,EAAInH,KAAKuE,kBACTqC,EAAQ5G,KAAKsE,iBACbwC,EAAS9G,KAAKuE,mBASR,uBAAuB2C,EAAWC,EAAWP,EAAgB,GACrE5G,KAAKsF,KAAK8B,SACRF,EAAIlH,KAAKsE,kBACR6C,EAAI,GAAKnH,KAAKuE,kBAAoB7J,OAAO2M,iBAAmB,EAC7DT,EAAQ5G,KAAKsE,iBACb5J,OAAO2M,kBASD,oBAAoBH,EAAWC,EAAWP,GAClD5G,KAAKsF,KAAK8B,SACRF,EAAIlH,KAAKsE,iBACT6C,EAAInH,KAAKuE,kBACT7J,OAAO2M,iBAAmBT,EAC1B5G,KAAKuE,mBASC,kBAAkB2C,EAAWC,EAAWP,EAAeE,GAC/D9G,KAAKsF,KAAKgC,UAAY5M,OAAO2M,iBAC7BrH,KAAKsF,KAAKiC,WACRL,EAAIlH,KAAKsE,iBAAmB5J,OAAO2M,iBAAmB,EACtDF,EAAInH,KAAKuE,kBAAqB7J,OAAO2M,iBAAmB,EACxDT,EAAQ5G,KAAKsE,iBAAmB5J,OAAO2M,iBACtCP,EAAS9G,KAAKuE,kBAAqB7J,OAAO2M,kBAMrC,YACJrH,KAAKkE,OACPlE,KAAKsF,KAAKkC,UAAU,EAAG,EAAGxH,KAAK0E,QAAQkC,MAAO5G,KAAK0E,QAAQoC,SAE3D9G,KAAKsF,KAAKmC,UAAYzH,KAAKmE,QAAQuD,WAAWC,IAC9C3H,KAAKsF,KAAK8B,SAAS,EAAG,EAAGpH,KAAK0E,QAAQkC,MAAO5G,KAAK0E,QAAQoC,SAWpD,YAAYI,EAAWC,EAAWP,EAAeE,GACrD9G,KAAKkE,OACPlE,KAAKsF,KAAKkC,UACRN,EAAIlH,KAAKsE,iBACT6C,EAAInH,KAAKuE,kBACTqC,EAAQ5G,KAAKsE,iBACbwC,EAAS9G,KAAKuE,oBAEhBvE,KAAKsF,KAAKmC,UAAYzH,KAAKmE,QAAQuD,WAAWC,IAC9C3H,KAAKsF,KAAK8B,SACRF,EAAIlH,KAAKsE,iBACT6C,EAAInH,KAAKuE,kBACTqC,EAAQ5G,KAAKsE,iBACbwC,EAAS9G,KAAKuE,oBAcV,mBAAmBmB,EAAoBkC,EAAgBV,EAAWC,GAC1EnH,KAAKsF,KAAKuC,KAAO7H,KAAK8H,SAASpC,GAAU,GAAO,GAChD1F,KAAKsF,KAAKyC,aAAe,SACzB/H,KAAKgI,SAAStC,EAAUyB,GACxBnH,KAAKsF,KAAK2C,SACRL,EAAKM,WACLhB,EAAIlH,KAAKsE,iBAAmBtE,KAAKwE,gBACjC2C,EAAInH,KAAKuE,kBAAoBvE,KAAKyE,eAAiBzE,KAAKqE,kBAAoB,GAQxE,SAASqB,EAAoByB,GACnCnH,KAAKsF,KAAK6C,YACVnI,KAAKsF,KAAK8C,KACR,EACAjB,EAAInH,KAAKuE,kBACTmB,EAAS7E,KAAOb,KAAKsE,iBACrBtE,KAAKuE,mBACPvE,KAAKsF,KAAK+C,OAQF,SAAS3C,EAAoBvD,EAAiBI,GAItD,MAAO,GAFWA,EAAW,SAAW,MADrBJ,EAASuD,EAAS4C,UAAU,kBAAoB5C,EAAS4C,UAAU,iBAGjD5C,EAAS4C,UAAU,YAAc5N,OAAO2M,sBAAsB3B,EAAS4C,UAAU,mB,kIC7P1H,aACA,QAaMC,EAAyC,GAQ/C,4BACE7C,EACA8C,EACAhC,EACAC,GAEA,MAAMgC,EAAY,EAAAC,eAAelC,EAAiBC,EAAkBf,EAAU8C,GAG9E,IAAK,IAAI/N,EAAI,EAAGA,EAAI8N,EAAezJ,OAAQrE,IAAK,CAC9C,MAAMkO,EAAQJ,EAAe9N,GACvBmO,EAAeD,EAAME,QAAQC,QAAQpD,GAC3C,GAAIkD,GAAgB,EAAG,CACrB,GAAI,EAAAG,aAAaJ,EAAMK,OAAQP,GAC7B,OAAOE,EAAMM,MAGc,IAAzBN,EAAME,QAAQ/J,QAChB6J,EAAMM,MAAM5D,UACZkD,EAAeW,OAAOzO,EAAG,IAEzBkO,EAAME,QAAQK,OAAON,EAAc,GAErC,OAKJ,IAAK,IAAInO,EAAI,EAAGA,EAAI8N,EAAezJ,OAAQrE,IAAK,CAC9C,MAAMkO,EAAQJ,EAAe9N,GAC7B,GAAI,EAAAsO,aAAaJ,EAAMK,OAAQP,GAG7B,OADAE,EAAME,QAAQM,KAAKzD,GACZiD,EAAMM,MAIjB,MAAMG,EAAiC,CACrCH,MAAO,IAAI,EAAAI,eAAe1E,SAAU8D,GACpCO,OAAQP,EACRI,QAAS,CAACnD,IAGZ,OADA6C,EAAeY,KAAKC,GACbA,EAASH,OAOlB,mCAAwCvD,GACtC,IAAK,IAAIjL,EAAI,EAAGA,EAAI8N,EAAezJ,OAAQrE,IAAK,CAC9C,MAAM6O,EAAQf,EAAe9N,GAAGoO,QAAQC,QAAQpD,GAChD,IAAe,IAAX4D,EAAc,CACyB,IAArCf,EAAe9N,GAAGoO,QAAQ/J,QAE5ByJ,EAAe9N,GAAGwO,MAAM5D,UACxBkD,EAAeW,OAAOzO,EAAG,IAGzB8N,EAAe9N,GAAGoO,QAAQK,OAAOI,EAAO,GAE1C,U,kIC/EN,MAAMC,EAAqB,CACzB5B,IAAK,GACL6B,KAAM,GAGR,0BAA+BhD,EAAyBC,EAA0Bf,EAAoB8C,GAEpG,MAAMiB,EAA0B,CAC9BC,WAAYlB,EAAOkB,WACnBhC,WAAYc,EAAOd,WACnBiC,OAAQJ,EACRK,aAAcL,EACdM,qBAAsBN,EACtBO,gBAAiBP,EAGjBQ,KAAMvB,EAAOuB,KAAKC,QAClBC,cAAezB,EAAOyB,eAExB,MAAO,CACL5C,iBAAkB3M,OAAO2M,iBACzBb,kBACAC,mBACAyD,WAAYxE,EAAS4C,UAAU,cAC/B6B,SAAUzE,EAAS4C,UAAU,YAC7B8B,WAAY1E,EAAS4C,UAAU,cAC/B+B,eAAgB3E,EAAS4C,UAAU,kBACnCgC,kBAAmB5E,EAAS4C,UAAU,qBACtCiC,2BAA4B7E,EAAS4C,UAAU,8BAC/CkC,qBAAsB9E,EAAS4C,UAAU,wBACzCE,OAAQiB,IAIZ,wBAA6BjP,EAAqB6G,GAChD,IAAK,IAAI5G,EAAI,EAAGA,EAAID,EAAEgO,OAAOuB,KAAKjL,OAAQrE,IACxC,GAAID,EAAEgO,OAAOuB,KAAKtP,GAAG+O,OAASnI,EAAEmH,OAAOuB,KAAKtP,GAAG+O,KAC7C,OAAO,EAGX,OAAOhP,EAAE6M,mBAAqBhG,EAAEgG,kBAC5B7M,EAAE0P,aAAe7I,EAAE6I,YACnB1P,EAAE2P,WAAa9I,EAAE8I,UACjB3P,EAAE4P,aAAe/I,EAAE+I,YACnB5P,EAAE6P,iBAAmBhJ,EAAEgJ,gBACvB7P,EAAE8P,oBAAsBjJ,EAAEiJ,mBAC1B9P,EAAEgM,kBAAoBnF,EAAEmF,iBACxBhM,EAAEiM,mBAAqBpF,EAAEoF,kBACzBjM,EAAE+P,6BAA+BlJ,EAAEkJ,4BACnC/P,EAAEgQ,uBAAyBnJ,EAAEmJ,sBAC7BhQ,EAAEgO,OAAOkB,aAAerI,EAAEmH,OAAOkB,YACjClP,EAAEgO,OAAOd,aAAerG,EAAEmH,OAAOd,YAGvC,sBAA2B+C,GACzB,OAA4C,WAAxB,SAAZA,IAA8F,WAAxB,SAAZA,K,sJC5DvD,EAAAC,uBAAyB,IACzB,EAAAC,YAAc,GAEd,EAAAC,wBAA0B,G,scCFvC,YACA,OACA,OAKA,yE,OAQS,EAAAC,QAAU,EACV,EAAApJ,GAAK,EACL,EAAAC,GAAK,EACL,EAAAC,SAA2B,IAAI,EAAAC,cAC/B,EAAAkJ,aAAe,G,EAoExB,OAhF8B,OAEd,EAAAC,aAAd,SAA2BjP,GACzB,IAAMkP,EAAM,IAAIC,EAEhB,OADAD,EAAIE,gBAAgBpP,GACbkP,GASF,YAAAG,WAAP,WACE,OAAsB,QAAfnL,KAAK6K,SAGP,YAAAO,SAAP,WACE,OAAOpL,KAAK6K,SAAW,IAGlB,YAAA3C,SAAP,WACE,OAAmB,QAAflI,KAAK6K,QACA7K,KAAK8K,aAEK,QAAf9K,KAAK6K,QACA,EAAAQ,oBAAmC,QAAfrL,KAAK6K,SAE3B,IAQF,YAAAS,QAAP,WACE,OAAQtL,KAAKmL,aACTnL,KAAK8K,aAAaS,WAAWvL,KAAK8K,aAAahM,OAAS,GACzC,QAAfkB,KAAK6K,SAGJ,YAAAK,gBAAP,SAAuBpP,GACrBkE,KAAKyB,GAAK3F,EAAM,EAAAoD,sBAChBc,KAAK0B,GAAK,EACV,IAAI8J,GAAW,EAEf,GAAI1P,EAAM,EAAAqD,sBAAsBL,OAAS,EACvC0M,GAAW,OAER,GAA2C,IAAvC1P,EAAM,EAAAqD,sBAAsBL,OAAc,CACjD,IAAM2M,EAAO3P,EAAM,EAAAqD,sBAAsBoM,WAAW,GAGpD,GAAI,OAAUE,GAAQA,GAAQ,MAAQ,CACpC,IAAMC,EAAS5P,EAAM,EAAAqD,sBAAsBoM,WAAW,GAClD,OAAUG,GAAUA,GAAU,MAChC1L,KAAK6K,QAA6B,MAAjBY,EAAO,OAAkBC,EAAS,MAAS,MAAY5P,EAAM,EAAAsD,wBAA0B,GAGxGoM,GAAW,OAIbA,GAAW,OAIbxL,KAAK6K,QAAU/O,EAAM,EAAAqD,sBAAsBoM,WAAW,GAAMzP,EAAM,EAAAsD,wBAA0B,GAE1FoM,IACFxL,KAAK8K,aAAehP,EAAM,EAAAqD,sBAC1Ba,KAAK6K,QAAU,QAA4B/O,EAAM,EAAAsD,wBAA0B,KAIxE,YAAAuM,cAAP,WACE,MAAO,CAAC3L,KAAKyB,GAAIzB,KAAKkI,WAAYlI,KAAKoL,WAAYpL,KAAKsL,YAE5D,EAhFA,CAA8B,EAAArJ,eAAjB,EAAAgJ,Y,mGCPb,cAKA,oBAKE,YAAoBW,GAAA,KAAAA,YAElBrO,QAAQsO,IAAI,mBAGP,SAASnG,GACd,IAAKA,EAASoG,QACZ,MAAM,IAAInO,MAAM,oDAGlBqC,KAAK+L,UAAYrG,EAC2BA,EAAUsG,MAAMC,eAA5D,MACMzD,EAA0B9C,EAAUsG,MAAME,cAAc1D,OAC9DxI,KAAKmM,UAAY,IAAI,EAAAC,eAAe1G,EAAU8C,EAAQxI,KAAK4L,WAC3D5L,KAAKqM,MAAQ,IAAIC,OAAOC,MAAMC,QAAQxM,KAAKmM,UAAUM,WAAW5F,kBAAmB7G,KAAKmM,UAAUM,WAAW1F,mBAAoB,GAG5H,UACL,IAAK/G,KAAK+L,UACR,MAAM,IAAIpO,MAAM,qDAElB,MAAM+O,EAAiC1M,KAAK+L,UAAkBC,MAAMC,eACpES,EAAcC,YAAa3M,KAAK+L,UAAkBC,MAAMY,mBACxDF,EAAcG,SAAS7M,KAAK+L,UAAUlL,KAAMb,KAAK+L,UAAUjL,MAC3Dd,KAAKmM,eAAYW,EAGnB,mB,MACE,OAAqB,QAArB,EAAO9M,KAAKmM,iBAAS,eAAEY,aAGzB,qB,MACE,OAAqB,QAArB,EAAO/M,KAAKmM,iBAAS,eAAEa,eAGzB,qB,MACE,OAAqB,QAArB,EAAOhN,KAAKmM,iBAAS,eAAEc,eAGzB,iBACE,OAAOjN,KAAKqM,MAGP,oB,MACS,QAAd,EAAArM,KAAKmM,iBAAS,SAAEe,iBAGX,O,MACS,QAAd,EAAAlN,KAAKmM,iBAAS,SAAEgB,WAAW,EAAG,O,sGC3DlC,cACA,QACA,QACA,OAEA,QAEA,OACA,QACA,OAKA,QACA,OAEA,MAAaf,UAAuB,EAAAgB,WAqBlC,YACUrB,EACA5H,EACAyH,GAgCR,GA9BAyB,QAJQ,KAAAtB,YACA,KAAA5H,UACA,KAAAyH,YAnBF,KAAA0B,OAAsB,IAAI,EAAAC,YAC1B,KAAAC,UAAsB,IAAI,EAAAvC,SAY1B,KAAAwC,iBAAmB,IAAI,EAAAC,aAU7B1N,KAAKgM,MAAShM,KAAK+L,UAAkBC,MAErChM,KAAK2N,cAAgB,CACnB,IAAI,EAAAC,gBAAgB5N,KAAKgM,MAAM6B,cAAgB,EAAG7N,KAAKmE,QAASnE,KAAKgM,OACrE,IAAI,EAAA8B,kBAAkB9N,KAAKgM,MAAM6B,cAAgB,EAAG7N,KAAKmE,QAASnE,KAAKyN,mBAEzEzN,KAAKyM,WAAa,CAChBjG,gBAAiB,EACjBC,iBAAkB,EAClBH,gBAAiB,EACjBC,iBAAkB,EAClBG,eAAgB,EAChBC,cAAe,EACfE,kBAAmB,EACnBE,mBAAoB,EACpBC,YAAa,EACbC,aAAc,EACd8G,gBAAiB,EACjBC,iBAAkB,GAEpBhO,KAAKiO,kBAAoBvT,OAAO2M,iBAChCrH,KAAKkO,oBAEL3Q,QAAQsO,IAAI,yCAEZ7L,KAAK0E,QAAUC,SAASC,cAAc,UACtC5E,KAAKmO,IAAMnO,KAAK4L,WAEX5L,KAAKmO,IAAO,MAAM,IAAIxQ,MAAM,wBAA0BqC,KAAKmO,KAEhEnO,KAAKgM,MAAM6B,cAAe3I,YAAYlF,KAAK0E,SAC3C1E,KAAKoO,mBAAqB,IAAI,EAAAC,kBAAkBrO,KAAK+L,UAAW/L,KAAKmE,QAASnE,KAAKmO,IAAKnO,KAAKyM,YAC7FzM,KAAKsO,eAAiB,IAAI,EAAAC,oBAAoBvO,KAAK+L,UAAW/L,KAAKmE,QAASnE,KAAKmO,IAAKnO,KAAKyM,YAE3FzM,KAAKwO,oBACLxO,KAAKyO,YAAc9J,SAAS+J,KAAKC,SAAS3O,KAAKgM,MAAM6B,eA5CvD,sBAA4D,OAAO7N,KAAKyN,iBAAiBmB,MA+CzF,qBAEE,OAAO5O,KAAKsO,eAAeO,kBAG7B,qBAEE,OAAO7O,KAAKsO,eAAerB,eAG7B,oBAEE,OAAOjN,KAAKsO,eAAeQ,cAGtB,UACL9O,KAAK2N,cAAcoB,QAAQjU,GAAKA,EAAEuK,WAClCrF,KAAKgM,MAAM6B,cAAe1I,YAAYnF,KAAK0E,SAC3C2I,MAAMhI,UAGR,mB,MACE,OAAsB,QAAtB,EAAOrF,KAAKoF,kBAAU,eAAE4J,YAGnB,UAAUxG,GACfxI,KAAKmE,QAAUqE,EAEfxI,KAAK2N,cAAcoB,QAAQjU,IACzBA,EAAEmU,UAAUjP,KAAK+L,UAAW/L,KAAKmE,SACjCrJ,EAAEoU,MAAMlP,KAAK+L,aAGf/L,KAAKoO,mBAAmBa,YACxBjP,KAAKsO,eAAeW,YAEpBjP,KAAK8F,oBAEL9F,KAAKoO,mBAAmBe,gBAAgBnP,KAAKsN,OAAOlN,WACpDJ,KAAKsO,eAAea,gBAAgBnP,KAAKsN,QAGzCtN,KAAKsN,OAAO8B,QACZpP,KAAKsN,OAAO+B,iBAGP,2BAGDrP,KAAKiO,oBAAsBvT,OAAO2M,mBACpCrH,KAAKiO,kBAAoBvT,OAAO2M,iBAChCrH,KAAK6M,SAAS7M,KAAK+L,UAAUlL,KAAMb,KAAK+L,UAAUjL,OAI/C,SAASD,EAAcC,GAE5Bd,KAAKkO,oBAELlO,KAAKsN,OAAOgC,OAAOtP,KAAK+L,UAAUlL,KAAMb,KAAK+L,UAAUjL,MACvDd,KAAKoO,mBAAmBvB,WAGxB7M,KAAK2N,cAAcoB,QAAQjU,GAAKA,EAAEwU,OAAOtP,KAAK+L,UAAW/L,KAAKyM,aAG9DzM,KAAK0E,QAAQkC,MAAQ5G,KAAKyM,WAAW5F,kBACrC7G,KAAK0E,QAAQoC,OAAS9G,KAAKyM,WAAW1F,mBACtC/G,KAAK0E,QAAQK,MAAM6B,MAAW5G,KAAKyM,WAAWzF,YAAnB,KAC3BhH,KAAK0E,QAAQK,MAAM+B,OAAY9G,KAAKyM,WAAWxF,aAAnB,KAG5BjH,KAAKgM,MAAM6B,cAAe9I,MAAM6B,MAAW5G,KAAKyM,WAAWzF,YAAnB,KACxChH,KAAKgM,MAAM6B,cAAe9I,MAAM+B,OAAY9G,KAAKyM,WAAWxF,aAAnB,KACzCjH,KAAKsO,eAAeiB,cAAcvP,KAAKyM,YACvCzM,KAAKsO,eAAezB,WAEpB7M,KAAK8F,oBAGL9F,KAAKsN,OAAO8B,QACZpP,KAAKsN,OAAO+B,iBAGP,oBACLrP,KAAK6M,SAAS7M,KAAK+L,UAAUlL,KAAMb,KAAK+L,UAAUjL,MAG7C,SACLd,KAAK2N,cAAcoB,QAAQjU,GAAKA,EAAE0U,OAAOxP,KAAK+L,YAGzC,UACL/L,KAAK2N,cAAcoB,QAAQjU,GAAKA,EAAE2U,QAAQzP,KAAK+L,YAG1C,mBAAmB5K,EAAqCC,EAAmCd,GAChGN,KAAK2N,cAAcoB,QAAQjU,GAAKA,EAAE4U,mBAAmB1P,KAAK+L,UAAW5K,EAAOC,EAAKd,IAEjFN,KAAK2P,sBAAsBxO,EAAOC,EAAKd,GAEvCN,KAAKoO,mBAAmBe,gBAAgBnP,KAAKsN,OAAOlN,WACpDJ,KAAKsO,eAAea,gBAAgBnP,KAAKsN,QAEzCtN,KAAKyN,iBAAiBmC,KAAK,CAAEzO,MAAO,EAAGC,IAAKpB,KAAK+L,UAAUjL,KAAO,IAG7D,eACLd,KAAK2N,cAAcoB,QAAQjU,GAAKA,EAAE+U,aAAa7P,KAAK+L,YAG/C,mBACL/L,KAAK2N,cAAcoB,QAAQjU,GAAKA,EAAEgV,iBAAiB9P,KAAK+L,YACxD/L,KAAKkO,oBACLlO,KAAK8F,oBAQC,oBACN,GAAI9F,KAAKyM,WAAWjG,iBAAmB,GAAKxG,KAAKyM,WAAWhG,kBAAoB,EAG9E,YADAzG,KAAKyO,aAAc,GAIrB,MAAMxF,EAAQ,EAAA9C,iBAAiBnG,KAAK+L,UAAW/L,KAAKmE,QAASnE,KAAKyM,WAAWjG,gBAC9CxG,KAAKyM,WAAWhG,kBAC/C,KAAM,uBAAwBwC,GAE5B,MAAM,IAAItL,MAAM,2DAElBqC,KAAKoF,WAAa6D,EAClBjJ,KAAKoF,WAAWgB,SAChBpG,KAAKsO,eAAeyB,SAAS/P,KAAKoF,YAElC7H,QAAQsO,IAAI,kDAGP,iB,MACU,QAAf,EAAA7L,KAAKoF,kBAAU,SAAE4K,eACjBhQ,KAAKsN,OAAO8B,QACZpP,KAAKiQ,aAAa,EAAGjQ,KAAK+L,UAAUjL,KAAO,GAC3Cd,KAAKsO,eAAea,gBAAgBnP,KAAKsN,QACzCtN,KAAKyN,iBAAiBmC,KAAK,CAAEzO,MAAO,EAAGC,IAAKpB,KAAK+L,UAAUjL,KAAO,IAG7D,QACLd,KAAK2N,cAAcoB,QAAQjU,GAAKA,EAAEoU,MAAMlP,KAAK+L,YAGxC,wBAAwBmE,GAC7B,OAAQ,EAGH,0BAA0BC,GAC/B,OAAO,EAGF,WAAWhP,EAAeC,GAC/B,IAAKpB,KAAKyO,YAAa,CACrB,KAAI9J,SAAS+J,KAAKC,SAAS3O,KAAKgM,MAAM6B,gBAAoB7N,KAAKgM,MAAcoE,iBAAiBxJ,OAAU5G,KAAKgM,MAAcoE,iBAAiBtJ,QAK1I,OAJA9G,KAAKkO,oBACLlO,KAAK8F,oBACL9F,KAAKyO,aAAc,EAOvBzO,KAAK2N,cAAcoB,QAAQjU,GAAKA,EAAEoL,cAAclG,KAAK+L,UAAW5K,EAAOC,IAGnEpB,KAAKsO,eAAe+B,eACtBrQ,KAAKsN,OAAO8B,QACZpP,KAAKsN,OAAO+B,kBAIdrP,KAAKiQ,aAAa9O,EAAOC,GAEzBpB,KAAKsO,eAAegC,QASf,WAAWnP,EAAeC,GAC/B,IAAKpB,KAAKyO,YAAa,CACrB,KAAI9J,SAAS+J,KAAKC,SAAS3O,KAAKgM,MAAM6B,gBAAoB7N,KAAKgM,MAAcoE,iBAAiBxJ,OAAU5G,KAAKgM,MAAcoE,iBAAiBtJ,QAK1I,OAJA9G,KAAKkO,oBACLlO,KAAK8F,oBACL9F,KAAKyO,aAAc,EAOvBzO,KAAK2N,cAAcoB,QAAQjU,GAAKA,EAAEoL,cAAclG,KAAK+L,UAAW5K,EAAOC,IAGnEpB,KAAKsO,eAAe+B,eACtBrQ,KAAKsN,OAAO8B,QACZpP,KAAKsN,OAAO+B,kBAIdrP,KAAKiQ,aAAa9O,EAAOC,GAEzBpB,KAAKsO,eAAeiC,cAQd,aAAapP,EAAeC,GAClC,MAAMsE,EAAW1F,KAAKgM,MAEtB,IAAK,IAAI7E,EAAIhG,EAAOgG,GAAK/F,EAAK+F,IAAK,CACjC,MAAMqJ,EAAMrJ,EAAIzB,EAAS+K,OAAOC,MAC1BC,EAAOjL,EAAS+K,OAAOG,MAAMlV,IAAI8U,GACvCxQ,KAAKsN,OAAOnN,YAAYgH,GAAK,EAC7B,IAAK,IAAID,EAAI,EAAGA,EAAIxB,EAAS7E,KAAMqG,IAAK,CACtCyJ,EAAKE,SAAS3J,EAAGlH,KAAKwN,WAEtB,MAAMsD,EAAQ9Q,KAAKwN,UAAUtF,WAC7B,IAAIuD,EAAOzL,KAAKwN,UAAUlC,UAC1B,MAAM7Q,GAAM0M,EAAIzB,EAAS7E,KAAQqG,GAAK,EAAAtH,+BAElC6L,IAAS,EAAAjM,iBACXQ,KAAKsN,OAAOnN,YAAYgH,GAAKD,EAAI,GAI/BlH,KAAKsN,OAAOrN,MAAMxF,KAAOgR,GAC3BzL,KAAKsN,OAAOrN,MAAMxF,EAAI,EAAAoF,0BAA4BG,KAAKwN,UAAU9L,IACjE1B,KAAKsN,OAAOrN,MAAMxF,EAAI,EAAAqF,0BAA4BE,KAAKwN,UAAU/L,KAK/DqP,EAAMhS,OAAS,IACjB2M,GAAc,EAAA1L,wBAIhBC,KAAKsN,OAAOrN,MAAMxF,GAAKgR,EACvBzL,KAAKsN,OAAOrN,MAAMxF,EAAI,EAAAoF,wBAA0BG,KAAKwN,UAAU9L,GAC/D1B,KAAKsN,OAAOrN,MAAMxF,EAAI,EAAAqF,wBAA0BE,KAAKwN,UAAU/L,GAE/DzB,KAAKsO,eAAeyC,WAAW7J,EAAGC,EAAGsE,EAAMzL,KAAKwN,UAAU9L,GAAI1B,KAAKwN,UAAU/L,GAAIqP,KAKrF9Q,KAAKoO,mBAAmB4C,kBAAkBhR,KAAKsN,QAGzC,sBAAsBnM,EAAqCC,EAAmCd,GACpG,MAAMoF,EAAW1F,KAAK+L,UAGtB,IAAK5K,IAAUC,GAAQD,EAAM,KAAOC,EAAI,IAAMD,EAAM,KAAOC,EAAI,GAE7D,YADApB,KAAKsN,OAAO+B,iBAKd,MAAM9O,EAAmBY,EAAM,GAAKuE,EAAS+K,OAAOQ,OAAOC,UACrD1Q,EAAiBY,EAAI,GAAKsE,EAAS+K,OAAOQ,OAAOC,UACjDzQ,EAAyB7B,KAAKF,IAAI6B,EAAkB,GACpDG,EAAuB9B,KAAKC,IAAI2B,EAAgBkF,EAAS5E,KAAO,GAGlEL,GAA0BiF,EAAS5E,MAAQJ,EAAuB,EACpEV,KAAKsN,OAAO+B,kBAIdrP,KAAKsN,OAAOlN,UAAUC,cAAe,EACrCL,KAAKsN,OAAOlN,UAAUE,iBAAmBA,EACzCN,KAAKsN,OAAOlN,UAAUG,iBAAmBA,EACzCP,KAAKsN,OAAOlN,UAAUI,eAAiBA,EACvCR,KAAKsN,OAAOlN,UAAUK,uBAAyBA,EAC/CT,KAAKsN,OAAOlN,UAAUM,qBAAuBA,EAC7CV,KAAKsN,OAAOlN,UAAUO,SAAWQ,EAAM,GACvCnB,KAAKsN,OAAOlN,UAAUQ,OAASQ,EAAI,IAM7B,oBAIApB,KAAKgM,MAAcoE,iBAAiBxJ,OAAW5G,KAAKgM,MAAcoE,iBAAiBtJ,SAWzF9G,KAAKyM,WAAWjG,gBAAkB5H,KAAKuS,MAAOnR,KAAKgM,MAAcoE,iBAAiBxJ,MAAQ5G,KAAKiO,mBAK/FjO,KAAKyM,WAAWhG,iBAAmB7H,KAAKwS,KAAMpR,KAAKgM,MAAcoE,iBAAiBtJ,OAAS9G,KAAKiO,mBAMhGjO,KAAKyM,WAAWlG,iBAAmB3H,KAAKuS,MAAMnR,KAAKyM,WAAWhG,iBAAmBzG,KAAK+L,UAAUzD,UAAU,eAI1GtI,KAAKyM,WAAW9F,cAA2D,IAA3C3G,KAAK+L,UAAUzD,UAAU,cAAsB,EAAI1J,KAAKyS,OAAOrR,KAAKyM,WAAWlG,iBAAmBvG,KAAKyM,WAAWhG,kBAAoB,GAGtKzG,KAAKyM,WAAWnG,gBAAkBtG,KAAKyM,WAAWjG,gBAAkB5H,KAAKyS,MAAMrR,KAAK+L,UAAUzD,UAAU,kBAIxGtI,KAAKyM,WAAW/F,eAAiB9H,KAAKuS,MAAMnR,KAAK+L,UAAUzD,UAAU,iBAAmB,GAIxFtI,KAAKyM,WAAW1F,mBAAqB/G,KAAK+L,UAAUjL,KAAOd,KAAKyM,WAAWlG,iBAC3EvG,KAAKyM,WAAW5F,kBAAoB7G,KAAK+L,UAAUlL,KAAOb,KAAKyM,WAAWnG,gBAO1EtG,KAAKyM,WAAWxF,aAAerI,KAAKyS,MAAMrR,KAAKyM,WAAW1F,mBAAqB/G,KAAKiO,mBACpFjO,KAAKyM,WAAWzF,YAAcpI,KAAKyS,MAAMrR,KAAKyM,WAAW5F,kBAAoB7G,KAAKiO,mBAelFjO,KAAKyM,WAAWuB,iBAAmBhO,KAAKyM,WAAWlG,iBAAmBvG,KAAKiO,kBAC3EjO,KAAKyM,WAAWsB,gBAAkB/N,KAAKyM,WAAWnG,gBAAkBtG,KAAKiO,oBAlb7E,oB,2GCjBA,aAGA,OACA,OACA,QACA,OAIA,OAsBA,4BAqCE,YACUlC,EACA5H,EACAgK,EACAmD,GAHA,KAAAvF,YACA,KAAA5H,UACA,KAAAgK,MACA,KAAAmD,cArCF,KAAAC,cAAwB,EAQxB,KAAAC,UAAuB,CAC7BC,MAAO,EACPC,WAAY,IAAI7T,aAAa,GAE7B8T,eAAgB,IAAI9T,aAAa,GACjC+T,cAAe,IAAI/T,aAAa,GAChCgU,gBAAiB,IAAIhU,aAAa,GAElCiU,kBAAmB,CACjB,IAAIjU,aAAa,GACjB,IAAIA,aAAa,IAEnBkU,oBAAqB,IAAIlU,aAAa,IAmBtC,MAAMf,EAAKkD,KAAKmO,IAEhBnO,KAAKgS,UAAY,IAAInU,aA/CN,MAgDfmC,KAAKiS,IAAM,IAAIpU,aAhDA,MAiDfmC,KAAKkS,IAAM,IAAIhS,YAjDA,MAkDhB3C,QAAQsO,IAAI,wBAAyB7L,KAAKgS,UAAUvB,OAAO0B,YAC3D5U,QAAQsO,IAAI,kBAAmB7L,KAAKiS,IAAIxB,OAAO0B,YAG9CnS,KAAK8O,cAAgB,EAAA5R,aAAaJ,EAAGsV,iBACrCtV,EAAGuV,YAAYvV,EAAGwV,WAAYtS,KAAK8O,eACnChS,EAAGyV,WAAWzV,EAAGwV,WAAY,EAAGxV,EAAG0V,KAAM,EAAG,EAAG,EAAG1V,EAAG0V,KAAM1V,EAAG2V,cAAe,IAAIC,WAAW,CAAC,EAAG,EAAG,IAAK,OACxG5V,EAAG6V,cAAc7V,EAAGwV,WAAYxV,EAAG8V,eAAgB9V,EAAG+V,eACtD/V,EAAG6V,cAAc7V,EAAGwV,WAAYxV,EAAGgW,eAAgBhW,EAAG+V,eAEtD7S,KAAK+S,sBAAwB,IAAIzG,OAAOC,MAAMyG,eAE9ChT,KAAKiT,gBAAkB,IAAI3G,OAAOC,MAAM2G,gBAAgBlT,KAAKgS,UAAW,GACxEhS,KAAKmT,eAAiB,IAAI7G,OAAOC,MAAM2G,gBAAgBlT,KAAKiS,IAAK,GACjEjS,KAAKiT,gBAAgBG,MAAQ9G,OAAOC,MAAM8G,iBAC1CrT,KAAKmT,eAAeC,MAAQ9G,OAAOC,MAAM8G,iBAEzCrT,KAAK+S,sBAAsBO,aAAc,WAAYtT,KAAKiT,iBAC1DjT,KAAK+S,sBAAsBO,aAAc,KAAMtT,KAAKmT,gBACpDnT,KAAK+S,sBAAsBQ,SAAU,EACrCvT,KAAK+S,sBAAsBrB,WAAW8B,SAASC,aAAc,EAC7DzT,KAAK+S,sBAAsBrB,WAAWgC,GAAGD,aAAc,EAIvDzT,KAAK+S,sBAAsBY,SAAS,IAAIrH,OAAOC,MAAM2G,gBAAgBlT,KAAKkS,IAAK,IAC/ElS,KAAK+S,sBAAsBzJ,MAAMmK,aAAc,EAG/CzT,KAAK6M,WAGA,WAAW3F,EAAWC,EAAWsE,EAAc/J,EAAYD,EAAYqP,GAE5E9Q,KAAK4T,YAAY5T,KAAKgS,UAAWhS,KAAKiS,IAAKjS,KAAKkS,IAAKhL,EAAGC,EAAGsE,EAAM/J,EAAID,EAAIqP,GACzE9Q,KAAK+S,sBAAsBrB,WAAW8B,SAASC,aAAc,EAC7DzT,KAAK+S,sBAAsBrB,WAAWgC,GAAGD,aAAc,EACvDzT,KAAK+S,sBAAsBzJ,MAAMmK,aAAc,EAG1C,SAKC,YAAYI,EAA0BC,EAAyBC,EACnDC,EAAYC,EAAYC,EAA2BC,EAAaC,EAAatD,GAE/F,MAAMpL,EAAW1F,KAAK+L,UAChBsI,EArGe,IAqGLJ,EAAKvO,EAAS7E,KAAOmT,GAC/BM,EAAqC,GAA3BL,EAAKvO,EAAS7E,KAAOmT,GAGrC,GAAIE,IAAU,EAAA1U,gBAAkB0U,IAAU,EAAAvU,2BAAkCmN,IAAVoH,EAKhE,OAFA,EAAAlT,KAAK6S,EAAY,EAAGQ,EAAQA,EA5GT,GA4GqC,EA3GhC,QA4GxB,EAAArT,KAAK8S,EAAW,EAAGO,EAAQA,EA7GR,GA6GoC,EA5G/B,GAgH1B,IAAIE,EACL,IAAKvU,KAAKwU,OAAU,OAOnB,GALED,EADEzD,GAASA,EAAMhS,OAAS,EACRkB,KAAKwU,OAAOC,+BAA+B3D,EAAOqD,EAAKC,GAEvDpU,KAAKwU,OAAOE,mBAAmBR,EAAOC,EAAKC,IAG1DG,EAKH,OAFA,EAAAvT,KAAK6S,EAAY,EAAGQ,EAAQA,EA5HT,GA4HqC,EA3HhC,QA4HxB,EAAArT,KAAK8S,EAAW,EAAGO,EAAQA,EA7HR,GA6HoC,EA5H/B,GAgI1B,IAAIM,EAAW3U,KAAKsR,YAAY7K,iBAAmBzG,KAAKsR,YAAYvK,mBAChE6N,EAAQX,EAAKvO,EAAS5E,KAAOd,KAAKsR,YAAY7K,iBAC9CoO,EAAQb,EAAKhU,KAAKsR,YAAYvK,mBAAqB/G,KAAKsR,YAAYzK,kBAAoB,EAExFiO,EAAMH,EAAYJ,EAAgBF,OAAQ,EAAIO,EAClDG,EAAUJ,GAAYJ,EAAgBF,OAAOlN,EAAIoN,EAAgBS,KAAK7N,GAAKyN,EAC3EK,EAAUN,GAAaJ,EAAgBF,OAAOnN,EAAK2N,EACnDK,EAAUP,IAAaJ,EAAgBF,OAAOnN,EAAIqN,EAAgBS,KAAK9N,GAAK2N,EAI5EhB,EAAWrS,IACT,CACEyT,EAAMH,EAAK,EACXI,EAAOJ,EAAK,EACZG,EAAMF,EAAQ,EACdG,EAAOH,EAAQ,GACdV,GAEL,IAAIc,EAAoC,GAA3BlB,EAAKvO,EAAS7E,KAAOmT,GAClCD,EAAWvS,IAAI,CAAC2T,EAAQ,EAAGA,EAAQ,EAAGA,EACtBA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,GACH,GAA3BlB,EAAKvO,EAAS7E,KAAOmT,IAErC,IAAIoB,EAAS,EAAMb,EAAgBc,yBAAyBlO,EACxDmO,EAAYF,EAASb,EAAgBgB,cAAcpO,EACnDqO,EAAUjB,EAAgBc,yBAAyBnO,EACnDuO,EAAWD,EAAUjB,EAAgBgB,cAAcrO,EAEvD4M,EAAUtS,IACR,CACEgU,EAASJ,EACTK,EAAUL,EACVI,EAASF,EACTG,EAAUH,GACThB,GAGC,QAAQoB,EAAsBC,GAEpC,MAAO,IAAMD,EAAOC,GAASC,QAAQ,GAAK,KAAOF,EAAOC,EAAU,GAAGC,QAAQ,GAAK,KAAQF,EAAOC,EAAU,GAAGC,QAAQ,GAAK,IAGtH,eAcC,uBAAuB1D,GAC7B,GAAIA,GAAOlS,KAAKmE,QAAQ4F,KAAKjL,OAC3B,MAAM,IAAInB,MAAM,0BAA4BuU,GAE9C,OAAOlS,KAAKmE,QAAQ4F,KAAKmI,GAGpB,WACL,MAAMxM,EAAW1F,KAAK+L,UAGhB8J,EAAWnQ,EAAS7E,KAAO6E,EAAS5E,KArMrB,GAsMrB,GAAId,KAAKwR,UAAUC,QAAUoE,EAC7B,CACE7V,KAAKwR,UAAUC,MAAQoE,EACvB7V,KAAKwR,UAAUE,WAAa,IAAI7T,aAAagY,GAE7CtY,QAAQsO,IAAI,eAAgBgK,GAG5B7V,KAAKwR,UAAUG,eAAiB,IAAI9T,aAAwB,EAAXgY,GACjD7V,KAAKwR,UAAUI,cAAgB,IAAI/T,aAAwB,EAAXgY,GAEhD,IAAK,IAAIpb,EAAI,EAAGA,EAAIuF,KAAKwR,UAAUM,kBAAkBhT,OAAQrE,IAE3DuF,KAAKwR,UAAUM,kBAAkBrX,GAAK,IAAIoD,aAAagY,GAGzD,IAAIpb,EAAI,EACR,IAAK,IAAI0M,EAAI,EAAGA,EAAIzB,EAAS5E,KAAMqG,IAEjC,IAAK,IAAID,EAAI,EAAGA,EAAIxB,EAAS7E,KAAMqG,IAEjClH,KAAKwR,UAAUE,WAAWjX,EAAI,GAAKyM,EAAIxB,EAAS7E,KAChDb,KAAKwR,UAAUE,WAAWjX,EAAI,GAAK0M,EAAIzB,EAAS5E,KAChDrG,GA7Ne,IAmOhB,OAAOqb,EAA2BC,IAyClC,SAAS9M,GACd,MAAMnM,EAAKkD,KAAKmO,IAChBnO,KAAKwU,OAASvL,EAEdnM,EAAGuV,YAAYvV,EAAGwV,WAAYtS,KAAK8O,eACnChS,EAAGyV,WAAWzV,EAAGwV,WAAY,EAAGxV,EAAG0V,KAAM1V,EAAG0V,KAAM1V,EAAG2V,cAAexJ,EAAM+F,aAC1ElS,EAAGkZ,eAAelZ,EAAGwV,YAGhB,cAAc7F,GAClBzM,KAAKsR,YAAc7E,EAGtB,wBACE,OAAOzM,KAAK+S,sBAGd,qBACE,OAAO/S,KAAKiW,sBAGd,gBACE,OAAOjW,KAAKkS,IAGP,aACL,OAAOlS,KAAKwU,QAASxU,KAAKwU,OAAOnE,aAG5B,aAGA,gBAAgB6F,GACrB,MAAMxQ,EAAW1F,KAAK+L,UAEtB/L,KAAKwR,UAAUO,oBAAsB,EAAA/H,MAAMhK,KAAKwR,UAAUE,WAAY,GAEtE,MAAMhQ,EAAM1B,KAAKmE,QAAQ2F,gBAAgBN,OAAS,EAAK,SAEvD,GAAI0M,EAAM9V,UAAUE,iBAAkB,CACpC,MAAMK,EAAWuV,EAAM9V,UAAUO,SAC3BiG,EAAQsP,EAAM9V,UAAUQ,OAASD,EACjCmG,EAASoP,EAAM9V,UAAUM,qBAAuBwV,EAAM9V,UAAUK,uBAAyB,EAC/F,IAAK,IAAI0G,EAAI+O,EAAM9V,UAAUK,uBAAwB0G,EAAI+O,EAAM9V,UAAUK,uBAAyBqG,EAAQK,IACxGnH,KAAKmW,sBAAsBxV,EAAUA,EAAWiG,EAAOO,EAAG+O,EAAOxU,OAE9D,CAEL,MAAMf,EAAWuV,EAAM9V,UAAUG,mBAAqB2V,EAAM9V,UAAUK,uBAAyByV,EAAM9V,UAAUO,SAAW,EACpHyV,EAAiBF,EAAM9V,UAAUK,yBAA2ByV,EAAM9V,UAAUM,qBAAuBwV,EAAM9V,UAAUQ,OAAS8E,EAAS7E,KAC3Ib,KAAKmW,sBAAsBxV,EAAUyV,EAAgBF,EAAM9V,UAAUK,uBAAwByV,EAAOxU,GAGpG,MAAM2U,EAAkBzX,KAAKF,IAAIwX,EAAM9V,UAAUM,qBAAuBwV,EAAM9V,UAAUK,uBAAyB,EAAG,GACpH,IAAK,IAAI0G,EAAI+O,EAAM9V,UAAUK,uBAAyB,EAAG0G,GAAK+O,EAAM9V,UAAUK,uBAAyB4V,EAAiBlP,IACtHnH,KAAKmW,sBAAsB,EAAGC,EAAgBjP,EAAG+O,EAAOxU,GAI1D,GAAIwU,EAAM9V,UAAUK,yBAA2ByV,EAAM9V,UAAUM,qBAAsB,CAEnF,MAAME,EAASsV,EAAM9V,UAAUI,iBAAmB0V,EAAM9V,UAAUM,qBAAuBwV,EAAM9V,UAAUQ,OAAS8E,EAAS7E,KAC3Hb,KAAKmW,sBAAsB,EAAGvV,EAAQsV,EAAM9V,UAAUM,qBAAsBwV,EAAOxU,KAKjF,sBAAsBf,EAAkBC,EAAgBuG,EAAW+O,EAAqBxU,GAC9F,MAAMgE,EAAW1F,KAAK+L,UAChByE,EAAMrJ,EAAIzB,EAAS+K,OAAOQ,OAAOC,UACvC,IAAIP,EACJ,IAAK,IAAIzJ,EAAIvG,EAAUuG,EAAItG,EAAQsG,IAAK,CACtC,MAAMmN,GAAUlN,EAAInH,KAAK+L,UAAUlL,KAAOqG,GAAK,EAAAtH,+BACzC6L,EAAOyK,EAAMjW,MAAMoU,GACzB,IAAI5S,EAAKyU,EAAMjW,MAAMoU,EAAS,EAAAvU,wBAC9B,GAAS,SAAL2B,EAAsB,CACxB,MAAM6U,EAAW,IAAI,EAAArU,cAOrB,OANAqU,EAAS7U,GAAKA,EACd6U,EAAS5U,GAAKwU,EAAMjW,MAAMoU,EAAS,EAAAxU,wBAInC4B,IAAW,UACH6U,EAAS5T,kBACf,KAAK,SACL,KAAK,SACH,MAAMxH,EAAI8E,KAAKuW,uBAAuBD,EAASnT,cAAcqG,KAC7D/H,GAAOvG,GAAK,EAAK,SAAuBA,GAAK,EAAK,MAAyBA,GAAK,EAAK,IACvF,KAAK,SACH,MAAMsb,EAAM,EAAAvU,cAAcJ,WAAWyU,EAASnT,cAC9C1B,GAAM+U,EAAI,IAAM,GAAuBA,EAAI,IAAM,EAAyBA,EAAI,IAAM,EACtF,KAAK,EACL,QACE,MAAMC,EAAKzW,KAAKmE,QAAQuD,WAAW8B,KACnC/H,GAAOgV,GAAM,EAAK,SAAuBA,GAAM,EAAK,MAAyBA,GAAM,EAAK,IAE5FhV,GAAM,SAER,GAAIgK,EAAO,EAAA1L,uBAAwB,CAC5B4Q,IACHA,EAAOjL,EAAS+K,OAAOQ,OAAOyF,QAAQlG,IAE1BG,EAAMgG,QAAQzP,GAAIgB,gB,6BCpYxC,SAAgB0O,EAAoC1V,EAAUC,EAAgB,EAAGC,EAAcF,EAAMpC,QAC/FqC,EAAQ,IACVA,GAASD,EAAMpC,OAASqC,GAASD,EAAMpC,QAGvCsC,EADEA,GAAOF,EAAMpC,OACToC,EAAMpC,QAELoC,EAAMpC,OAASsC,GAAOF,EAAMpC,OAErCqC,EAAQvC,KAAKC,IAAIsC,EAAOC,GAExB,MAAME,EAAY,IAAKJ,EAAMK,YAAoBH,EAAMD,GACvD,IAAK,IAAI1G,EAAI,EAAGA,EAAI2G,EAAMD,IAAS1G,EACjC6G,EAAO7G,GAAKyG,EAAMzG,EAAI0G,GAExB,OAAOG,E,gFAvBT,iBAA4CJ,EAAUC,EAAgBC,GAEpE,OAAIF,EAAM8I,MACD9I,EAAM8I,MAAM7I,EAAOC,GAErBwV,EAAc1V,EAAOC,EAAOC,IAGrC,mB,uGCTA,aACA,OACA,OAIA,MAAawM,UAAwB,EAAAiJ,gBAGnC,YAAYC,EAAwB7S,EAAgBuE,EAAmB9C,GACrE2H,MAAMyJ,EAAW,OAAQ7S,GAAQ,EAAMuE,GACvC9C,EAASqR,UAAUC,oBAAoBC,GAAKjX,KAAKkX,qBAAqBD,IACtEvR,EAASqR,UAAUI,oBAAoBF,GAAKjX,KAAKoX,qBAAqBH,IAEtEvR,EAAS2R,WAAWL,oBAAoBC,GAAKjX,KAAKkX,qBAAqBD,IACvEvR,EAAS2R,WAAWF,oBAAoBF,GAAKjX,KAAKoX,qBAAqBH,IAGlE,OAAOvR,EAAoBW,GAChCgH,MAAMiC,OAAO5J,EAAUW,GAEvBrG,KAAKsX,YAASxK,EAGT,MAAMpH,GACX1F,KAAKuX,oBAGC,oBACN,GAAIvX,KAAKsX,OAAQ,CACftX,KAAKwX,YAAYxX,KAAKsX,OAAOG,GAAIzX,KAAKsX,OAAOI,GAAI1X,KAAKsX,OAAOzW,KAAOb,KAAKsX,OAAOG,GAAI,GACpF,MAAME,EAAiB3X,KAAKsX,OAAOM,GAAK5X,KAAKsX,OAAOI,GAAK,EACrDC,EAAiB,GACnB3X,KAAKwX,YAAY,EAAGxX,KAAKsX,OAAOI,GAAK,EAAG1X,KAAKsX,OAAOzW,KAAM8W,GAE5D3X,KAAKwX,YAAY,EAAGxX,KAAKsX,OAAOM,GAAI5X,KAAKsX,OAAOO,GAAI,GACpD7X,KAAKsX,YAASxK,GAIV,qBAAqBmK,GAU3B,GATIA,EAAExV,KAAO,EAAAiJ,uBACX1K,KAAKsF,KAAKmC,UAAYzH,KAAKmE,QAAQuD,WAAWC,SAC5BmF,IAATmK,EAAExV,IAAoB,EAAAqW,WAAWb,EAAExV,IAE5CzB,KAAKsF,KAAKmC,UAAYzH,KAAKmE,QAAQ4F,KAAKkN,EAAExV,IAAKkG,IAE/C3H,KAAKsF,KAAKmC,UAAYzH,KAAKmE,QAAQuF,WAAW/B,IAG5CsP,EAAES,KAAOT,EAAEW,GAEb5X,KAAK+X,uBAAuBd,EAAEQ,GAAIR,EAAES,GAAIT,EAAEY,GAAKZ,EAAEQ,QAC5C,CAELzX,KAAK+X,uBAAuBd,EAAEQ,GAAIR,EAAES,GAAIT,EAAEpW,KAAOoW,EAAEQ,IACnD,IAAK,IAAItQ,EAAI8P,EAAES,GAAK,EAAGvQ,EAAI8P,EAAEW,GAAIzQ,IAC/BnH,KAAK+X,uBAAuB,EAAG5Q,EAAG8P,EAAEpW,MAEtCb,KAAK+X,uBAAuB,EAAGd,EAAEW,GAAIX,EAAEY,IAEzC7X,KAAKsX,OAASL,EAGR,qBAAqBA,GAC3BjX,KAAKuX,qBA3DT,qB,sGCNA,aAEA,OACA,OAGA,OACA,QAYMS,EAAmBpZ,KAAKuS,MAAM8G,OAE9BC,EAAoB,CACxBvQ,IAAK,mBACL6B,KAAM,GAMF2O,EAA0C,CAC9C9D,OAAQ,CAAEnN,EAAG,EAAGC,EAAG,GACnBiR,gBAAiB,CAAElR,EAAG,EAAGC,EAAG,GAC5BkO,yBAA0B,CAAEnO,EAAG,EAAGC,EAAG,GACrC6N,KAAM,CAAE9N,EAAG,EAAGC,EAAG,GACjBoO,cAAe,CAAErO,EAAG,EAAGC,EAAG,IAwf5B,SAASkR,EAAYnd,GACnB,MAAM0B,EAAI1B,EAAE8J,SAAS,IACrB,OAAOpI,EAAEkC,OAAS,EAAI,IAAMlC,EAAIA,EArflC,uBA2BE,YACE+H,EACQ2T,GAAA,KAAAA,UA5BF,KAAAC,YAAsB,EAEtB,KAAAC,UAAqD,GACrD,KAAAC,kBAA8D,GAc9D,KAAAC,aAAuB,EACvB,KAAAC,aAAuB,EACvB,KAAAC,kBAA4B,EAE7B,KAAAC,kBAAmB,EAElB,KAAAC,iBAAiC,CAAEhE,IAAK,EAAGG,KAAM,EAAGF,OAAQ,EAAGG,MAAO,GACtE,KAAA6D,mBAAoC,IAAI,EAAA9W,cAM9CjC,KAAKgP,YAAcrK,EAASC,cAAc,UAC1C5E,KAAKgP,YAAYpI,MA5DC,KA6DlB5G,KAAKgP,YAAYlI,OA5DE,KAgEnB9G,KAAKgZ,UAAY,EAAA9b,aAAa8C,KAAKgP,YAAYzJ,WAAW,KAAM,CAACC,OAAO,KAExExF,KAAKiZ,WAAatU,EAASC,cAAc,UACzC5E,KAAKiZ,WAAWrS,MAAuC,EAA/B5G,KAAKsY,QAAQ9R,gBAAsB0S,EAC3DlZ,KAAKiZ,WAAWnS,OAAS9G,KAAKsY,QAAQ7R,iBAAmByS,EACzDlZ,KAAKmZ,QAAU,EAAAjc,aAAa8C,KAAKiZ,WAAW1T,WAAW,KAAM,CAACC,MAAOxF,KAAKsY,QAAQhO,qBAG7E,UACDtK,KAAKgP,YAAYoK,eACnBpZ,KAAKgP,YAAYoK,cAAcjU,YAAYnF,KAAKgP,aAI7C,SACAhP,KAAKuY,aACRvY,KAAKqZ,YACLrZ,KAAKuY,YAAa,GAId,YAEN,IAAK,IAAI9d,EAAI,GAAIA,EAAI,IAAKA,IAAK,CAC7B,MAAM8Z,EAAkBvU,KAAKsZ,aAAa7e,EAAG,EAAAuE,cAAe,EAAAA,eAC5DgB,KAAKwY,UAAU/d,GAAK,CAClB,CAAC,EAAAuE,eAAgB,CACf,CAAC,EAAAA,eAAgBuV,KAMlB,aACL,OAAIvU,KAAK0Y,aAAeV,IACtBhY,KAAKgQ,eACLhQ,KAAKoG,UACE,GAKJ,eACqB,IAAtBpG,KAAK2Y,cAA4C,IAAtB3Y,KAAK0Y,eAGpC1Y,KAAKgZ,UAAUxR,UAAU,EAAG,EA/GV,KACC,MA+GnBxH,KAAKwY,UAAY,GACjBxY,KAAKyY,kBAAoB,GACzBzY,KAAK4Y,kBAAoB,EACzB5Y,KAAK2Y,aAAe,EACpB3Y,KAAK0Y,aAAe,EACpB1Y,KAAKuY,YAAa,GAGb,+BAA+BzH,EAAepP,EAAYD,GAC/D,IAKI8S,EALAgF,EAAqBvZ,KAAKyY,kBAAkB3H,GAC3CyI,IACHA,EAAqB,GACrBvZ,KAAKyY,kBAAkB3H,GAASyI,GAGlC,MAAMC,EAAuBD,EAAmB7X,GAWhD,OAVI8X,IACFjF,EAAkBiF,EAAqB/X,IAEpC8S,IACHA,EAAkBvU,KAAKsZ,aAAaxI,EAAOpP,EAAID,GAC1C8X,EAAmB7X,KACtB6X,EAAmB7X,GAAM,IAE3B6X,EAAmB7X,GAAKD,GAAM8S,GAEzBA,EAMF,mBAAmB9I,EAAc/J,EAAYD,GAClD,IAKI8S,EALAgF,EAAqBvZ,KAAKwY,UAAU/M,GACnC8N,IACHA,EAAqB,GACrBvZ,KAAKwY,UAAU/M,GAAQ8N,GAGzB,MAAMC,EAAuBD,EAAmB7X,GAWhD,OAVI8X,IACFjF,EAAkBiF,EAAqB/X,IAEpC8S,IACHA,EAAkBvU,KAAKsZ,aAAa7N,EAAM/J,EAAID,GACzC8X,EAAmB7X,KACtB6X,EAAmB7X,GAAM,IAE3B6X,EAAmB7X,GAAKD,GAAM8S,GAEzBA,EAGD,uBAAuBrC,GAC7B,GAAIA,GAAOlS,KAAKsY,QAAQ9P,OAAOuB,KAAKjL,OAClC,MAAM,IAAInB,MAAM,0BAA4BuU,GAE9C,OAAOlS,KAAKsY,QAAQ9P,OAAOuB,KAAKmI,GAG1B,oBAAoBuH,EAAqBC,EAAiBC,GAChE,GAAI3Z,KAAKsY,QAAQhO,kBAIf,OAAO4N,EAGT,OAAQuB,GACN,KAAK,SACL,KAAK,SACH,OAAOzZ,KAAKuW,uBAAuBmD,GACrC,KAAK,SACH,MAAMlD,EAAM,EAAAvU,cAAcJ,WAAW6X,GAErC,MAAO,CACLlQ,KAAMkQ,GAAW,EACjB/R,IAAK,IAAI0Q,EAAY7B,EAAI,MAAM6B,EAAY7B,EAAI,MAAM6B,EAAY7B,EAAI,OAEzE,KAAK,EACL,QACE,OAAImD,EACK3Z,KAAKsY,QAAQ9P,OAAOkB,WAEtB1J,KAAKsY,QAAQ9P,OAAOd,YAIzB,kBAAkBhG,EAAY+X,EAAqBC,EAAiBjY,EAAYmY,EAAqBC,EAAiBF,EAAkBG,GAC9I,MAAMC,EAAqB/Z,KAAKga,uBAAuBtY,EAAI+X,EAAaC,EAASjY,EAAImY,EAAaC,EAASF,EAASG,GACpH,GAAIC,EACF,OAAOA,EAGT,OAAQH,GACN,KAAK,SACL,KAAK,SAIH,OAHI5Z,KAAKsY,QAAQ/N,4BAA8BuP,GAAQD,EAAU,IAC/DA,GAAW,GAEN7Z,KAAKuW,uBAAuBsD,GAASlS,IAC9C,KAAK,SACH,MAAM6O,EAAM,EAAAvU,cAAcJ,WAAWgY,GACrC,OAAO,EAAAI,SAASC,MAAM1D,EAAI,GAAIA,EAAI,GAAIA,EAAI,IAC5C,KAAK,EACL,QACE,GAAImD,EAAS,CACX,MAAMjY,EAAK1B,KAAKsY,QAAQ9P,OAAOd,WAAWC,IAC1C,OAAkB,IAAdjG,EAAG5C,OAEE4C,EAAGyY,OAAO,EAAG,GAEfzY,EAET,OAAO1B,KAAKsY,QAAQ9P,OAAOkB,WAAW/B,KAIpC,uBAAuB8R,EAAqBC,EAAiBC,GACnE,OAAQF,GACN,KAAK,SACL,KAAK,SACH,OAAOzZ,KAAKuW,uBAAuBmD,GAASlQ,KAC9C,KAAK,SACH,OAAOkQ,GAAW,EACpB,KAAK,EACL,QACE,OAAIC,EACK3Z,KAAKsY,QAAQ9P,OAAOkB,WAAWF,KAEjCxJ,KAAKsY,QAAQ9P,OAAOd,WAAW8B,MAIpC,uBAAuBoQ,EAAqBC,EAAiBF,EAAkBG,GACrF,OAAQF,GACN,KAAK,SACL,KAAK,SAIH,OAHI5Z,KAAKsY,QAAQ/N,4BAA8BuP,GAAQD,EAAU,IAC/DA,GAAW,GAEN7Z,KAAKuW,uBAAuBsD,GAASrQ,KAC9C,KAAK,SACH,OAAOqQ,GAAW,EACpB,KAAK,EACL,QACE,OAAIF,EACK3Z,KAAKsY,QAAQ9P,OAAOd,WAAW8B,KAEjCxJ,KAAKsY,QAAQ9P,OAAOkB,WAAWF,MAIpC,uBAAuB9H,EAAY+X,EAAqBC,EAAiBjY,EAAYmY,EAAqBC,EAAiBF,EAAkBG,GACnJ,GAA0C,IAAtC9Z,KAAKsY,QAAQ9N,qBACf,OAIF,MAAM4P,EAAgBpa,KAAKsY,QAAQ9P,OAAOyB,cAAcoQ,OAAO3Y,EAAID,GACnE,QAAsBqL,IAAlBsN,EACF,OAAOA,QAAiBtN,EAG1B,MAAMwN,EAASta,KAAKua,uBAAuBd,EAAaC,EAASC,GAC3Da,EAASxa,KAAKya,uBAAuBb,EAAaC,EAASF,EAASG,GACpExY,EAAS,EAAAkI,KAAKkR,oBAAoBJ,EAAQE,EAAQxa,KAAKsY,QAAQ9N,sBAErE,IAAKlJ,EAEH,YADAtB,KAAKsY,QAAQ9P,OAAOyB,cAAc0Q,OAAOjZ,EAAID,EAAI,MAInD,MAAMkG,EAAM,EAAAsS,SAASC,MAClB5Y,GAAU,GAAM,IAChBA,GAAU,GAAM,IAChBA,GAAU,EAAK,KAIlB,OAFAtB,KAAKsY,QAAQ9P,OAAOyB,cAAc0Q,OAAOjZ,EAAID,EAAIkG,GAE1CA,EAKD,aAAaiT,EAA8BlZ,EAAYD,GAC7D,MAAMqP,EAA+B,iBAAhB8J,EAA2BC,OAAOC,aAAaF,GAAeA,EAEnF5a,KAAK6Y,kBAAmB,EAExB7Y,KAAKmZ,QAAQ4B,OAEb/a,KAAK+Y,mBAAmBtX,GAAKA,EAC7BzB,KAAK+Y,mBAAmBrX,GAAKA,EAG7B,KADoB1B,KAAK+Y,mBAAmBzW,cAE1C,OAAO6V,EAGT,MAAM2B,IAAS9Z,KAAK+Y,mBAAmB5W,SACjCwX,IAAY3Z,KAAK+Y,mBAAmB7W,YACpCmE,IAAQrG,KAAK+Y,mBAAmBvW,QAChCwY,IAAWhb,KAAK+Y,mBAAmBxW,WACzC,IAAIsX,EAAU7Z,KAAK+Y,mBAAmB7V,aAClC0W,EAAc5Z,KAAK+Y,mBAAmBtW,iBACtCiX,EAAU1Z,KAAK+Y,mBAAmB5V,aAClCsW,EAAczZ,KAAK+Y,mBAAmBrW,iBAC1C,GAAIiX,EAAS,CACX,MAAMsB,EAAOpB,EACbA,EAAUH,EACVA,EAAUuB,EACV,MAAMC,EAAQtB,EACdA,EAAcH,EACdA,EAAcyB,EAIhB,MAAMC,EAAkBnb,KAAKob,oBAAoB3B,EAAaC,EAASC,GAGvE3Z,KAAKmZ,QAAQkC,yBAA2B,OACxCrb,KAAKmZ,QAAQ1R,UAAY0T,EAAgBxT,IACzC3H,KAAKmZ,QAAQ/R,SAAS,EAAG,EAAGpH,KAAKiZ,WAAWrS,MAAO5G,KAAKiZ,WAAWnS,QACnE9G,KAAKmZ,QAAQkC,yBAA2B,cAGxC,MAAMjR,EAAa0P,EAAO9Z,KAAKsY,QAAQjO,eAAiBrK,KAAKsY,QAAQlO,WAC/DkR,EAAYN,EAAS,SAAW,GACtChb,KAAKmZ,QAAQtR,KACX,GAAGyT,KAAalR,KAAcpK,KAAKsY,QAAQnO,SAAWnK,KAAKsY,QAAQjR,sBAAsBrH,KAAKsY,QAAQpO,aACxGlK,KAAKmZ,QAAQpR,aAAe,SAE5B/H,KAAKmZ,QAAQ1R,UAAYzH,KAAKub,kBAAkB7Z,EAAI+X,EAAaC,EAASjY,EAAImY,EAAaC,EAASF,EAASG,GAGzGzT,IACFrG,KAAKmZ,QAAQqC,YAAc,EAAA7Q,aAI7B3K,KAAKmZ,QAAQlR,SAAS6I,EAvUO,IAuUqD9Q,KAAKsY,QAAQ7R,iBAAmB,GAClHzG,KAAKmZ,QAAQsC,UAIb,MAAMC,EAAY1b,KAAKmZ,QAAQwC,aAC7B,EAAG,EAAG3b,KAAKiZ,WAAWrS,MAAO5G,KAAKiZ,WAAWnS,QAa/C,GA0IJ,SAAoB4U,EAAsBE,GACxC,IAAItY,GAAU,EACd,MAAM3H,EAAIigB,EAAMpS,OAAS,GACnBqS,EAAID,EAAMpS,OAAS,GAAK,IACxBnI,EAAIua,EAAMpS,OAAS,EAAI,IAC7B,IAAK,IAAI6K,EAAS,EAAGA,EAASqH,EAAUI,KAAKhd,OAAQuV,GAAU,EACzDqH,EAAUI,KAAKzH,KAAY1Y,GAC3B+f,EAAUI,KAAKzH,EAAS,KAAOwH,GAC/BH,EAAUI,KAAKzH,EAAS,KAAOhT,EACjCqa,EAAUI,KAAKzH,EAAS,GAAK,EAE7B/Q,GAAU,EAGd,OAAOA,EA3JWyY,CAAWL,EAAWP,GAIpC,OAAOhD,EAGT,MAAM5D,EAAkBvU,KAAKgc,sBAAsBN,EAAW1b,KAAK8Y,kBAC7DmD,EAAmBjc,KAAKkc,eAAeR,EAAW1b,KAAK8Y,kBAsB7D,OAnBI9Y,KAAK2Y,aAAe3Y,KAAKsY,QAAQ9R,gBA5XnB,OA6XhBxG,KAAK2Y,aAAe,EACpB3Y,KAAK0Y,cAAgB1Y,KAAK4Y,kBAC1B5Y,KAAK4Y,kBAAoB,GAI3BrE,EAAgB6D,gBAAgBlR,EAAIlH,KAAK2Y,aACzCpE,EAAgB6D,gBAAgBjR,EAAInH,KAAK0Y,aACzCnE,EAAgBc,yBAAyBnO,EAAIlH,KAAK2Y,aArYhC,KAsYlBpE,EAAgBc,yBAAyBlO,EAAInH,KAAK0Y,aArY/B,KAwYnB1Y,KAAK4Y,kBAAoBha,KAAKF,IAAIsB,KAAK4Y,kBAAmBrE,EAAgBS,KAAK7N,GAC/EnH,KAAK2Y,cAAgBpE,EAAgBS,KAAK9N,EAG1ClH,KAAKgZ,UAAUmD,aAAaF,EAAkB1H,EAAgB6D,gBAAgBlR,EAAGqN,EAAgB6D,gBAAgBjR,GAE1GoN,EAUD,sBAAsBmH,EAAsBU,GAClDA,EAAYtH,IAAM,EAClB,IAAIuH,GAAQ,EACZ,IAAK,IAAIlV,EAAI,EAAGA,EAAInH,KAAKiZ,WAAWnS,OAAQK,IAAK,CAC/C,IAAK,IAAID,EAAI,EAAGA,EAAIlH,KAAKiZ,WAAWrS,MAAOM,IAAK,CAC9C,MAAMoV,EAAcnV,EAAInH,KAAKiZ,WAAWrS,MAAQ,EAAQ,EAAJM,EAAQ,EAC5D,GAAoC,IAAhCwU,EAAUI,KAAKQ,GAAoB,CACrCF,EAAYtH,IAAM3N,EAClBkV,GAAQ,EACR,OAGJ,GAAIA,EACF,MAGJD,EAAYnH,KAAO,EACnBoH,GAAQ,EACR,IAAK,IAAInV,EAAI,EAAGA,EAAIlH,KAAKiZ,WAAWrS,MAAOM,IAAK,CAC9C,IAAK,IAAIC,EAAI,EAAGA,EAAInH,KAAKiZ,WAAWnS,OAAQK,IAAK,CAC/C,MAAMmV,EAAcnV,EAAInH,KAAKiZ,WAAWrS,MAAQ,EAAQ,EAAJM,EAAQ,EAC5D,GAAoC,IAAhCwU,EAAUI,KAAKQ,GAAoB,CACrCF,EAAYnH,KAAO/N,EACnBmV,GAAQ,EACR,OAGJ,GAAIA,EACF,MAGJD,EAAYlH,MAAQlV,KAAKiZ,WAAWrS,MACpCyV,GAAQ,EACR,IAAK,IAAInV,EAAIlH,KAAKiZ,WAAWrS,MAAQ,EAAGM,GAAK,EAAGA,IAAK,CACnD,IAAK,IAAIC,EAAI,EAAGA,EAAInH,KAAKiZ,WAAWnS,OAAQK,IAAK,CAC/C,MAAMmV,EAAcnV,EAAInH,KAAKiZ,WAAWrS,MAAQ,EAAQ,EAAJM,EAAQ,EAC5D,GAAoC,IAAhCwU,EAAUI,KAAKQ,GAAoB,CACrCF,EAAYlH,MAAQhO,EACpBmV,GAAQ,EACR,OAGJ,GAAIA,EACF,MAGJD,EAAYrH,OAAS/U,KAAKiZ,WAAWnS,OACrCuV,GAAQ,EACR,IAAK,IAAIlV,EAAInH,KAAKiZ,WAAWnS,OAAS,EAAGK,GAAK,EAAGA,IAAK,CACpD,IAAK,IAAID,EAAI,EAAGA,EAAIlH,KAAKiZ,WAAWrS,MAAOM,IAAK,CAC9C,MAAMoV,EAAcnV,EAAInH,KAAKiZ,WAAWrS,MAAQ,EAAQ,EAAJM,EAAQ,EAC5D,GAAoC,IAAhCwU,EAAUI,KAAKQ,GAAoB,CACrCF,EAAYrH,OAAS5N,EACrBkV,GAAQ,EACR,OAGJ,GAAIA,EACF,MAGJ,MAAO,CACLjE,gBAAiB,CAAElR,EAAG,EAAGC,EAAG,GAC5BkO,yBAA0B,CAAEnO,EAAG,EAAGC,EAAG,GACrC6N,KAAM,CACJ9N,EAAGkV,EAAYlH,MAAQkH,EAAYnH,KAAO,EAC1C9N,EAAGiV,EAAYrH,OAASqH,EAAYtH,IAAM,GAE5CS,cAAe,CACbrO,GAAIkV,EAAYlH,MAAQkH,EAAYnH,KAAO,GA9d7B,KA+dd9N,GAAIiV,EAAYrH,OAASqH,EAAYtH,IAAM,GA9d5B,MAgejBT,OAAQ,CACNnN,EAxcyB,EAwcrBkV,EAAYnH,KAChB9N,EAzcyB,EAycrBiV,EAAYtH,MAKd,eAAe4G,EAAsBU,GAC3C,MAAMxV,EAAQwV,EAAYlH,MAAQkH,EAAYnH,KAAO,EAC/CnO,EAASsV,EAAYrH,OAASqH,EAAYtH,IAAM,EAChDyH,EAAc,IAAIC,kBAAkB5V,EAAQE,EAAS,GAC3D,IAAK,IAAIK,EAAIiV,EAAYtH,IAAK3N,GAAKiV,EAAYrH,OAAQ5N,IACrD,IAAK,IAAID,EAAIkV,EAAYnH,KAAM/N,GAAKkV,EAAYlH,MAAOhO,IAAK,CAC1D,MAAMuV,EAAYtV,EAAInH,KAAKiZ,WAAWrS,MAAQ,EAAQ,EAAJM,EAC5CwV,GAAavV,EAAIiV,EAAYtH,KAAOlO,EAAQ,EAA6B,GAAxBM,EAAIkV,EAAYnH,MACvEsH,EAAYG,GAAahB,EAAUI,KAAKW,GACxCF,EAAYG,EAAY,GAAKhB,EAAUI,KAAKW,EAAY,GACxDF,EAAYG,EAAY,GAAKhB,EAAUI,KAAKW,EAAY,GACxDF,EAAYG,EAAY,GAAKhB,EAAUI,KAAKW,EAAY,GAG5D,OAAO,IAAIE,UAAUJ,EAAa3V,EAAOE,M,6BC7f7C,IAAiBmT,EAiBA,EAkFA2C,EAoCApT,EAkEjB,SAAgB6O,EAAYnd,GAC1B,IAAM0B,EAAI1B,EAAE8J,SAAS,IACrB,OAAOpI,EAAEkC,OAAS,EAAI,IAAMlC,EAAIA,EASlC,SAAgBigB,EAAcC,EAAYC,GACxC,OAAID,EAAKC,GACCA,EAAK,MAASD,EAAK,MAErBA,EAAK,MAASC,EAAK,K,4HAxN7B,SAAiB9C,GACC,EAAAC,MAAhB,SAAsBve,EAAWkgB,EAAWxa,EAAW7G,GACrD,YAAUsS,IAANtS,EACK,IAAI6d,EAAY1c,GAAK0c,EAAYwD,GAAKxD,EAAYhX,GAAKgX,EAAY7d,GAErE,IAAI6d,EAAY1c,GAAK0c,EAAYwD,GAAKxD,EAAYhX,IAG3C,EAAA2b,OAAhB,SAAuBrhB,EAAWkgB,EAAWxa,EAAW7G,GAEtD,YAFsD,IAAAA,MAAA,MAE9CmB,GAAK,GAAKkgB,GAAK,GAAKxa,GAAK,EAAI7G,KAAO,GAVhD,CAAiByf,EAAA,EAAAA,WAAA,EAAAA,SAAQ,MAiBR,IAAA2B,QAAA,EAAAA,MAAK,KACJqB,MAAhB,SAAsBvb,EAAYD,GAChC,IAAMjH,GAAe,IAAViH,EAAG+H,MAAe,IAC7B,GAAU,IAANhP,EACF,MAAO,CACLmN,IAAKlG,EAAGkG,IACR6B,KAAM/H,EAAG+H,MAGb,IAAM0T,EAAOzb,EAAG+H,MAAQ,GAAM,IACxB2T,EAAO1b,EAAG+H,MAAQ,GAAM,IACxB4T,EAAO3b,EAAG+H,MAAQ,EAAK,IACvB6T,EAAO3b,EAAG8H,MAAQ,GAAM,IACxB8T,EAAO5b,EAAG8H,MAAQ,GAAM,IACxB+T,EAAO7b,EAAG8H,MAAQ,EAAK,IACvB7N,EAAI0hB,EAAMze,KAAKyS,OAAO6L,EAAMG,GAAO7iB,GACnCqhB,EAAIyB,EAAM1e,KAAKyS,OAAO8L,EAAMG,GAAO9iB,GACnC6G,EAAIkc,EAAM3e,KAAKyS,OAAO+L,EAAMG,GAAO/iB,GAGzC,MAAO,CAAEmN,IAFGsS,EAASC,MAAMve,EAAGkgB,EAAGxa,GAEnBmI,KADDyQ,EAAS+C,OAAOrhB,EAAGkgB,EAAGxa,KAIrB,EAAAmc,SAAhB,SAAyB5B,GACvB,OAA+B,MAAV,IAAbA,EAAMpS,OAGA,EAAAkR,oBAAhB,SAAoChZ,EAAYD,EAAYgc,GAC1D,IAAMnc,EAASkI,EAAKkR,oBAAoBhZ,EAAG8H,KAAM/H,EAAG+H,KAAMiU,GAC1D,GAAKnc,EAGL,OAAOkI,EAAKkU,QACTpc,GAAU,GAAK,IACfA,GAAU,GAAK,IACfA,GAAU,EAAK,MAIJ,EAAAqc,OAAhB,SAAuB/B,GACrB,IAAMgC,GAA0B,IAAbhC,EAAMpS,QAAiB,EACpC,EAAYA,EAAKqU,WAAWD,GAA3BjiB,EAAC,KAAEkgB,EAAC,KAAExa,EAAC,KACd,MAAO,CACLsG,IAAKsS,EAASC,MAAMve,EAAGkgB,EAAGxa,GAC1BmI,KAAMoU,IAIM,EAAAE,QAAhB,SAAwBlC,EAAekC,GACrC,IAAMtjB,EAAIoE,KAAKyS,MAAgB,IAAVyM,GACf,EAAYtU,EAAKqU,WAAWjC,EAAMpS,MAAjC7N,EAAC,KAAEkgB,EAAC,KAAExa,EAAC,KACd,MAAO,CACLsG,IAAKsS,EAASC,MAAMve,EAAGkgB,EAAGxa,EAAG7G,GAC7BgP,KAAMyQ,EAAS+C,OAAOrhB,EAAGkgB,EAAGxa,EAAG7G,MAQpB,EAAAmN,MAAA,EAAAA,IAAG,KACF+V,QAAhB,SAAwB/V,GACtB,OAAQA,EAAI7I,QACV,KAAK,EACH,MAAO,CACL6I,IAAG,EACH6B,MAAOuU,SAASpW,EAAIqC,MAAM,GAAI,KAAO,EAAI,OAAU,GAEvD,KAAK,EACH,MAAO,CACLrC,IAAG,EACH6B,KAAMuU,SAASpW,EAAIqC,MAAM,GAAI,MAAQ,GAG3C,MAAM,IAAIrM,MAAM,wCAOpB,SAAiB,GAsBf,SAAgBqgB,EAAmBriB,EAAWkgB,EAAWxa,GACvD,IAAM4c,EAAKtiB,EAAI,IACTuiB,EAAKrC,EAAI,IACTsC,EAAK9c,EAAI,IAIf,MAAY,OAHD4c,GAAM,OAAUA,EAAK,MAAQrf,KAAKwf,KAAKH,EAAK,MAAS,MAAO,MAG7C,OAFfC,GAAM,OAAUA,EAAK,MAAQtf,KAAKwf,KAAKF,EAAK,MAAS,MAAO,MAE/B,OAD7BC,GAAM,OAAUA,EAAK,MAAQvf,KAAKwf,KAAKD,EAAK,MAAS,MAAO,MArBzD,EAAAE,kBAAhB,SAAkCzB,GAChC,OAAOoB,EACJpB,GAAO,GAAM,IACbA,GAAO,EAAM,IACA,IAAd,IAWY,EAAAoB,mBAAkB,EAtBpC,CAAiBpB,EAAA,EAAAA,MAAA,EAAAA,IAAG,KAoCpB,SAAiBpT,GAcf,SAAgB8U,EAAgBhE,EAAgBE,EAAgBiD,GAU9D,IAPA,IAAMJ,EAAO/C,GAAU,GAAM,IACvBgD,EAAOhD,GAAU,GAAM,IACvBiD,EAAOjD,GAAW,EAAK,IACzB4C,EAAO1C,GAAU,GAAM,IACvB2C,EAAO3C,GAAU,GAAM,IACvB4C,EAAO5C,GAAW,EAAK,IACvB+D,EAAK1B,EAAcD,EAAIoB,mBAAmBd,EAAKE,EAAKD,GAAMP,EAAIoB,mBAAmBX,EAAKC,EAAKC,IACxFgB,EAAKd,IAAUP,EAAM,GAAKC,EAAM,GAAKC,EAAM,IAEhDF,GAAOte,KAAKF,IAAI,EAAGE,KAAKwS,KAAW,GAAN8L,IAC7BC,GAAOve,KAAKF,IAAI,EAAGE,KAAKwS,KAAW,GAAN+L,IAC7BC,GAAOxe,KAAKF,IAAI,EAAGE,KAAKwS,KAAW,GAANgM,IAC7BmB,EAAK1B,EAAcD,EAAIoB,mBAAmBd,EAAKE,EAAKD,GAAMP,EAAIoB,mBAAmBX,EAAKC,EAAKC,IAE7F,OAAQL,GAAO,GAAKC,GAAO,GAAKC,GAAO,EAAI,OAAU,EAGvD,SAAgBoB,EAAkBlE,EAAgBE,EAAgBiD,GAUhE,IAPA,IAAMJ,EAAO/C,GAAU,GAAM,IACvBgD,EAAOhD,GAAU,GAAM,IACvBiD,EAAOjD,GAAW,EAAK,IACzB4C,EAAO1C,GAAU,GAAM,IACvB2C,EAAO3C,GAAU,GAAM,IACvB4C,EAAO5C,GAAW,EAAK,IACvB+D,EAAK1B,EAAcD,EAAIoB,mBAAmBd,EAAKE,EAAKD,GAAMP,EAAIoB,mBAAmBX,EAAKC,EAAKC,IACxFgB,EAAKd,IAAUP,EAAM,KAAQC,EAAM,KAAQC,EAAM,MAEtDF,EAAMte,KAAKC,IAAI,IAAMqe,EAAMte,KAAKwS,KAAmB,IAAb,IAAM8L,KAC5CC,EAAMve,KAAKC,IAAI,IAAMse,EAAMve,KAAKwS,KAAmB,IAAb,IAAM+L,KAC5CC,EAAMxe,KAAKC,IAAI,IAAMue,EAAMxe,KAAKwS,KAAmB,IAAb,IAAMgM,KAC5CmB,EAAK1B,EAAcD,EAAIoB,mBAAmBd,EAAKE,EAAKD,GAAMP,EAAIoB,mBAAmBX,EAAKC,EAAKC,IAE7F,OAAQL,GAAO,GAAKC,GAAO,GAAKC,GAAO,EAAI,OAAU,EAlDvC,EAAA1C,oBAAhB,SAAoCJ,EAAgBE,EAAgBiD,GAClE,IAAMgB,EAAM7B,EAAIyB,kBAAkB/D,GAAU,GACtCoE,EAAM9B,EAAIyB,kBAAkB7D,GAAU,GAE5C,GADWqC,EAAc4B,EAAKC,GACrBjB,EACP,OAAIiB,EAAMD,EACDH,EAAgBhE,EAAQE,EAAQiD,GAElCe,EAAkBlE,EAAQE,EAAQiD,IAK7B,EAAAa,gBAAe,EAoBf,EAAAE,kBAAiB,EAoBjB,EAAAX,WAAhB,SAA2B/hB,GACzB,MAAO,CAAEA,GAAS,GAAM,IAAOA,GAAS,GAAM,IAAOA,GAAS,EAAK,IAAc,IAARA,IAG3D,EAAA4hB,QAAhB,SAAwB/hB,EAAWkgB,EAAWxa,GAC5C,MAAO,CACLsG,IAAKsS,EAASC,MAAMve,EAAGkgB,EAAGxa,GAC1BmI,KAAMyQ,EAAS+C,OAAOrhB,EAAGkgB,EAAGxa,KA7DlC,CAAiBmI,EAAA,EAAAA,OAAA,EAAAA,KAAI,KAkErB,gBAWA,mB,yGCxNA,aAEA,OAkBA,MAAasE,UAA0B,EAAA+I,gBAMrC,YACEC,EACA7S,EACAuE,EACQmW,GAERtR,MAAMyJ,EAAW,SAAU7S,GAAQ,EAAMuE,GAFjC,KAAAmW,6BANF,KAAAC,MAAmB,IAAI,EAAA3T,SAS7BjL,KAAKsX,OAAS,CACZpQ,EAAG,EACHC,EAAG,EACH0X,WAAW,EACX9Z,MAAO,GACP6B,MAAO,GAET5G,KAAK8e,iBAAmB,CACtB,IAAO9e,KAAK+e,iBAAiB1iB,KAAK2D,MAClC,MAASA,KAAKgf,mBAAmB3iB,KAAK2D,MACtC,UAAaA,KAAKif,uBAAuB5iB,KAAK2D,OAK3C,OAAO0F,EAAoBW,GAChCgH,MAAMiC,OAAO5J,EAAUW,GAEvBrG,KAAKsX,OAAS,CACZpQ,EAAG,EACHC,EAAG,EACH0X,WAAW,EACX9Z,MAAO,GACP6B,MAAO,GAIJ,MAAMlB,GACX1F,KAAKkf,eACDlf,KAAKmf,2BACPnf,KAAKmf,yBAAyB9Z,UAC9BrF,KAAK8P,iBAAiBpK,IAInB,OAAOA,GACR1F,KAAKmf,0BACPnf,KAAKmf,yBAAyBC,QAEhCpf,KAAK2e,2BAA2B/O,KAAK,CAAEzO,MAAOuE,EAAS+K,OAAOQ,OAAOoO,QAASje,IAAKsE,EAAS+K,OAAOQ,OAAOoO,UAGrG,QAAQ3Z,GACT1F,KAAKmf,yBACPnf,KAAKmf,yBAAyBG,OAAO5Z,GAErC1F,KAAK2e,2BAA2B/O,KAAK,CAAEzO,MAAOuE,EAAS+K,OAAOQ,OAAOoO,QAASje,IAAKsE,EAAS+K,OAAOQ,OAAOoO,UAIvG,iBAAiB3Z,G,MAClBA,EAAS4C,UAAU,eAChBtI,KAAKmf,2BACRnf,KAAKmf,yBAA2B,IAAII,EAAwB7Z,EAAU,KACpE1F,KAAKwf,QAAQ9Z,GAAU,OAIE,QAA7B,EAAA1F,KAAKmf,gCAAwB,SAAE9Z,UAC/BrF,KAAKmf,8BAA2BrS,GAIlC9M,KAAK2e,2BAA2B/O,KAAK,CAAEzO,MAAOuE,EAAS+K,OAAOQ,OAAOoO,QAASje,IAAKsE,EAAS+K,OAAOQ,OAAOoO,UAGrG,aAAa3Z,GACd1F,KAAKmf,0BACPnf,KAAKmf,yBAAyBM,sBAAsB/Z,GAIjD,cAAcA,EAAoBC,EAAkBC,IACpD5F,KAAKmf,0BAA4Bnf,KAAKmf,yBAAyBO,SAClE1f,KAAKwf,QAAQ9Z,GAAU,GAEvB1F,KAAKmf,yBAAyBM,sBAAsB/Z,GAIhD,QAAQA,EAAoBia,GAGlC,IAAMja,EAAiBsG,MAAM4T,aAAaC,qBAAwBna,EAAiBsG,MAAM4T,aAAaE,eAEpG,YADA9f,KAAKkf,eAIP,MAAMG,EAAU3Z,EAAS+K,OAAOQ,OAAO8O,MAAQra,EAAS+K,OAAOQ,OAAOoO,QAChEW,EAA0BX,EAAU3Z,EAAS+K,OAAOQ,OAAOC,UAG3D+O,EAAUrhB,KAAKC,IAAI6G,EAAS+K,OAAOQ,OAAOgP,QAASva,EAAS7E,KAAO,GAGzE,GAAImf,EAA0B,GAAKA,GAA2Bta,EAAS5E,KACrEd,KAAKkf,oBAMP,GADCxZ,EAAiBsG,MAAMyE,OAAOG,MAAMlV,IAAI2jB,GAASxO,SAASoP,EAASjgB,KAAK4e,YAC9C9R,IAAvB9M,KAAK4e,MAAM/T,QAAf,CAIA,IAAKqV,EAAkBxa,GAAW,CAChC1F,KAAKkf,eACLlf,KAAKsF,KAAKyV,OACV/a,KAAKsF,KAAKmC,UAAYzH,KAAKmE,QAAQwF,OAAOhC,IAC1C,MAAMwY,EAAcza,EAAS4C,UAAU,eAYvC,OAXI6X,GAA+B,UAAhBA,EACjBngB,KAAK8e,iBAAiBqB,GAAaza,EAAUua,EAASD,EAAyBhgB,KAAK4e,OAEpF5e,KAAKogB,kBAAkB1a,EAAUua,EAASD,EAAyBhgB,KAAK4e,OAE1E5e,KAAKsF,KAAKmW,UACVzb,KAAKsX,OAAOpQ,EAAI+Y,EAChBjgB,KAAKsX,OAAOnQ,EAAI6Y,EAChBhgB,KAAKsX,OAAOuH,WAAY,EACxB7e,KAAKsX,OAAOvS,MAAQob,OACpBngB,KAAKsX,OAAO1Q,MAAQ5G,KAAK4e,MAAMxT,YAKjC,IAAIpL,KAAKmf,0BAA6Bnf,KAAKmf,yBAAyBkB,gBAApE,CAKA,GAAIrgB,KAAKsX,OAAQ,CAEf,GAAItX,KAAKsX,OAAOpQ,IAAM+Y,GAClBjgB,KAAKsX,OAAOnQ,IAAM6Y,GAClBhgB,KAAKsX,OAAOuH,YAAcqB,EAAkBxa,IAC5C1F,KAAKsX,OAAOvS,QAAUW,EAAS4C,UAAU,gBACzCtI,KAAKsX,OAAO1Q,QAAU5G,KAAK4e,MAAMxT,WACnC,OAEFpL,KAAKkf,eAGPlf,KAAKsF,KAAKyV,OACV/a,KAAK8e,iBAAiBpZ,EAAS4C,UAAU,gBAAkB,SAAS5C,EAAUua,EAASD,EAAyBhgB,KAAK4e,OACrH5e,KAAKsF,KAAKmW,UAEVzb,KAAKsX,OAAOpQ,EAAI+Y,EAChBjgB,KAAKsX,OAAOnQ,EAAI6Y,EAChBhgB,KAAKsX,OAAOuH,WAAY,EACxB7e,KAAKsX,OAAOvS,MAAQW,EAAS4C,UAAU,eACvCtI,KAAKsX,OAAO1Q,MAAQ5G,KAAK4e,MAAMxT,gBAxB7BpL,KAAKkf,gBA2BD,eACFlf,KAAKsX,SACPtX,KAAKwX,YAAYxX,KAAKsX,OAAOpQ,EAAGlH,KAAKsX,OAAOnQ,EAAGnH,KAAKsX,OAAO1Q,MAAO,GAClE5G,KAAKsX,OAAS,CACZpQ,EAAG,EACHC,EAAG,EACH0X,WAAW,EACX9Z,MAAO,GACP6B,MAAO,IAKL,iBAAiBlB,EAAoBwB,EAAWC,EAAWS,GACjE5H,KAAKsF,KAAKyV,OACV/a,KAAKsF,KAAKmC,UAAYzH,KAAKmE,QAAQwF,OAAOhC,IAC1C3H,KAAKsgB,oBAAoBpZ,EAAGC,EAAGzB,EAAS4C,UAAU,gBAClDtI,KAAKsF,KAAKmW,UAGJ,mBAAmB/V,EAAoBwB,EAAWC,EAAWS,GACnE5H,KAAKsF,KAAKyV,OACV/a,KAAKsF,KAAKmC,UAAYzH,KAAKmE,QAAQwF,OAAOhC,IAC1C3H,KAAKugB,WAAWrZ,EAAGC,EAAGS,EAAKwD,WAAY,GACvCpL,KAAKsF,KAAKmC,UAAYzH,KAAKmE,QAAQyF,aAAajC,IAChD3H,KAAKwgB,mBAAmB9a,EAAUkC,EAAMV,EAAGC,GAC3CnH,KAAKsF,KAAKmW,UAGJ,uBAAuB/V,EAAoBwB,EAAWC,EAAWS,GACvE5H,KAAKsF,KAAKyV,OACV/a,KAAKsF,KAAKmC,UAAYzH,KAAKmE,QAAQwF,OAAOhC,IAC1C3H,KAAK+X,uBAAuB7Q,EAAGC,GAC/BnH,KAAKsF,KAAKmW,UAGJ,kBAAkB/V,EAAoBwB,EAAWC,EAAWS,GAClE5H,KAAKsF,KAAKyV,OACV/a,KAAKsF,KAAKmb,YAAczgB,KAAKmE,QAAQwF,OAAOhC,IAC5C3H,KAAK0gB,kBAAkBxZ,EAAGC,EAAGS,EAAKwD,WAAY,GAC9CpL,KAAKsF,KAAKmW,WA/Md,sBAmNA,MAAM8D,EAcJ,YACE7Z,EACQib,GAAA,KAAAA,kBAER3gB,KAAKqgB,iBAAkB,EACnBH,EAAkBxa,IACpB1F,KAAK4gB,mBAIT,eAAiC,QAAS5gB,KAAK6gB,oBAAsB7gB,KAAK8gB,gBAEnE,UACD9gB,KAAK8gB,iBACPpmB,OAAOqmB,cAAc/gB,KAAK8gB,gBAC1B9gB,KAAK8gB,oBAAiBhU,GAEpB9M,KAAK6gB,qBACPnmB,OAAOsmB,aAAahhB,KAAK6gB,oBACzB7gB,KAAK6gB,wBAAqB/T,GAExB9M,KAAKihB,kBACPvmB,OAAOwmB,qBAAqBlhB,KAAKihB,iBACjCjhB,KAAKihB,qBAAkBnU,GAIpB,sBAAsBpH,GACvB1F,KAAK0f,WAIT1f,KAAKmhB,wBAA0BC,KAAKC,MAEpCrhB,KAAKqgB,iBAAkB,EAClBrgB,KAAKihB,kBACRjhB,KAAKihB,gBAAkBvmB,OAAO4mB,sBAAsB,KAClDthB,KAAK2gB,kBACL3gB,KAAKihB,qBAAkBnU,MAKrB,iBAAiByU,EA9QJ,KAgRfvhB,KAAK8gB,gBACPpmB,OAAOqmB,cAAc/gB,KAAK8gB,gBAO5B9gB,KAAK6gB,mBAAqBnmB,OAAO8mB,WAAW,KAG1C,GAAIxhB,KAAKmhB,wBAAyB,CAChC,MAAMM,EA5RS,KA4RgBL,KAAKC,MAAQrhB,KAAKmhB,yBAEjD,GADAnhB,KAAKmhB,6BAA0BrU,EAC3B2U,EAAO,EAET,YADAzhB,KAAK4gB,iBAAiBa,GAM1BzhB,KAAKqgB,iBAAkB,EACvBrgB,KAAKihB,gBAAkBvmB,OAAO4mB,sBAAsB,KAClDthB,KAAK2gB,kBACL3gB,KAAKihB,qBAAkBnU,IAIzB9M,KAAK8gB,eAAiBpmB,OAAOgnB,YAAY,KAEvC,GAAI1hB,KAAKmhB,wBAAyB,CAGhC,MAAMM,EAjTO,KAiTkBL,KAAKC,MAAQrhB,KAAKmhB,yBAGjD,OAFAnhB,KAAKmhB,6BAA0BrU,OAC/B9M,KAAK4gB,iBAAiBa,GAKxBzhB,KAAKqgB,iBAAmBrgB,KAAKqgB,gBAC7BrgB,KAAKihB,gBAAkBvmB,OAAO4mB,sBAAsB,KAClDthB,KAAK2gB,kBACL3gB,KAAKihB,qBAAkBnU,KA3TV,MA8ThByU,GAGE,QACLvhB,KAAKqgB,iBAAkB,EACnBrgB,KAAK8gB,iBACPpmB,OAAOqmB,cAAc/gB,KAAK8gB,gBAC1B9gB,KAAK8gB,oBAAiBhU,GAEpB9M,KAAK6gB,qBACPnmB,OAAOsmB,aAAahhB,KAAK6gB,oBACzB7gB,KAAK6gB,wBAAqB/T,GAExB9M,KAAKihB,kBACPvmB,OAAOwmB,qBAAqBlhB,KAAKihB,iBACjCjhB,KAAKihB,qBAAkBnU,GAIpB,OAAOpH,GAEZ1F,KAAKof,QAELpf,KAAKmhB,6BAA0BrU,EAC/B9M,KAAK4gB,mBACL5gB,KAAKyf,sBAAsB/Z,IAI/B,SAASwa,EAAkBxa,GACzB,OAAOf,SAASgd,gBAAkBjc,EAASkc,UAAYjd,SAASkd,a,yJCxWlE,+BAAoCC,GAClC,OAAIA,EAAY,OACdA,GAAa,MACNjH,OAAOC,aAAiC,OAAnBgH,GAAa,KAAgBjH,OAAOC,aAAcgH,EAAY,KAAS,QAE9FjH,OAAOC,aAAagH,IAQ7B,yBAA8BhG,EAAmB3a,EAAmBC,QAAnB,IAAAD,MAAA,QAAmB,IAAAC,MAAc0a,EAAKhd,QAErF,IADA,IAAIwC,EAAS,GACJ7G,EAAI0G,EAAO1G,EAAI2G,IAAO3G,EAAG,CAChC,IAAIsnB,EAAYjG,EAAKrhB,GACjBsnB,EAAY,OAMdA,GAAa,MACbzgB,GAAUuZ,OAAOC,aAAiC,OAAnBiH,GAAa,KAAgBlH,OAAOC,aAAciH,EAAY,KAAS,QAEtGzgB,GAAUuZ,OAAOC,aAAaiH,GAGlC,OAAOzgB,GAOT,8BACU,KAAA0gB,SAAmB,EA8D7B,OAzDS,YAAA5S,MAAP,WACEpP,KAAKgiB,SAAW,GAWX,YAAAC,OAAP,SAAcC,EAAeC,GAC3B,IAAMrjB,EAASojB,EAAMpjB,OAErB,IAAKA,EACH,OAAO,EAGT,IAAIkW,EAAO,EACPoN,EAAW,EAGXpiB,KAAKgiB,WAEH,QADEtW,EAASwW,EAAM3W,WAAW6W,OACR1W,GAAU,MAChCyW,EAAOnN,KAAqC,MAA1BhV,KAAKgiB,SAAW,OAAkBtW,EAAS,MAAS,OAGtEyW,EAAOnN,KAAUhV,KAAKgiB,SACtBG,EAAOnN,KAAUtJ,GAEnB1L,KAAKgiB,SAAW,GAGlB,IAAK,IAAIvnB,EAAI2nB,EAAU3nB,EAAIqE,IAAUrE,EAAG,CACtC,IAAMgR,EAAOyW,EAAM3W,WAAW9Q,GAE9B,GAAI,OAAUgR,GAAQA,GAAQ,MAA9B,CACE,KAAMhR,GAAKqE,EAET,OADAkB,KAAKgiB,SAAWvW,EACTuJ,EAET,IAAMtJ,EACF,QADEA,EAASwW,EAAM3W,WAAW9Q,KACRiR,GAAU,MAChCyW,EAAOnN,KAA4B,MAAjBvJ,EAAO,OAAkBC,EAAS,MAAS,OAG7DyW,EAAOnN,KAAUvJ,EACjB0W,EAAOnN,KAAUtJ,QAIrByW,EAAOnN,KAAUvJ,EAEnB,OAAOuJ,GAEX,EA/DA,GAAa,EAAAqN,gBAoEb,8BACS,KAAAC,QAAsB,IAAI5P,WAAW,GAgO9C,OA3NS,YAAAtD,MAAP,WACEpP,KAAKsiB,QAAQthB,KAAK,IAWb,YAAAihB,OAAP,SAAcC,EAAmBC,GAC/B,IAAMrjB,EAASojB,EAAMpjB,OAErB,IAAKA,EACH,OAAO,EAGT,IACIyjB,EACAC,EACAC,EACAC,EAJA1N,EAAO,EAKP+M,EAAY,EACZK,EAAW,EAGf,GAAIpiB,KAAKsiB,QAAQ,GAAI,CACnB,IAAIK,GAAiB,EACjBC,EAAK5iB,KAAKsiB,QAAQ,GACtBM,GAAyB,MAAV,IAALA,GAAwB,GAAyB,MAAV,IAALA,GAAwB,GAAO,EAG3E,IAFA,IAAIC,EAAM,EACNC,OAAG,GACCA,EAA4B,GAAtB9iB,KAAKsiB,UAAUO,KAAgBA,EAAM,GACjDD,IAAO,EACPA,GAAME,EAKR,IAFA,IAAM/lB,EAAsC,MAAV,IAAlBiD,KAAKsiB,QAAQ,IAAwB,EAAmC,MAAV,IAAlBtiB,KAAKsiB,QAAQ,IAAwB,EAAI,EAC/FS,EAAUhmB,EAAO8lB,EAChBT,EAAWW,GAAS,CACzB,GAAIX,GAAYtjB,EACd,OAAO,EAGT,GAAqB,MAAV,KADXgkB,EAAMZ,EAAME,OACe,CAEzBA,IACAO,GAAiB,EACjB,MAGA3iB,KAAKsiB,QAAQO,KAASC,EACtBF,IAAO,EACPA,GAAY,GAANE,EAGLH,IAEU,IAAT5lB,EACE6lB,EAAK,IAEPR,IAEAD,EAAOnN,KAAU4N,EAED,IAAT7lB,EACL6lB,EAAK,MAAWA,GAAM,OAAUA,GAAM,QAGxCT,EAAOnN,KAAU4N,GAGfA,EAAK,OAAYA,EAAK,UAGxBT,EAAOnN,KAAU4N,IAIvB5iB,KAAKsiB,QAAQthB,KAAK,GAMpB,IAFA,IAAMgiB,EAAWlkB,EAAS,EACtBrE,EAAI2nB,EACD3nB,EAAIqE,GAAQ,CAejB,SAAOrE,EAAIuoB,IACiB,KAApBT,EAAQL,EAAMznB,KACU,KAAxB+nB,EAAQN,EAAMznB,EAAI,KACM,KAAxBgoB,EAAQP,EAAMznB,EAAI,KACM,KAAxBioB,EAAQR,EAAMznB,EAAI,MAExB0nB,EAAOnN,KAAUuN,EACjBJ,EAAOnN,KAAUwN,EACjBL,EAAOnN,KAAUyN,EACjBN,EAAOnN,KAAU0N,EACjBjoB,GAAK,EAOP,IAHA8nB,EAAQL,EAAMznB,MAGF,IACV0nB,EAAOnN,KAAUuN,OAGZ,GAAuB,MAAV,IAARA,GAAwB,CAClC,GAAI9nB,GAAKqE,EAEP,OADAkB,KAAKsiB,QAAQ,GAAKC,EACXvN,EAGT,GAAuB,MAAV,KADbwN,EAAQN,EAAMznB,OACe,CAE3BA,IACA,SAGF,IADAsnB,GAAqB,GAARQ,IAAiB,EAAa,GAARC,GACnB,IAAM,CAEpB/nB,IACA,SAEF0nB,EAAOnN,KAAU+M,OAGZ,GAAuB,MAAV,IAARQ,GAAwB,CAClC,GAAI9nB,GAAKqE,EAEP,OADAkB,KAAKsiB,QAAQ,GAAKC,EACXvN,EAGT,GAAuB,MAAV,KADbwN,EAAQN,EAAMznB,OACe,CAE3BA,IACA,SAEF,GAAIA,GAAKqE,EAGP,OAFAkB,KAAKsiB,QAAQ,GAAKC,EAClBviB,KAAKsiB,QAAQ,GAAKE,EACXxN,EAGT,GAAuB,MAAV,KADbyN,EAAQP,EAAMznB,OACe,CAE3BA,IACA,SAGF,IADAsnB,GAAqB,GAARQ,IAAiB,IAAc,GAARC,IAAiB,EAAa,GAARC,GAC1C,MAAWV,GAAa,OAAUA,GAAa,MAE7D,SAEFI,EAAOnN,KAAU+M,OAGZ,GAAuB,MAAV,IAARQ,GAAwB,CAClC,GAAI9nB,GAAKqE,EAEP,OADAkB,KAAKsiB,QAAQ,GAAKC,EACXvN,EAGT,GAAuB,MAAV,KADbwN,EAAQN,EAAMznB,OACe,CAE3BA,IACA,SAEF,GAAIA,GAAKqE,EAGP,OAFAkB,KAAKsiB,QAAQ,GAAKC,EAClBviB,KAAKsiB,QAAQ,GAAKE,EACXxN,EAGT,GAAuB,MAAV,KADbyN,EAAQP,EAAMznB,OACe,CAE3BA,IACA,SAEF,GAAIA,GAAKqE,EAIP,OAHAkB,KAAKsiB,QAAQ,GAAKC,EAClBviB,KAAKsiB,QAAQ,GAAKE,EAClBxiB,KAAKsiB,QAAQ,GAAKG,EACXzN,EAGT,GAAuB,MAAV,KADb0N,EAAQR,EAAMznB,OACe,CAE3BA,IACA,SAGF,IADAsnB,GAAqB,EAARQ,IAAiB,IAAc,GAARC,IAAiB,IAAc,GAARC,IAAiB,EAAa,GAARC,GACjE,OAAYX,EAAY,QAEtC,SAEFI,EAAOnN,KAAU+M,GAKrB,OAAO/M,GAEX,EAjOA,GAAa,EAAAiO,e,yGC/Gb,aAEA,OAKA,OA4CMC,EADwB,EACsBrlB,aAAaslB,kBAIjE,0BAgBE,YACUpX,EACA5H,EACAgK,EACAmD,GAHA,KAAAvF,YACA,KAAA5H,UACA,KAAAgK,MACA,KAAAmD,cAVF,KAAAE,UAAuB,CAC7BC,MAAO,EACPC,WAAY,IAAI7T,aAdsB,KAetCuC,UAAW,IAAIvC,aAAa,KAS5B,MAAMf,EAAKkD,KAAKmO,IAEhBnO,KAAKojB,SAAW,EAAAlmB,aAAa,EAAAe,cAAcnB,EA/DpB,obAiBE,gIAiDzBkD,KAAKqjB,oBAAsB,EAAAnmB,aAAaJ,EAAGwmB,mBAAmBtjB,KAAKojB,SAAU,iBAC7EpjB,KAAKujB,oBAAsB,EAAArmB,aAAaJ,EAAGwmB,mBAAmBtjB,KAAKojB,SAAU,iBAG7EpjB,KAAKwjB,mBAAqB1mB,EAAG2mB,oBAC7B3mB,EAAG4mB,gBAAgB1jB,KAAKwjB,oBAGxB,MAAMG,EAAmB,IAAI9lB,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAC1D+lB,EAAyB9mB,EAAG+mB,eAClC/mB,EAAGgnB,WAAWhnB,EAAGinB,aAAcH,GAC/B9mB,EAAGknB,WAAWlnB,EAAGinB,aAAcJ,EAAkB7mB,EAAGmnB,aACpDnnB,EAAGonB,wBAAwB,GAC3BpnB,EAAGqnB,oBAAoB,EAAiC,EAAGnkB,KAAKmO,IAAIiW,OAAO,EAAO,EAAG,GAIrF,MAAMC,EAAyB,IAAI3R,WAAW,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,IACxD4R,EAAuBxnB,EAAG+mB,eAChC/mB,EAAGgnB,WAAWhnB,EAAGynB,qBAAsBD,GACvCxnB,EAAGknB,WAAWlnB,EAAGynB,qBAAsBF,EAAwBvnB,EAAGmnB,aAGlEjkB,KAAKwkB,kBAAoB,EAAAtnB,aAAaJ,EAAG+mB,gBACzC/mB,EAAGgnB,WAAWhnB,EAAGinB,aAAc/jB,KAAKwkB,mBACpC1nB,EAAGonB,wBAAwB,GAC3BpnB,EAAGqnB,oBAAoB,EAAgC,EAAGrnB,EAAGsnB,OAAO,EAAOlB,EAAqB,GAChGpmB,EAAG2nB,oBAAoB,EAAgC,GACvD3nB,EAAGonB,wBAAwB,GAC3BpnB,EAAGqnB,oBAAoB,EAA4B,EAAGrnB,EAAGsnB,OAAO,EAAOlB,EAAqB,EAAIrlB,aAAaslB,mBAC7GrmB,EAAG2nB,oBAAoB,EAA4B,GACnD3nB,EAAGonB,wBAAwB,GAC3BpnB,EAAGqnB,oBAAoB,EAA6B,EAAGrnB,EAAGsnB,OAAO,EAAOlB,EAAqB,EAAIrlB,aAAaslB,mBAC9GrmB,EAAG2nB,oBAAoB,EAA6B,GAEpDzkB,KAAK0kB,sBAGA,SACL,MAAM5nB,EAAKkD,KAAKmO,IAEhBrR,EAAG6nB,WAAW3kB,KAAKojB,UAEnBtmB,EAAG4mB,gBAAgB1jB,KAAKwjB,oBAExB1mB,EAAG8nB,iBAAiB5kB,KAAKujB,qBAAqB,EAAO,EAAA3lB,mBACrDd,EAAG+nB,UAAU7kB,KAAKqjB,oBAAqBvmB,EAAGgoB,OAAOle,MAAO9J,EAAGgoB,OAAOhe,QAGlEhK,EAAGgnB,WAAWhnB,EAAGinB,aAAc/jB,KAAKwkB,mBACpC1nB,EAAGknB,WAAWlnB,EAAGinB,aAAc/jB,KAAKwR,UAAUE,WAAY5U,EAAGioB,cAC7DjoB,EAAGkoB,sBAAsBhlB,KAAKmO,IAAI8W,UAAW,EAAGnoB,EAAG2V,cAAe,EAAGzS,KAAKwR,UAAUC,OAGpF3U,EAAGgnB,WAAWhnB,EAAGinB,aAAc/jB,KAAKwkB,mBACpC1nB,EAAGknB,WAAWlnB,EAAGinB,aAAc/jB,KAAKwR,UAAUpR,UAAWtD,EAAGioB,cAC5DjoB,EAAGkoB,sBAAsBhlB,KAAKmO,IAAI8W,UAAW,EAAGnoB,EAAG2V,cAAe,EAAG,GAGhE,WACLzS,KAAKklB,2BAGA,YACLllB,KAAK0kB,sBACL1kB,KAAKklB,2BAGC,sBACNllB,KAAKmlB,SAAWnlB,KAAKolB,qBAAqBplB,KAAKmE,QAAQuD,YACvD1H,KAAKqlB,gBAAkBrlB,KAAKolB,qBAAqBplB,KAAKmE,QAAQ2F,iBAGxD,2BAEN9J,KAAKslB,mBACHtlB,KAAKwR,UAAUE,WACf,EACA,EACA,EACA1R,KAAK+L,UAAUlL,KAAOb,KAAKsR,YAAYhL,gBACvCtG,KAAK+L,UAAUjL,KAAOd,KAAKsR,YAAY/K,iBACvCvG,KAAKmlB,UAIF,gBAAgBjP,GACrB,MAAMxQ,EAAW1F,KAAK+L,UAEtB,GAAKmK,EAAM7V,aAKX,GAAI6V,EAAM5V,iBAAkB,CAC1B,MAAMK,EAAWuV,EAAMvV,SACjBiG,EAAQsP,EAAMtV,OAASD,EACvBmG,EAASoP,EAAMxV,qBAAuBwV,EAAMzV,uBAAyB,EAC3ET,KAAKslB,mBACHtlB,KAAKwR,UAAUpR,UACf,EACAO,EAAWX,KAAKsR,YAAYhL,gBAC5B4P,EAAMzV,uBAAyBT,KAAKsR,YAAY/K,iBAChDK,EAAQ5G,KAAKsR,YAAYhL,gBACzBQ,EAAS9G,KAAKsR,YAAY/K,iBAC1BvG,KAAKqlB,iBAEP,EAAArkB,KAAKhB,KAAKwR,UAAUpR,UAAW,EA3IP,OA4InB,CAEL,MAAMO,EAAWuV,EAAM3V,mBAAqB2V,EAAMzV,uBAAyByV,EAAMvV,SAAW,EACtFyV,EAAiBF,EAAMzV,yBAA2ByV,EAAM1V,eAAiB0V,EAAMtV,OAAS8E,EAAS7E,KACvGb,KAAKslB,mBACHtlB,KAAKwR,UAAUpR,UACf,EACAO,EAAWX,KAAKsR,YAAYhL,gBAC5B4P,EAAMzV,uBAAyBT,KAAKsR,YAAY/K,kBAC/C6P,EAAiBzV,GAAYX,KAAKsR,YAAYhL,gBAC/CtG,KAAKsR,YAAY/K,iBACjBvG,KAAKqlB,iBAIP,MAAMhP,EAAkBzX,KAAKF,IAAIwX,EAAMxV,qBAAuBwV,EAAMzV,uBAAyB,EAAG,GAYhG,GAXAT,KAAKslB,mBACHtlB,KAAKwR,UAAUpR,UA7JO,EA+JtB,GACC8V,EAAMzV,uBAAyB,GAAKT,KAAKsR,YAAY/K,iBACtDb,EAAS7E,KAAOb,KAAKsR,YAAYhL,gBACjC+P,EAAkBrW,KAAKsR,YAAY/K,iBACnCvG,KAAKqlB,iBAIHnP,EAAMzV,yBAA2ByV,EAAMxV,qBAAsB,CAE/D,MAAME,EAASsV,EAAM1V,iBAAmB0V,EAAMxV,qBAAuBwV,EAAMtV,OAAS8E,EAAS7E,KAC7Fb,KAAKslB,mBACHtlB,KAAKwR,UAAUpR,UACfmlB,GACA,EACArP,EAAMxV,qBAAuBV,KAAKsR,YAAY/K,iBAC9C3F,EAASZ,KAAKsR,YAAYhL,gBAC1BtG,KAAKsR,YAAY/K,iBACjBvG,KAAKqlB,sBAGP,EAAArkB,KAAKhB,KAAKwR,UAAUpR,UAAW,EAAGmlB,SA1DpC,EAAAvkB,KAAKhB,KAAKwR,UAAUpR,UAAW,EAAG,GA+D/B,kBAAkB8V,GACvB,MAAMxQ,EAAW1F,KAAK+L,UAChByZ,EAAWxlB,KAAKwR,UAEtB,IAAIiU,EAAiB,EAErB,IAAK,IAAIte,EAAI,EAAGA,EAAIzB,EAAS5E,KAAMqG,IAAK,CACtC,IAAIue,GAAiB,EACjBC,EAAY,EACZC,EAAY,EACZC,GAAiB,EACrB,IAAK,IAAI3e,EAAI,EAAGA,EAAIxB,EAAS7E,KAAMqG,IAAK,CACtC,MAAM4e,GAAe3e,EAAIzB,EAAS7E,KAAQqG,GAAK,EAAAtH,+BACzC8B,EAAKwU,EAAMjW,MAAM6lB,EAAa,EAAAjmB,wBAC9B4B,EAAKyU,EAAMjW,MAAM6lB,EAAa,EAAAhmB,wBAC9B6Z,KAAkB,SAALlY,GACnB,GAAIC,IAAOikB,GAAclkB,IAAOmkB,IAAcC,GAAkBlM,GAAW,CAEzE,GAAkB,IAAdgM,GAAoBE,GAAgC,IAAdD,EAAkB,CAC1D,MAAMvR,EA5MY,EA4MHoR,IACfzlB,KAAK+lB,iBAAiBP,EAAUnR,EAAQuR,EAAWD,EAAWD,EAAexe,EAAGC,GAElFue,EAAgBxe,EAChBye,EAAYjkB,EACZkkB,EAAYnkB,EACZokB,EAAiBlM,GAIrB,GAAkB,IAAdgM,GAAoBE,GAAgC,IAAdD,EAAkB,CAC1D,MAAMvR,EAvNgB,EAuNPoR,IACfzlB,KAAK+lB,iBAAiBP,EAAUnR,EAAQuR,EAAWD,EAAWD,EAAehgB,EAAS7E,KAAMsG,IAGhGqe,EAAS/T,MAAQgU,EAGX,iBAAiBD,EAAqBnR,EAAgB5S,EAAYC,EAAYskB,EAAgBC,EAAc9e,GAClH,IAAIqC,EACJ,GAAS,SAAL/H,EACF,OAAa,SAALA,GACN,KAAK,SACL,KAAK,SACH+H,EAAOxJ,KAAKmE,QAAQ4F,KAAU,IAALtI,GAA6B+H,KACtD,MACF,KAAK,SACHA,GAAa,SAAL/H,IAA6B,EACrC,MACF,KAAK,EACL,QACE+H,EAAOxJ,KAAKmE,QAAQuF,WAAWF,UAGnC,OAAa,SAAL9H,GACN,KAAK,SACL,KAAK,SACH8H,EAAOxJ,KAAKmE,QAAQ4F,KAAU,IAALrI,GAA6B8H,KACtD,MACF,KAAK,SACHA,GAAa,SAAL9H,IAA6B,EACrC,MACF,KAAK,EACL,QACE8H,EAAOxJ,KAAKmE,QAAQuD,WAAW8B,KAIjCgc,EAAS9T,WAAW5S,OAASuV,EAAS,IACxCmR,EAAS9T,WAAa,EAAAwU,mBAAmBV,EAAS9T,WAAY1R,KAAK+L,UAAUjL,KAAOd,KAAK+L,UAAUlL,KA7P3E,IA+P1B,MAAM4W,EAAKuO,EAAShmB,KAAKsR,YAAYhL,gBAC/BoR,EAAKvQ,EAAInH,KAAKsR,YAAY/K,iBAC1B5K,GAAM6N,GAAQ,GAAM,KAAQ,IAC5BqS,GAAMrS,GAAQ,GAAM,KAAQ,IAC5BnI,GAAMmI,GAAQ,EAAM,KAAQ,IAElCxJ,KAAKmmB,cAAcX,EAAS9T,WAAY2C,EAAQoD,EAAIC,GAAKuO,EAAOD,GAAUhmB,KAAKsR,YAAYhL,gBAAiBtG,KAAKsR,YAAY/K,iBAAkB5K,EAAGkgB,EAAGxa,EAAG,GAGlJ,cAAcH,EAAqBmT,EAAgBoD,EAAYC,EAAY9Q,EAAeE,EAAgBnL,EAAWkgB,EAAWxa,EAAW7G,GACjJ0G,EAAMmT,GAAcoD,EACpBvW,EAAMmT,EAAS,GAAKqD,EACpBxW,EAAMmT,EAAS,GAAKzN,EACpB1F,EAAMmT,EAAS,GAAKvN,EACpB5F,EAAMmT,EAAS,GAAK1Y,EACpBuF,EAAMmT,EAAS,GAAKwH,EACpB3a,EAAMmT,EAAS,GAAKhT,EACpBH,EAAMmT,EAAS,GAAK7Z,EAGd,mBAAmB0G,EAAqBmT,EAAgBoD,EAAYC,EAAY9Q,EAAeE,EAAgB8U,GACrH1a,EAAMmT,GAAcoD,EACpBvW,EAAMmT,EAAS,GAAKqD,EACpBxW,EAAMmT,EAAS,GAAKzN,EACpB1F,EAAMmT,EAAS,GAAKvN,EACpB5F,EAAMmT,EAAS,GAAKuH,EAAM,GAC1B1a,EAAMmT,EAAS,GAAKuH,EAAM,GAC1B1a,EAAMmT,EAAS,GAAKuH,EAAM,GAC1B1a,EAAMmT,EAAS,GAAKuH,EAAM,GAGpB,qBAAqBA,GAC3B,OAAO,IAAI/d,aAAa,EACpB+d,EAAMpS,MAAQ,GAAM,KAAQ,KAC5BoS,EAAMpS,MAAQ,GAAM,KAAQ,KAC5BoS,EAAMpS,MAAQ,EAAM,KAAQ,KACR,IAApBoS,EAAU,MAAkB,S,6IC/UpC,iBAIE,aAHU,KAAAwK,aAA8B,GAC9B,KAAAC,aAAuB,EAqCnC,OA7BS,YAAAhhB,QAAP,WACErF,KAAKqmB,aAAc,EACnB,IAAgB,UAAArmB,KAAKomB,aAAL,eAAmB,CAAvB,KACR/gB,UAEJrF,KAAKomB,aAAatnB,OAAS,GAQtB,YAAAwnB,SAAP,SAAuCnrB,GAErC,OADA6E,KAAKomB,aAAajd,KAAKhO,GAChBA,GAQF,YAAAorB,WAAP,SAAyCprB,GACvC,IAAMmO,EAAQtJ,KAAKomB,aAAatd,QAAQ3N,IACzB,IAAXmO,GACFtJ,KAAKomB,aAAald,OAAOI,EAAO,IAGtC,EAvCA,GA4CA,SAAgBkd,EAAaC,GAC3B,IAAgB,UAAAA,EAAA,eAAa,CAAjB,KACRphB,UAEJohB,EAAY3nB,OAAS,EAhDD,EAAAsO,aA4CtB,iBAUA,qCAA0ClM,GACxC,MAAO,CAAEmE,QAAS,WAAM,OAAAmhB,EAAatlB,O,mHC7CvC,8BACU,KAAAwlB,WAAgC,GAEhC,KAAAC,WAAqB,EAwC/B,OAtCE,sBAAW,oBAAK,C,IAAhB,sBAmBE,OAlBK3mB,KAAK4mB,SACR5mB,KAAK4mB,OAAS,SAACC,GAcb,OAbA,EAAKH,WAAWvd,KAAK0d,GACF,CACjBxhB,QAAS,WACP,IAAK,EAAKshB,UACR,IAAK,IAAIlsB,EAAI,EAAGA,EAAI,EAAKisB,WAAW5nB,OAAQrE,IAC1C,GAAI,EAAKisB,WAAWjsB,KAAOosB,EAEzB,YADA,EAAKH,WAAWxd,OAAOzO,EAAG,OAUjCuF,KAAK4mB,Q,gCAGP,YAAAhX,KAAP,SAAYkX,EAASC,GAEnB,IADA,IAAMC,EAA2B,GACxBvsB,EAAI,EAAGA,EAAIuF,KAAK0mB,WAAW5nB,OAAQrE,IAC1CusB,EAAM7d,KAAKnJ,KAAK0mB,WAAWjsB,IAE7B,IAASA,EAAI,EAAGA,EAAIusB,EAAMloB,OAAQrE,IAChCusB,EAAMvsB,GAAGO,UAAK8R,EAAWga,EAAMC,IAI5B,YAAA1hB,QAAP,WACMrF,KAAK0mB,aACP1mB,KAAK0mB,WAAW5nB,OAAS,GAE3BkB,KAAK2mB,WAAY,GAErB,EA3CA,GAAa,EAAAjZ,eA6Cb,wBAAgCuZ,EAAiBC,GAC/C,OAAOD,GAAK,SAAAhQ,GAAK,OAAAiQ,EAAGtX,KAAKqH","file":"xterm-addon-aframe.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\n/**\n * A matrix that when multiplies will translate 0-1 coordinates (left to right,\n * top to bottom) to clip space.\n */\nexport const PROJECTION_MATRIX = new Float32Array([\n  2, 0, 0, 0,\n  0, -2, 0, 0,\n  0, 0, 1, 0,\n  -1, 1, 0, 1\n]);\n\nexport function createProgram(gl: WebGLRenderingContext, vertexSource: string, fragmentSource: string): WebGLProgram | undefined {\n  const program = throwIfFalsy(gl.createProgram());\n  gl.attachShader(program, throwIfFalsy(createShader(gl, gl.VERTEX_SHADER, vertexSource)));\n  gl.attachShader(program, throwIfFalsy(createShader(gl, gl.FRAGMENT_SHADER, fragmentSource)));\n  gl.linkProgram(program);\n  const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (success) {\n    return program;\n  }\n\n  console.error(gl.getProgramInfoLog(program));\n  gl.deleteProgram(program);\n}\n\nexport function createShader(gl: WebGLRenderingContext, type: number, source: string): WebGLShader | undefined {\n  const shader = throwIfFalsy(gl.createShader(type));\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  if (success) {\n    return shader;\n  }\n\n  console.error(gl.getShaderInfoLog(shader));\n  gl.deleteShader(shader);\n}\n\nexport function expandFloat32Array(source: Float32Array, max: number): Float32Array {\n  const newLength = Math.min(source.length * 2, max);\n  const newArray = new Float32Array(newLength);\n  for (let i = 0; i < source.length; i++) {\n    newArray[i] = source[i];\n  }\n  return newArray;\n}\n\nexport function throwIfFalsy<T>(value: T | undefined | null): T {\n  if (!value) {\n    throw new Error('value must not be falsy');\n  }\n  return value;\n}\n","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport const DEFAULT_COLOR = 256;\nexport const DEFAULT_ATTR = (0 << 18) | (DEFAULT_COLOR << 9) | (256 << 0);\n\nexport const CHAR_DATA_ATTR_INDEX = 0;\nexport const CHAR_DATA_CHAR_INDEX = 1;\nexport const CHAR_DATA_WIDTH_INDEX = 2;\nexport const CHAR_DATA_CODE_INDEX = 3;\n\n/**\n * Null cell - a real empty cell (containing nothing).\n * Note that code should always be 0 for a null cell as\n * several test condition of the buffer line rely on this.\n */\nexport const NULL_CELL_CHAR = '';\nexport const NULL_CELL_WIDTH = 1;\nexport const NULL_CELL_CODE = 0;\n\n/**\n * Whitespace cell.\n * This is meant as a replacement for empty cells when needed\n * during rendering lines to preserve correct aligment.\n */\nexport const WHITESPACE_CELL_CHAR = ' ';\nexport const WHITESPACE_CELL_WIDTH = 1;\nexport const WHITESPACE_CELL_CODE = 32;\n\n/**\n * Bitmasks for accessing data in `content`.\n */\nexport const enum Content {\n  /**\n   * bit 1..21    codepoint, max allowed in UTF32 is 0x10FFFF (21 bits taken)\n   *              read:   `codepoint = content & Content.codepointMask;`\n   *              write:  `content |= codepoint & Content.codepointMask;`\n   *                      shortcut if precondition `codepoint <= 0x10FFFF` is met:\n   *                      `content |= codepoint;`\n   */\n  CODEPOINT_MASK = 0x1FFFFF,\n\n  /**\n   * bit 22       flag indication whether a cell contains combined content\n   *              read:   `isCombined = content & Content.isCombined;`\n   *              set:    `content |= Content.isCombined;`\n   *              clear:  `content &= ~Content.isCombined;`\n   */\n  IS_COMBINED_MASK = 0x200000,  // 1 << 21\n\n  /**\n   * bit 1..22    mask to check whether a cell contains any string data\n   *              we need to check for codepoint and isCombined bits to see\n   *              whether a cell contains anything\n   *              read:   `isEmpty = !(content & Content.hasContent)`\n   */\n  HAS_CONTENT_MASK = 0x3FFFFF,\n\n  /**\n   * bit 23..24   wcwidth value of cell, takes 2 bits (ranges from 0..2)\n   *              read:   `width = (content & Content.widthMask) >> Content.widthShift;`\n   *                      `hasWidth = content & Content.widthMask;`\n   *                      as long as wcwidth is highest value in `content`:\n   *                      `width = content >> Content.widthShift;`\n   *              write:  `content |= (width << Content.widthShift) & Content.widthMask;`\n   *                      shortcut if precondition `0 <= width <= 3` is met:\n   *                      `content |= width << Content.widthShift;`\n   */\n  WIDTH_MASK = 0xC00000,   // 3 << 22\n  WIDTH_SHIFT = 22\n}\n\nexport const enum Attributes {\n  /**\n   * bit 1..8     blue in RGB, color in P256 and P16\n   */\n  BLUE_MASK = 0xFF,\n  BLUE_SHIFT = 0,\n  PCOLOR_MASK = 0xFF,\n  PCOLOR_SHIFT = 0,\n\n  /**\n   * bit 9..16    green in RGB\n   */\n  GREEN_MASK = 0xFF00,\n  GREEN_SHIFT = 8,\n\n  /**\n   * bit 17..24   red in RGB\n   */\n  RED_MASK = 0xFF0000,\n  RED_SHIFT = 16,\n\n  /**\n   * bit 25..26   color mode: DEFAULT (0) | P16 (1) | P256 (2) | RGB (3)\n   */\n  CM_MASK = 0x3000000,\n  CM_DEFAULT = 0,\n  CM_P16 = 0x1000000,\n  CM_P256 = 0x2000000,\n  CM_RGB = 0x3000000,\n\n  /**\n   * bit 1..24  RGB room\n   */\n  RGB_MASK = 0xFFFFFF\n}\n\nexport const enum FgFlags {\n  /**\n   * bit 27..31 (32th bit unused)\n   */\n  INVERSE = 0x4000000,\n  BOLD = 0x8000000,\n  UNDERLINE = 0x10000000,\n  BLINK = 0x20000000,\n  INVISIBLE = 0x40000000\n}\n\nexport const enum BgFlags {\n  /**\n   * bit 27..32 (upper 3 unused)\n   */\n  ITALIC = 0x4000000,\n  DIM = 0x8000000,\n  HAS_EXTENDED = 0x10000000\n}\n\nexport const enum UnderlineStyle {\n  NONE = 0,\n  SINGLE = 1,\n  DOUBLE = 2,\n  CURLY = 3,\n  DOTTED = 4,\n  DASHED = 5\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IRenderModel, ISelectionRenderModel } from './Types';\nimport { fill } from 'common/TypedArrayUtils';\n\nexport const RENDER_MODEL_INDICIES_PER_CELL = 3;\nexport const RENDER_MODEL_BG_OFFSET = 1;\nexport const RENDER_MODEL_FG_OFFSET = 2;\n\nexport const COMBINED_CHAR_BIT_MASK = 0x80000000;\n\nexport class RenderModel implements IRenderModel {\n  public cells: Uint32Array;\n  public lineLengths: Uint32Array;\n  public selection: ISelectionRenderModel;\n\n  constructor() {\n    this.cells = new Uint32Array(0);\n    this.lineLengths = new Uint32Array(0);\n    this.selection = {\n      hasSelection: false,\n      columnSelectMode: false,\n      viewportStartRow: 0,\n      viewportEndRow: 0,\n      viewportCappedStartRow: 0,\n      viewportCappedEndRow: 0,\n      startCol: 0,\n      endCol: 0\n    };\n  }\n\n  public resize(cols: number, rows: number): void {\n    const indexCount = cols * rows * RENDER_MODEL_INDICIES_PER_CELL;\n    if (indexCount !== this.cells.length) {\n      this.cells = new Uint32Array(indexCount);\n      this.lineLengths = new Uint32Array(rows);\n    }\n  }\n\n  public clear(): void {\n    fill(this.cells, 0, 0);\n    fill(this.lineLengths, 0, 0);\n  }\n\n  public clearSelection(): void {\n    this.selection.hasSelection = false;\n    this.selection.viewportStartRow = 0;\n    this.selection.viewportEndRow = 0;\n    this.selection.viewportCappedStartRow = 0;\n    this.selection.viewportCappedEndRow = 0;\n    this.selection.startCol = 0;\n    this.selection.endCol = 0;\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport type TypedArray = Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array;\n\n\n/**\n * polyfill for TypedArray.fill\n * This is needed to support .fill in all safari versions and IE 11.\n */\nexport function fill<T extends TypedArray>(array: T, value: number, start?: number, end?: number): T {\n  // all modern engines that support .fill\n  if (array.fill) {\n    return array.fill(value, start, end) as T;\n  }\n  return fillFallback(array, value, start, end);\n}\n\nexport function fillFallback<T extends TypedArray>(array: T, value: number, start: number = 0, end: number = array.length): T {\n  // safari and IE 11\n  // since IE 11 does not support Array.prototype.fill either\n  // we cannot use the suggested polyfill from MDN\n  // instead we simply fall back to looping\n  if (start >= array.length) {\n    return array;\n  }\n  start = (array.length + start) % array.length;\n  if (end >= array.length) {\n    end = array.length;\n  } else {\n    end = (array.length + end) % array.length;\n  }\n  for (let i = start; i < end; ++i) {\n    array[i] = value;\n  }\n  return array;\n}\n\n/**\n * Concat two typed arrays `a` and `b`.\n * Returns a new typed array.\n */\nexport function concat<T extends TypedArray>(a: T, b: T): T {\n  const result = new (a.constructor as any)(a.length + b.length);\n  result.set(a);\n  result.set(b, a.length);\n  return result;\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IAttributeData, IColorRGB, IExtendedAttrs } from 'common/Types';\nimport { Attributes, FgFlags, BgFlags, UnderlineStyle } from 'common/buffer/Constants';\n\nexport class AttributeData implements IAttributeData {\n  public static toColorRGB(value: number): IColorRGB {\n    return [\n      value >>> Attributes.RED_SHIFT & 255,\n      value >>> Attributes.GREEN_SHIFT & 255,\n      value & 255\n    ];\n  }\n\n  public static fromColorRGB(value: IColorRGB): number {\n    return (value[0] & 255) << Attributes.RED_SHIFT | (value[1] & 255) << Attributes.GREEN_SHIFT | value[2] & 255;\n  }\n\n  public clone(): IAttributeData {\n    const newObj = new AttributeData();\n    newObj.fg = this.fg;\n    newObj.bg = this.bg;\n    newObj.extended = this.extended.clone();\n    return newObj;\n  }\n\n  // data\n  public fg = 0;\n  public bg = 0;\n  public extended = new ExtendedAttrs();\n\n  // flags\n  public isInverse(): number   { return this.fg & FgFlags.INVERSE; }\n  public isBold(): number      { return this.fg & FgFlags.BOLD; }\n  public isUnderline(): number { return this.fg & FgFlags.UNDERLINE; }\n  public isBlink(): number     { return this.fg & FgFlags.BLINK; }\n  public isInvisible(): number { return this.fg & FgFlags.INVISIBLE; }\n  public isItalic(): number    { return this.bg & BgFlags.ITALIC; }\n  public isDim(): number       { return this.bg & BgFlags.DIM; }\n\n  // color modes\n  public getFgColorMode(): number { return this.fg & Attributes.CM_MASK; }\n  public getBgColorMode(): number { return this.bg & Attributes.CM_MASK; }\n  public isFgRGB(): boolean       { return (this.fg & Attributes.CM_MASK) === Attributes.CM_RGB; }\n  public isBgRGB(): boolean       { return (this.bg & Attributes.CM_MASK) === Attributes.CM_RGB; }\n  public isFgPalette(): boolean   { return (this.fg & Attributes.CM_MASK) === Attributes.CM_P16 || (this.fg & Attributes.CM_MASK) === Attributes.CM_P256; }\n  public isBgPalette(): boolean   { return (this.bg & Attributes.CM_MASK) === Attributes.CM_P16 || (this.bg & Attributes.CM_MASK) === Attributes.CM_P256; }\n  public isFgDefault(): boolean   { return (this.fg & Attributes.CM_MASK) === 0; }\n  public isBgDefault(): boolean   { return (this.bg & Attributes.CM_MASK) === 0; }\n  public isAttributeDefault(): boolean { return this.fg === 0 && this.bg === 0; }\n\n  // colors\n  public getFgColor(): number {\n    switch (this.fg & Attributes.CM_MASK) {\n      case Attributes.CM_P16:\n      case Attributes.CM_P256:  return this.fg & Attributes.PCOLOR_MASK;\n      case Attributes.CM_RGB:   return this.fg & Attributes.RGB_MASK;\n      default:                  return -1;  // CM_DEFAULT defaults to -1\n    }\n  }\n  public getBgColor(): number {\n    switch (this.bg & Attributes.CM_MASK) {\n      case Attributes.CM_P16:\n      case Attributes.CM_P256:  return this.bg & Attributes.PCOLOR_MASK;\n      case Attributes.CM_RGB:   return this.bg & Attributes.RGB_MASK;\n      default:                  return -1;  // CM_DEFAULT defaults to -1\n    }\n  }\n\n  // extended attrs\n  public hasExtendedAttrs(): number {\n    return this.bg & BgFlags.HAS_EXTENDED;\n  }\n  public updateExtended(): void {\n    if (this.extended.isEmpty()) {\n      this.bg &= ~BgFlags.HAS_EXTENDED;\n    } else {\n      this.bg |= BgFlags.HAS_EXTENDED;\n    }\n  }\n  public getUnderlineColor(): number {\n    if ((this.bg & BgFlags.HAS_EXTENDED) && ~this.extended.underlineColor) {\n      switch (this.extended.underlineColor & Attributes.CM_MASK) {\n        case Attributes.CM_P16:\n        case Attributes.CM_P256:  return this.extended.underlineColor & Attributes.PCOLOR_MASK;\n        case Attributes.CM_RGB:   return this.extended.underlineColor & Attributes.RGB_MASK;\n        default:                  return this.getFgColor();\n      }\n    }\n    return this.getFgColor();\n  }\n  public getUnderlineColorMode(): number {\n    return (this.bg & BgFlags.HAS_EXTENDED) && ~this.extended.underlineColor\n      ? this.extended.underlineColor & Attributes.CM_MASK\n      : this.getFgColorMode();\n  }\n  public isUnderlineColorRGB(): boolean {\n    return (this.bg & BgFlags.HAS_EXTENDED) && ~this.extended.underlineColor\n      ? (this.extended.underlineColor & Attributes.CM_MASK) === Attributes.CM_RGB\n      : this.isFgRGB();\n  }\n  public isUnderlineColorPalette(): boolean {\n    return (this.bg & BgFlags.HAS_EXTENDED) && ~this.extended.underlineColor\n      ? (this.extended.underlineColor & Attributes.CM_MASK) === Attributes.CM_P16\n          || (this.extended.underlineColor & Attributes.CM_MASK) === Attributes.CM_P256\n      : this.isFgPalette();\n  }\n  public isUnderlineColorDefault(): boolean {\n    return (this.bg & BgFlags.HAS_EXTENDED) && ~this.extended.underlineColor\n      ? (this.extended.underlineColor & Attributes.CM_MASK) === 0\n      : this.isFgDefault();\n  }\n  public getUnderlineStyle(): UnderlineStyle {\n    return this.fg & FgFlags.UNDERLINE\n      ? (this.bg & BgFlags.HAS_EXTENDED ? this.extended.underlineStyle : UnderlineStyle.SINGLE)\n      : UnderlineStyle.NONE;\n  }\n}\n\n\n/**\n * Extended attributes for a cell.\n * Holds information about different underline styles and color.\n */\nexport class ExtendedAttrs implements IExtendedAttrs {\n  constructor(\n    // underline style, NONE is empty\n    public underlineStyle: UnderlineStyle = UnderlineStyle.NONE,\n    // underline color, -1 is empty (same as FG)\n    public underlineColor: number = -1\n  ) {}\n\n  public clone(): IExtendedAttrs {\n    return new ExtendedAttrs(this.underlineStyle, this.underlineColor);\n  }\n\n  /**\n   * Convenient method to indicate whether the object holds no additional information,\n   * that needs to be persistant in the buffer.\n   */\n  public isEmpty(): boolean {\n    return this.underlineStyle === UnderlineStyle.NONE;\n  }\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IRenderLayer } from './Types';\nimport { acquireCharAtlas } from '../atlas/CharAtlasCache';\nimport { Terminal } from 'xterm';\nimport { IColorSet } from 'browser/Types';\nimport { IRenderDimensions } from 'browser/renderer/Types';\nimport { CellData } from 'common/buffer/CellData';\nimport { WebglCharAtlas } from 'atlas/WebglCharAtlas';\nimport { throwIfFalsy } from '../WebglUtils';\n\nexport abstract class BaseRenderLayer implements IRenderLayer {\n  private _canvas: any;//HTMLCanvasElement;\n  protected _ctx!: CanvasRenderingContext2D;\n  private _scaledCharWidth: number = 0;\n  private _scaledCharHeight: number = 0;\n  private _scaledCellWidth: number = 0;\n  private _scaledCellHeight: number = 0;\n  private _scaledCharLeft: number = 0;\n  private _scaledCharTop: number = 0;\n\n  protected _charAtlas: WebglCharAtlas | undefined;\n\n  constructor(\n    private _container: HTMLElement,\n    id: string,\n    zIndex: number,\n    private _alpha: boolean,\n    protected _colors: IColorSet\n  ) {\n    this._canvas = document.createElement('canvas');\n    this._canvas.classList.add(`xterm-${id}-layer`);\n    this._canvas.style.zIndex = zIndex.toString();\n    this._initCanvas();\n    this._container.appendChild(this._canvas);\n  }\n\n  public dispose(): void {\n    this._container.removeChild(this._canvas);\n    if (this._charAtlas) {\n      this._charAtlas.dispose();\n    }\n  }\n\n  private _initCanvas(): void {\n    this._ctx = throwIfFalsy(this._canvas.getContext('2d', {alpha: this._alpha}));\n    // Draw the background if this is an opaque layer\n    if (!this._alpha) {\n      this._clearAll();\n    }\n  }\n\n  public onOptionsChanged(terminal: Terminal): void {}\n  public onBlur(terminal: Terminal): void {}\n  public onFocus(terminal: Terminal): void {}\n  public onCursorMove(terminal: Terminal): void {}\n  public onGridChanged(terminal: Terminal, startRow: number, endRow: number): void {}\n  public onSelectionChanged(terminal: Terminal, start: [number, number] | undefined, end: [number, number] | undefined, columnSelectMode: boolean = false): void {}\n\n  public setColors(terminal: Terminal, colorSet: IColorSet): void {\n    this._refreshCharAtlas(terminal, colorSet);\n  }\n\n  protected _setTransparency(terminal: Terminal, alpha: boolean): void {\n    // Do nothing when alpha doesn't change\n    if (alpha === this._alpha) {\n      return;\n    }\n\n    // Create new canvas and replace old one\n    const oldCanvas = this._canvas;\n    this._alpha = alpha;\n    // Cloning preserves properties\n    this._canvas = this._canvas.cloneNode() as HTMLCanvasElement;\n    this._initCanvas();\n    this._container.replaceChild(this._canvas, oldCanvas);\n\n    // Regenerate char atlas and force a full redraw\n    this._refreshCharAtlas(terminal, this._colors);\n    this.onGridChanged(terminal, 0, terminal.rows - 1);\n  }\n\n  /**\n   * Refreshes the char atlas, aquiring a new one if necessary.\n   * @param terminal The terminal.\n   * @param colorSet The color set to use for the char atlas.\n   */\n  private _refreshCharAtlas(terminal: Terminal, colorSet: IColorSet): void {\n    if (this._scaledCharWidth <= 0 && this._scaledCharHeight <= 0) {\n      return;\n    }\n    this._charAtlas = acquireCharAtlas(terminal, colorSet, this._scaledCharWidth, this._scaledCharHeight);\n    this._charAtlas.warmUp();\n  }\n\n  public resize(terminal: Terminal, dim: IRenderDimensions): void {\n    this._scaledCellWidth = dim.scaledCellWidth;\n    this._scaledCellHeight = dim.scaledCellHeight;\n    this._scaledCharWidth = dim.scaledCharWidth;\n    this._scaledCharHeight = dim.scaledCharHeight;\n    this._scaledCharLeft = dim.scaledCharLeft;\n    this._scaledCharTop = dim.scaledCharTop;\n    this._canvas.width = dim.scaledCanvasWidth;\n    this._canvas.height = dim.scaledCanvasHeight;\n    this._canvas.style.width = `${dim.canvasWidth}px`;\n    this._canvas.style.height = `${dim.canvasHeight}px`;\n\n    // Draw the background if this is an opaque layer\n    if (!this._alpha) {\n      this._clearAll();\n    }\n\n    this._refreshCharAtlas(terminal, this._colors);\n  }\n\n  public abstract reset(terminal: Terminal): void;\n\n  /**\n   * Fills 1+ cells completely. This uses the existing fillStyle on the context.\n   * @param x The column to start at.\n   * @param y The row to start at\n   * @param width The number of columns to fill.\n   * @param height The number of rows to fill.\n   */\n  protected _fillCells(x: number, y: number, width: number, height: number): void {\n    this._ctx.fillRect(\n      x * this._scaledCellWidth,\n      y * this._scaledCellHeight,\n      width * this._scaledCellWidth,\n      height * this._scaledCellHeight);\n  }\n\n  /**\n   * Fills a 1px line (2px on HDPI) at the bottom of the cell. This uses the\n   * existing fillStyle on the context.\n   * @param x The column to fill.\n   * @param y The row to fill.\n   */\n  protected _fillBottomLineAtCells(x: number, y: number, width: number = 1): void {\n    this._ctx.fillRect(\n      x * this._scaledCellWidth,\n      (y + 1) * this._scaledCellHeight - window.devicePixelRatio - 1 /* Ensure it's drawn within the cell */,\n      width * this._scaledCellWidth,\n      window.devicePixelRatio);\n  }\n\n  /**\n   * Fills a 1px line (2px on HDPI) at the left of the cell. This uses the\n   * existing fillStyle on the context.\n   * @param x The column to fill.\n   * @param y The row to fill.\n   */\n  protected _fillLeftLineAtCell(x: number, y: number, width: number): void {\n    this._ctx.fillRect(\n      x * this._scaledCellWidth,\n      y * this._scaledCellHeight,\n      window.devicePixelRatio * width,\n      this._scaledCellHeight);\n  }\n\n  /**\n   * Strokes a 1px rectangle (2px on HDPI) around a cell. This uses the existing\n   * strokeStyle on the context.\n   * @param x The column to fill.\n   * @param y The row to fill.\n   */\n  protected _strokeRectAtCell(x: number, y: number, width: number, height: number): void {\n    this._ctx.lineWidth = window.devicePixelRatio;\n    this._ctx.strokeRect(\n      x * this._scaledCellWidth + window.devicePixelRatio / 2,\n      y * this._scaledCellHeight + (window.devicePixelRatio / 2),\n      width * this._scaledCellWidth - window.devicePixelRatio,\n      (height * this._scaledCellHeight) - window.devicePixelRatio);\n  }\n\n  /**\n   * Clears the entire canvas.\n   */\n  protected _clearAll(): void {\n    if (this._alpha) {\n      this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n    } else {\n      this._ctx.fillStyle = this._colors.background.css;\n      this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);\n    }\n  }\n\n  /**\n   * Clears 1+ cells completely.\n   * @param x The column to start at.\n   * @param y The row to start at.\n   * @param width The number of columns to clear.\n   * @param height The number of rows to clear.\n   */\n  protected _clearCells(x: number, y: number, width: number, height: number): void {\n    if (this._alpha) {\n      this._ctx.clearRect(\n        x * this._scaledCellWidth,\n        y * this._scaledCellHeight,\n        width * this._scaledCellWidth,\n        height * this._scaledCellHeight);\n    } else {\n      this._ctx.fillStyle = this._colors.background.css;\n      this._ctx.fillRect(\n        x * this._scaledCellWidth,\n        y * this._scaledCellHeight,\n        width * this._scaledCellWidth,\n        height * this._scaledCellHeight);\n    }\n  }\n\n  /**\n   * Draws a truecolor character at the cell. The character will be clipped to\n   * ensure that it fits with the cell, including the cell to the right if it's\n   * a wide character. This uses the existing fillStyle on the context.\n   * @param terminal The terminal.\n   * @param cell The cell data for the character to draw.\n   * @param x The column to draw at.\n   * @param y The row to draw at.\n   * @param color The color of the character.\n   */\n  protected _fillCharTrueColor(terminal: Terminal, cell: CellData, x: number, y: number): void {\n    this._ctx.font = this._getFont(terminal, false, false);\n    this._ctx.textBaseline = 'middle';\n    this._clipRow(terminal, y);\n    this._ctx.fillText(\n      cell.getChars(),\n      x * this._scaledCellWidth + this._scaledCharLeft,\n      y * this._scaledCellHeight + this._scaledCharTop + this._scaledCharHeight / 2);\n  }\n\n  /**\n   * Clips a row to ensure no pixels will be drawn outside the cells in the row.\n   * @param terminal The terminal.\n   * @param y The row to clip.\n   */\n  private _clipRow(terminal: Terminal, y: number): void {\n    this._ctx.beginPath();\n    this._ctx.rect(\n      0,\n      y * this._scaledCellHeight,\n      terminal.cols * this._scaledCellWidth,\n      this._scaledCellHeight);\n    this._ctx.clip();\n  }\n\n  /**\n   * Gets the current font.\n   * @param terminal The terminal.\n   * @param isBold If we should use the bold fontWeight.\n   */\n  protected _getFont(terminal: Terminal, isBold: boolean, isItalic: boolean): string {\n    const fontWeight = isBold ? terminal.getOption('fontWeightBold') : terminal.getOption('fontWeight');\n    const fontStyle = isItalic ? 'italic' : '';\n\n    return `${fontStyle} ${fontWeight} ${terminal.getOption('fontSize') * window.devicePixelRatio}px ${terminal.getOption('fontFamily')}`;\n  }\n}\n\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { generateConfig, configEquals } from './CharAtlasUtils';\nimport { WebglCharAtlas } from './WebglCharAtlas';\nimport { ICharAtlasConfig } from './Types';\nimport { Terminal } from 'xterm';\nimport { IColorSet } from 'browser/Types';\n\ninterface ICharAtlasCacheEntry {\n  atlas: WebglCharAtlas;\n  config: ICharAtlasConfig;\n  // N.B. This implementation potentially holds onto copies of the terminal forever, so\n  // this may cause memory leaks.\n  ownedBy: Terminal[];\n}\n\nconst charAtlasCache: ICharAtlasCacheEntry[] = [];\n\n/**\n * Acquires a char atlas, either generating a new one or returning an existing\n * one that is in use by another terminal.\n * @param terminal The terminal.\n * @param colors The colors to use.\n */\nexport function acquireCharAtlas(\n  terminal: Terminal,\n  colors: IColorSet,\n  scaledCharWidth: number,\n  scaledCharHeight: number\n): WebglCharAtlas {\n  const newConfig = generateConfig(scaledCharWidth, scaledCharHeight, terminal, colors);\n\n  // Check to see if the terminal already owns this config\n  for (let i = 0; i < charAtlasCache.length; i++) {\n    const entry = charAtlasCache[i];\n    const ownedByIndex = entry.ownedBy.indexOf(terminal);\n    if (ownedByIndex >= 0) {\n      if (configEquals(entry.config, newConfig)) {\n        return entry.atlas;\n      }\n      // The configs differ, release the terminal from the entry\n      if (entry.ownedBy.length === 1) {\n        entry.atlas.dispose();\n        charAtlasCache.splice(i, 1);\n      } else {\n        entry.ownedBy.splice(ownedByIndex, 1);\n      }\n      break;\n    }\n  }\n\n  // Try match a char atlas from the cache\n  for (let i = 0; i < charAtlasCache.length; i++) {\n    const entry = charAtlasCache[i];\n    if (configEquals(entry.config, newConfig)) {\n      // Add the terminal to the cache entry and return\n      entry.ownedBy.push(terminal);\n      return entry.atlas;\n    }\n  }\n\n  const newEntry: ICharAtlasCacheEntry = {\n    atlas: new WebglCharAtlas(document, newConfig),\n    config: newConfig,\n    ownedBy: [terminal]\n  };\n  charAtlasCache.push(newEntry);\n  return newEntry.atlas;\n}\n\n/**\n * Removes a terminal reference from the cache, allowing its memory to be freed.\n * @param terminal The terminal to remove.\n */\nexport function removeTerminalFromCache(terminal: Terminal): void {\n  for (let i = 0; i < charAtlasCache.length; i++) {\n    const index = charAtlasCache[i].ownedBy.indexOf(terminal);\n    if (index !== -1) {\n      if (charAtlasCache[i].ownedBy.length === 1) {\n        // Remove the cache entry if it's the only terminal\n        charAtlasCache[i].atlas.dispose();\n        charAtlasCache.splice(i, 1);\n      } else {\n        // Remove the reference from the cache entry\n        charAtlasCache[i].ownedBy.splice(index, 1);\n      }\n      break;\n    }\n  }\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { ICharAtlasConfig } from './Types';\nimport { Attributes } from 'common/buffer/Constants';\nimport { Terminal, FontWeight } from 'xterm';\nimport { IColorSet, IColor } from 'browser/Types';\n\nconst NULL_COLOR: IColor = {\n  css: '',\n  rgba: 0\n};\n\nexport function generateConfig(scaledCharWidth: number, scaledCharHeight: number, terminal: Terminal, colors: IColorSet): ICharAtlasConfig {\n  // null out some fields that don't matter\n  const clonedColors: IColorSet = {\n    foreground: colors.foreground,\n    background: colors.background,\n    cursor: NULL_COLOR,\n    cursorAccent: NULL_COLOR,\n    selectionTransparent: NULL_COLOR,\n    selectionOpaque: NULL_COLOR,\n    // For the static char atlas, we only use the first 16 colors, but we need all 256 for the\n    // dynamic character atlas.\n    ansi: colors.ansi.slice(),\n    contrastCache: colors.contrastCache\n  };\n  return {\n    devicePixelRatio: window.devicePixelRatio,\n    scaledCharWidth,\n    scaledCharHeight,\n    fontFamily: terminal.getOption('fontFamily'),\n    fontSize: terminal.getOption('fontSize'),\n    fontWeight: terminal.getOption('fontWeight') as FontWeight,\n    fontWeightBold: terminal.getOption('fontWeightBold') as FontWeight,\n    allowTransparency: terminal.getOption('allowTransparency'),\n    drawBoldTextInBrightColors: terminal.getOption('drawBoldTextInBrightColors'),\n    minimumContrastRatio: terminal.getOption('minimumContrastRatio'),\n    colors: clonedColors\n  };\n}\n\nexport function configEquals(a: ICharAtlasConfig, b: ICharAtlasConfig): boolean {\n  for (let i = 0; i < a.colors.ansi.length; i++) {\n    if (a.colors.ansi[i].rgba !== b.colors.ansi[i].rgba) {\n      return false;\n    }\n  }\n  return a.devicePixelRatio === b.devicePixelRatio &&\n      a.fontFamily === b.fontFamily &&\n      a.fontSize === b.fontSize &&\n      a.fontWeight === b.fontWeight &&\n      a.fontWeightBold === b.fontWeightBold &&\n      a.allowTransparency === b.allowTransparency &&\n      a.scaledCharWidth === b.scaledCharWidth &&\n      a.scaledCharHeight === b.scaledCharHeight &&\n      a.drawBoldTextInBrightColors === b.drawBoldTextInBrightColors &&\n      a.minimumContrastRatio === b.minimumContrastRatio &&\n      a.colors.foreground === b.colors.foreground &&\n      a.colors.background === b.colors.background;\n}\n\nexport function is256Color(colorCode: number): boolean {\n  return (colorCode & Attributes.CM_MASK) === Attributes.CM_P16 || (colorCode & Attributes.CM_MASK) === Attributes.CM_P256;\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport const INVERTED_DEFAULT_COLOR = 257;\nexport const DIM_OPACITY = 0.5;\n\nexport const CHAR_ATLAS_CELL_SPACING = 1;\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { CharData, ICellData, IExtendedAttrs } from 'common/Types';\nimport { stringFromCodePoint } from 'common/input/TextDecoder';\nimport { CHAR_DATA_CHAR_INDEX, CHAR_DATA_WIDTH_INDEX, CHAR_DATA_ATTR_INDEX, Content } from 'common/buffer/Constants';\nimport { AttributeData, ExtendedAttrs } from 'common/buffer/AttributeData';\n\n/**\n * CellData - represents a single Cell in the terminal buffer.\n */\nexport class CellData extends AttributeData implements ICellData {\n  /** Helper to create CellData from CharData. */\n  public static fromCharData(value: CharData): CellData {\n    const obj = new CellData();\n    obj.setFromCharData(value);\n    return obj;\n  }\n  /** Primitives from terminal buffer. */\n  public content = 0;\n  public fg = 0;\n  public bg = 0;\n  public extended: IExtendedAttrs = new ExtendedAttrs();\n  public combinedData = '';\n  /** Whether cell contains a combined string. */\n  public isCombined(): number {\n    return this.content & Content.IS_COMBINED_MASK;\n  }\n  /** Width of the cell. */\n  public getWidth(): number {\n    return this.content >> Content.WIDTH_SHIFT;\n  }\n  /** JS string of the content. */\n  public getChars(): string {\n    if (this.content & Content.IS_COMBINED_MASK) {\n      return this.combinedData;\n    }\n    if (this.content & Content.CODEPOINT_MASK) {\n      return stringFromCodePoint(this.content & Content.CODEPOINT_MASK);\n    }\n    return '';\n  }\n  /**\n   * Codepoint of cell\n   * Note this returns the UTF32 codepoint of single chars,\n   * if content is a combined string it returns the codepoint\n   * of the last char in string to be in line with code in CharData.\n   * */\n  public getCode(): number {\n    return (this.isCombined())\n      ? this.combinedData.charCodeAt(this.combinedData.length - 1)\n      : this.content & Content.CODEPOINT_MASK;\n  }\n  /** Set data from CharData */\n  public setFromCharData(value: CharData): void {\n    this.fg = value[CHAR_DATA_ATTR_INDEX];\n    this.bg = 0;\n    let combined = false;\n    // surrogates and combined strings need special treatment\n    if (value[CHAR_DATA_CHAR_INDEX].length > 2) {\n      combined = true;\n    }\n    else if (value[CHAR_DATA_CHAR_INDEX].length === 2) {\n      const code = value[CHAR_DATA_CHAR_INDEX].charCodeAt(0);\n      // if the 2-char string is a surrogate create single codepoint\n      // everything else is combined\n      if (0xD800 <= code && code <= 0xDBFF) {\n        const second = value[CHAR_DATA_CHAR_INDEX].charCodeAt(1);\n        if (0xDC00 <= second && second <= 0xDFFF) {\n          this.content = ((code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000) | (value[CHAR_DATA_WIDTH_INDEX] << Content.WIDTH_SHIFT);\n        }\n        else {\n          combined = true;\n        }\n      }\n      else {\n        combined = true;\n      }\n    }\n    else {\n      this.content = value[CHAR_DATA_CHAR_INDEX].charCodeAt(0) | (value[CHAR_DATA_WIDTH_INDEX] << Content.WIDTH_SHIFT);\n    }\n    if (combined) {\n      this.combinedData = value[CHAR_DATA_CHAR_INDEX];\n      this.content = Content.IS_COMBINED_MASK | (value[CHAR_DATA_WIDTH_INDEX] << Content.WIDTH_SHIFT);\n    }\n  }\n  /** Get data as CharData. */\n  public getAsCharData(): CharData {\n    return [this.fg, this.getChars(), this.getWidth(), this.getCode()];\n  }\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { Terminal, ITerminalAddon } from 'xterm';\nimport { AframeRenderer } from './AframeRenderer';\nimport { IRenderService } from 'browser/services/Services'; // '../xterm.js'; // if you use \"\"noImplicitAny\": false\" in tsconfig.json\nimport { IColorSet } from 'browser/Types';\nimport { AFrame } from 'aframe';\n\nexport class AframeAddon implements ITerminalAddon {\n  private _terminal?: Terminal;\n  private _renderer?: AframeRenderer;\n  private _size?: any;\n\n  constructor(private _gl_three: any)\n  {\n    console.log(\"construct addon\");\n  }\n\n  public activate(terminal: Terminal): void {\n    if (!terminal.element) {\n      throw new Error('Cannot activate AframeAddon before Terminal.open');\n    }\n\n    this._terminal = terminal;\n    const renderService: IRenderService = (<any>terminal)._core._renderService;\n    const colors: IColorSet = (<any>terminal)._core._colorManager.colors;\n    this._renderer = new AframeRenderer(terminal, colors, this._gl_three);\n    this._size = new AFRAME.THREE.Vector3(this._renderer.dimensions.scaledCanvasWidth, this._renderer.dimensions.scaledCanvasHeight, 0);\n  }\n\n  public dispose(): void {\n    if (!this._terminal) {\n      throw new Error('Cannot dispose WebglAddon because it is activated');\n    }\n    const renderService: IRenderService = (this._terminal as any)._core._renderService;\n    renderService.setRenderer((this._terminal as any)._core._createRenderer());\n    renderService.onResize(this._terminal.cols, this._terminal.rows);\n    this._renderer = undefined;\n  }\n\n  public get textureAtlas(): HTMLCanvasElement | undefined {\n    return this._renderer?.textureAtlas;\n  }\n\n  public get bufferGeometry(): any {\n    return this._renderer?.bufferGeometry;\n  }\n\n  public get shaderMaterial(): any {\n    return this._renderer?.shaderMaterial;\n  }\n\n  public get canvasSize(): any {\n    return this._size;\n  }\n\n  public clearTextureAtlas(): void {\n    this._renderer?.clearCharAtlas();\n  }\n\n  public tick(): void {\n    this._renderer?.updateRows(0, 24);\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { AframeGlyphRenderer } from './AframeGlyphRenderer'; // WebGL shader and color\nimport { LinkRenderLayer } from './renderLayer/LinkRenderLayer'; // likifier? URL and underline\nimport { CursorRenderLayer } from './renderLayer/CursorRenderLayer'; // Cursor properties looking / animation / rendercallback\nimport { acquireCharAtlas } from './atlas/CharAtlasCache'; // texture atlas (has webglcharatlas)\nimport { WebglCharAtlas } from './atlas/WebglCharAtlas'; // Browser canvas / WebGL texture / fontstyle etc.\nimport { RectangleRenderer } from './RectangleRenderer'; // WebGL shader and color\nimport { IWebGL2RenderingContext } from './Types'; // ts typing? WebGL accessor\nimport { RenderModel, COMBINED_CHAR_BIT_MASK, RENDER_MODEL_BG_OFFSET, RENDER_MODEL_FG_OFFSET, RENDER_MODEL_INDICIES_PER_CELL } from './RenderModel'; // selection and FG/BG something\nimport { Disposable } from 'common/Lifecycle'; // register / unregister and dispose array\nimport { NULL_CELL_CODE } from 'common/buffer/Constants'; // common constants for font highlight and coloring\nimport { Terminal, IEvent } from 'xterm'; // base xterm (no webgl) but not confirmed yet XXX\nimport { IRenderLayer } from './renderLayer/Types'; // definition of xterm, color and renderdimensions(font size) (no WebGL)\nimport { IRenderDimensions, IRenderer, IRequestRedrawEvent } from 'browser/renderer/Types'; // definition of xterm, browser event and redraw count(start/end)\nimport { ITerminal, IColorSet } from 'browser/Types'; // facade class (HTML, browser, buffer, camena, option, link, event) and color\nimport { EventEmitter } from 'common/EventEmitter'; // event queue\nimport { CellData } from 'common/buffer/CellData'; // terminal cell\n\nexport class AframeRenderer extends Disposable implements IRenderer {\n  private _renderLayers: IRenderLayer[];\n  private _charAtlas: WebglCharAtlas | undefined;\n  private _devicePixelRatio: number;\n\n  private _model: RenderModel = new RenderModel();\n  private _workCell: CellData = new CellData();\n\n  private _canvas: any;\n  private _gl: IWebGL2RenderingContext;\n  private _rectangleRenderer: RectangleRenderer;\n  private _glyphRenderer:  AframeGlyphRenderer;\n\n  public dimensions: IRenderDimensions;\n\n  private _core: ITerminal;\n  private _isAttached: boolean;\n\n  private _onRequestRedraw = new EventEmitter<IRequestRedrawEvent>();\n  public get onRequestRedraw(): IEvent<IRequestRedrawEvent> { return this._onRequestRedraw.event; }\n\n  constructor(\n    private _terminal: Terminal,\n    private _colors: IColorSet,\n    private _gl_three: IWebGL2RenderingContext,\n  ) {\n    super();\n\n    this._core = (this._terminal as any)._core;\n\n    this._renderLayers = [\n      new LinkRenderLayer(this._core.screenElement!, 2, this._colors, this._core),\n      new CursorRenderLayer(this._core.screenElement!, 3, this._colors, this._onRequestRedraw)\n    ];\n    this.dimensions = {\n      scaledCharWidth: 0,\n      scaledCharHeight: 0,\n      scaledCellWidth: 0,\n      scaledCellHeight: 0,\n      scaledCharLeft: 0,\n      scaledCharTop: 0,\n      scaledCanvasWidth: 0,\n      scaledCanvasHeight: 0,\n      canvasWidth: 0,\n      canvasHeight: 0,\n      actualCellWidth: 0,\n      actualCellHeight: 0\n    };\n    this._devicePixelRatio = window.devicePixelRatio;\n    this._updateDimensions();\n\n    console.log('canvas -----------------------------v');\n    // canvas\n    this._canvas = document.createElement('canvas');\n    this._gl = this._gl_three;\n\n    if (!this._gl) { throw new Error('WebGL2 not supported ' + this._gl); }\n\n    this._core.screenElement!.appendChild(this._canvas);\n    this._rectangleRenderer = new RectangleRenderer(this._terminal, this._colors, this._gl, this.dimensions);\n    this._glyphRenderer = new AframeGlyphRenderer(this._terminal, this._colors, this._gl, this.dimensions);\n    // Update dimensions and acquire char atlas\n    this.onCharSizeChanged();\n    this._isAttached = document.body.contains(this._core.screenElement!);\n  }\n\n  public get bufferGeometry(): any\n  {\n    return this._glyphRenderer.getBufferGeometry;\n  }\n\n  public get shaderMaterial(): any\n  {\n    return this._glyphRenderer.shaderMaterial;\n  }\n\n  public get textureObject(): WebGLTexture | undefined\n  {\n    return this._glyphRenderer._atlasTexture;\n  }\n\n  public dispose(): void {\n    this._renderLayers.forEach(l => l.dispose());\n    this._core.screenElement!.removeChild(this._canvas);\n    super.dispose();\n  }\n\n  public get textureAtlas(): HTMLCanvasElement | undefined {\n    return this._charAtlas?.cacheCanvas;\n  }\n\n  public setColors(colors: IColorSet): void {\n    this._colors = colors;\n    // Clear layers and force a full render\n    this._renderLayers.forEach(l => {\n      l.setColors(this._terminal, this._colors);\n      l.reset(this._terminal);\n    });\n\n    this._rectangleRenderer.setColors();\n    this._glyphRenderer.setColors();\n\n    this._refreshCharAtlas();\n\n    this._rectangleRenderer.updateSelection(this._model.selection);\n    this._glyphRenderer.updateSelection(this._model);\n\n    // Force a full refresh\n    this._model.clear();\n    this._model.clearSelection();\n  }\n\n  public onDevicePixelRatioChange(): void {\n    // If the device pixel ratio changed, the char atlas needs to be regenerated\n    // and the terminal needs to refreshed\n    if (this._devicePixelRatio !== window.devicePixelRatio) {\n      this._devicePixelRatio = window.devicePixelRatio;\n      this.onResize(this._terminal.cols, this._terminal.rows);\n    }\n  }\n\n  public onResize(cols: number, rows: number): void {\n    // Update character and canvas dimensions\n    this._updateDimensions();\n\n    this._model.resize(this._terminal.cols, this._terminal.rows);\n    this._rectangleRenderer.onResize();\n\n    // Resize all render layers\n    this._renderLayers.forEach(l => l.resize(this._terminal, this.dimensions));\n\n    // Resize the canvas\n    this._canvas.width = this.dimensions.scaledCanvasWidth;\n    this._canvas.height = this.dimensions.scaledCanvasHeight;\n    this._canvas.style.width = `${this.dimensions.canvasWidth}px`;\n    this._canvas.style.height = `${this.dimensions.canvasHeight}px`;\n\n    // Resize the screen\n    this._core.screenElement!.style.width = `${this.dimensions.canvasWidth}px`;\n    this._core.screenElement!.style.height = `${this.dimensions.canvasHeight}px`;\n    this._glyphRenderer.setDimensions(this.dimensions);\n    this._glyphRenderer.onResize();\n\n    this._refreshCharAtlas();\n\n    // Force a full refresh\n    this._model.clear();\n    this._model.clearSelection();\n  }\n\n  public onCharSizeChanged(): void {\n    this.onResize(this._terminal.cols, this._terminal.rows);\n  }\n\n  public onBlur(): void {\n    this._renderLayers.forEach(l => l.onBlur(this._terminal));\n  }\n\n  public onFocus(): void {\n    this._renderLayers.forEach(l => l.onFocus(this._terminal));\n  }\n\n  public onSelectionChanged(start: [number, number] | undefined, end: [number, number] | undefined, columnSelectMode: boolean): void {\n    this._renderLayers.forEach(l => l.onSelectionChanged(this._terminal, start, end, columnSelectMode));\n\n    this._updateSelectionModel(start, end, columnSelectMode);\n\n    this._rectangleRenderer.updateSelection(this._model.selection);\n    this._glyphRenderer.updateSelection(this._model);\n\n    this._onRequestRedraw.fire({ start: 0, end: this._terminal.rows - 1 });\n  }\n\n  public onCursorMove(): void {\n    this._renderLayers.forEach(l => l.onCursorMove(this._terminal));\n   }\n\n  public onOptionsChanged(): void {\n    this._renderLayers.forEach(l => l.onOptionsChanged(this._terminal));\n    this._updateDimensions();\n    this._refreshCharAtlas();\n  }\n\n  /**\n   * Refreshes the char atlas, aquiring a new one if necessary.\n   * @param terminal The terminal.\n   * @param colorSet The color set to use for the char atlas.\n   */\n  private _refreshCharAtlas(): void {\n    if (this.dimensions.scaledCharWidth <= 0 && this.dimensions.scaledCharHeight <= 0) {\n      // Mark as not attached so char atlas gets refreshed on next render\n      this._isAttached = false;\n      return;\n    }\n\n    const atlas = acquireCharAtlas(this._terminal, this._colors, this.dimensions.scaledCharWidth,\n                                   this.dimensions.scaledCharHeight);\n    if (!('getRasterizedGlyph' in atlas))\n    {\n      throw new Error('The webgl renderer only works with the webgl char atlas');\n    }\n    this._charAtlas = atlas as WebglCharAtlas;\n    this._charAtlas.warmUp();\n    this._glyphRenderer.setAtlas(this._charAtlas);\n\n    console.log('canvas warmup--------------- USE CanvasTexture');\n  }\n\n  public clearCharAtlas(): void {\n    this._charAtlas?.clearTexture();\n    this._model.clear();\n    this._updateModel(0, this._terminal.rows - 1);\n    this._glyphRenderer.updateSelection(this._model);\n    this._onRequestRedraw.fire({ start: 0, end: this._terminal.rows - 1 });\n  }\n\n  public clear(): void {\n    this._renderLayers.forEach(l => l.reset(this._terminal));\n  }\n\n  public registerCharacterJoiner(handler: (text: string) => [number, number][]): number {\n    return -1;\n  }\n\n  public deregisterCharacterJoiner(joinerId: number): boolean {\n    return false;\n  }\n\n  public updateRows(start: number, end: number): void {\n    if (!this._isAttached) {\n      if (document.body.contains(this._core.screenElement!) && (this._core as any)._charSizeService.width && (this._core as any)._charSizeService.height) {\n        this._updateDimensions();\n        this._refreshCharAtlas();\n        this._isAttached = true;\n      } else {\n        return;\n      }\n    }\n\n    // Update render layers\n    this._renderLayers.forEach(l => l.onGridChanged(this._terminal, start, end));\n\n    // Tell renderer the frame is beginning\n    if (this._glyphRenderer.beginFrame()) {\n      this._model.clear();\n      this._model.clearSelection();\n    }\n\n    // Update model to reflect what's drawn\n    this._updateModel(start, end);\n\n    this._glyphRenderer.debug();\n\n    // Render\n    /*\n    this._rectangleRenderer.render();\n    this._glyphRenderer.render(this._model, this._model.selection.hasSelection);\n    */\n  }\n\n  public renderRows(start: number, end: number): void {\n    if (!this._isAttached) {\n      if (document.body.contains(this._core.screenElement!) && (this._core as any)._charSizeService.width && (this._core as any)._charSizeService.height) {\n        this._updateDimensions();\n        this._refreshCharAtlas();\n        this._isAttached = true;\n      } else {\n        return;\n      }\n    }\n\n    // Update render layers\n    this._renderLayers.forEach(l => l.onGridChanged(this._terminal, start, end));\n\n    // Tell renderer the frame is beginning\n    if (this._glyphRenderer.beginFrame()) {\n      this._model.clear();\n      this._model.clearSelection();\n    }\n\n    // Update model to reflect what's drawn\n    this._updateModel(start, end);\n\n    this._glyphRenderer.updateAtlas();\n    // Render\n    /*\n    this._rectangleRenderer.render();\n    this._glyphRenderer.render(this._model, this._model.selection.hasSelection);\n    */\n  }\n\n  private _updateModel(start: number, end: number): void {\n    const terminal = this._core;\n\n    for (let y = start; y <= end; y++) {\n      const row = y + terminal.buffer.ydisp;\n      const line = terminal.buffer.lines.get(row)!;\n      this._model.lineLengths[y] = 0;\n      for (let x = 0; x < terminal.cols; x++) {\n        line.loadCell(x, this._workCell);\n\n        const chars = this._workCell.getChars();\n        let code = this._workCell.getCode();\n        const i = ((y * terminal.cols) + x) * RENDER_MODEL_INDICIES_PER_CELL;\n\n        if (code !== NULL_CELL_CODE) {\n          this._model.lineLengths[y] = x + 1;\n        }\n\n        // Nothing has changed, no updates needed\n        if (this._model.cells[i] === code &&\n          this._model.cells[i + RENDER_MODEL_BG_OFFSET] === this._workCell.bg &&\n          this._model.cells[i + RENDER_MODEL_FG_OFFSET] === this._workCell.fg) {\n          continue;\n        }\n\n        // Flag combined chars with a bit mask so they're easily identifiable\n        if (chars.length > 1) {\n          code = code | COMBINED_CHAR_BIT_MASK;\n        }\n\n        // Cache the results in the model\n        this._model.cells[i] = code;\n        this._model.cells[i + RENDER_MODEL_BG_OFFSET] = this._workCell.bg;\n        this._model.cells[i + RENDER_MODEL_FG_OFFSET] = this._workCell.fg;\n\n        this._glyphRenderer.updateCell(x, y, code, this._workCell.bg, this._workCell.fg, chars);\n      }\n\n\n    }\n    this._rectangleRenderer.updateBackgrounds(this._model);\n  }\n\n  private _updateSelectionModel(start: [number, number] | undefined, end: [number, number] | undefined, columnSelectMode: boolean): void {\n    const terminal = this._terminal;\n\n    // Selection does not exist\n    if (!start || !end || (start[0] === end[0] && start[1] === end[1])) {\n      this._model.clearSelection();\n      return;\n    }\n\n    // Translate from buffer position to viewport position\n    const viewportStartRow = start[1] - terminal.buffer.active.viewportY;\n    const viewportEndRow = end[1] - terminal.buffer.active.viewportY;\n    const viewportCappedStartRow = Math.max(viewportStartRow, 0);\n    const viewportCappedEndRow = Math.min(viewportEndRow, terminal.rows - 1);\n\n    // No need to draw the selection\n    if (viewportCappedStartRow >= terminal.rows || viewportCappedEndRow < 0) {\n      this._model.clearSelection();\n      return;\n    }\n\n    this._model.selection.hasSelection = true;\n    this._model.selection.columnSelectMode = columnSelectMode;\n    this._model.selection.viewportStartRow = viewportStartRow;\n    this._model.selection.viewportEndRow = viewportEndRow;\n    this._model.selection.viewportCappedStartRow = viewportCappedStartRow;\n    this._model.selection.viewportCappedEndRow = viewportCappedEndRow;\n    this._model.selection.startCol = start[0];\n    this._model.selection.endCol = end[0];\n  }\n\n  /**\n   * Recalculates the character and canvas dimensions.\n   */\n  private _updateDimensions(): void {\n    // TODO: Acquire CharSizeService properly\n\n    // Perform a new measure if the CharMeasure dimensions are not yet available\n    if (!(this._core as any)._charSizeService.width || !(this._core as any)._charSizeService.height) {\n      return;\n    }\n\n    // Calculate the scaled character width. Width is floored as it must be\n    // drawn to an integer grid in order for the CharAtlas \"stamps\" to not be\n    // blurry. When text is drawn to the grid not using the CharAtlas, it is\n    // clipped to ensure there is no overlap with the next cell.\n\n    // NOTE: ceil fixes sometime, floor does others :s\n\n    this.dimensions.scaledCharWidth = Math.floor((this._core as any)._charSizeService.width * this._devicePixelRatio);\n\n    // Calculate the scaled character height. Height is ceiled in case\n    // devicePixelRatio is a floating point number in order to ensure there is\n    // enough space to draw the character to the cell.\n    this.dimensions.scaledCharHeight = Math.ceil((this._core as any)._charSizeService.height * this._devicePixelRatio);\n\n    // Calculate the scaled cell height, if lineHeight is not 1 then the value\n    // will be floored because since lineHeight can never be lower then 1, there\n    // is a guarentee that the scaled line height will always be larger than\n    // scaled char height.\n    this.dimensions.scaledCellHeight = Math.floor(this.dimensions.scaledCharHeight * this._terminal.getOption('lineHeight'));\n\n    // Calculate the y coordinate within a cell that text should draw from in\n    // order to draw in the center of a cell.\n    this.dimensions.scaledCharTop = this._terminal.getOption('lineHeight') === 1 ? 0 : Math.round((this.dimensions.scaledCellHeight - this.dimensions.scaledCharHeight) / 2);\n\n    // Calculate the scaled cell width, taking the letterSpacing into account.\n    this.dimensions.scaledCellWidth = this.dimensions.scaledCharWidth + Math.round(this._terminal.getOption('letterSpacing'));\n\n    // Calculate the x coordinate with a cell that text should draw from in\n    // order to draw in the center of a cell.\n    this.dimensions.scaledCharLeft = Math.floor(this._terminal.getOption('letterSpacing') / 2);\n\n    // Recalculate the canvas dimensions; scaled* define the actual number of\n    // pixel in the canvas\n    this.dimensions.scaledCanvasHeight = this._terminal.rows * this.dimensions.scaledCellHeight;\n    this.dimensions.scaledCanvasWidth = this._terminal.cols * this.dimensions.scaledCellWidth;\n\n    // The the size of the canvas on the page. It's very important that this\n    // rounds to nearest integer and not ceils as browsers often set\n    // window.devicePixelRatio as something like 1.100000023841858, when it's\n    // actually 1.1. Ceiling causes blurriness as the backing canvas image is 1\n    // pixel too large for the canvas element size.\n    this.dimensions.canvasHeight = Math.round(this.dimensions.scaledCanvasHeight / this._devicePixelRatio);\n    this.dimensions.canvasWidth = Math.round(this.dimensions.scaledCanvasWidth / this._devicePixelRatio);\n\n    // this.dimensions.scaledCanvasHeight = this.dimensions.canvasHeight * devicePixelRatio;\n    // this.dimensions.scaledCanvasWidth = this.dimensions.canvasWidth * devicePixelRatio;\n\n    // Get the _actual_ dimensions of an individual cell. This needs to be\n    // derived from the canvasWidth/Height calculated above which takes into\n    // account window.devicePixelRatio. CharMeasure.width/height by itself is\n    // insufficient when the page is not at 100% zoom level as CharMeasure is\n    // measured in CSS pixels, but the actual char size on the canvas can\n    // differ.\n    // this.dimensions.actualCellHeight = this.dimensions.canvasHeight / this._terminal.rows;\n    // this.dimensions.actualCellWidth = this.dimensions.canvasWidth / this._terminal.cols;\n\n    // This fixes 110% and 125%, not 150% or 175% though\n    this.dimensions.actualCellHeight = this.dimensions.scaledCellHeight / this._devicePixelRatio;\n    this.dimensions.actualCellWidth = this.dimensions.scaledCellWidth / this._devicePixelRatio;\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { throwIfFalsy } from './WebglUtils';\nimport { WebglCharAtlas } from './atlas/WebglCharAtlas';\nimport { IWebGL2RenderingContext, IWebGLVertexArrayObject, IRenderModel, IRasterizedGlyph } from './Types';\nimport { COMBINED_CHAR_BIT_MASK, RENDER_MODEL_INDICIES_PER_CELL, RENDER_MODEL_FG_OFFSET, RENDER_MODEL_BG_OFFSET } from './RenderModel';\nimport { fill } from 'common/TypedArrayUtils';\nimport { slice } from './TypedArray';\nimport { NULL_CELL_CODE, WHITESPACE_CELL_CODE, Attributes, FgFlags } from 'common/buffer/Constants';\nimport { Terminal, IBufferLine } from 'xterm';\nimport { IColorSet, IColor } from 'browser/Types';\nimport { IRenderDimensions } from 'browser/renderer/Types';\nimport { AttributeData } from 'common/buffer/AttributeData';\nimport { AFrame } from 'aframe';\n\ninterface IVertices {\n  attributes: Float32Array;\n  pos_attributes: Float32Array;\n  uv_attributes: Float32Array;\n  norm_attributes: Float32Array;\n  /**\n   * These buffers are the ones used to bind to WebGL, the reason there are\n   * multiple is to allow double buffering to work as you cannot modify the\n   * buffer while it's being used by the GPU. Having multiple lets us start\n   * working on the next frame.\n   */\n  attributesBuffers: Float32Array[];\n  selectionAttributes: Float32Array;\n  count: number;\n}\nconst INDICES_PER_CELL = 12;\nconst CELL_POSITION_INDICES = 2;\nconst ARRAY_SIZE = 24000;\n\nexport class AframeGlyphRenderer {\n  private _atlas: WebglCharAtlas | undefined;\n\n  public _atlasTexture: WebGLTexture;\n  private _activeBuffer: number = 0;\n\n  // from a-frame variables\n  private _aframebuffergeometry: any;\n  private _aframe_pos_att: any;\n  private _aframe_uv_att: any;\n  private _aframeshadermaterial: any;\n\n  private _vertices: IVertices = {\n    count: 0,\n    attributes: new Float32Array(0),\n\n    pos_attributes: new Float32Array(8),//(10000),\n    uv_attributes: new Float32Array(8),//(10000),\n    norm_attributes: new Float32Array(8),//(10000),\n\n    attributesBuffers: [\n      new Float32Array(8),\n      new Float32Array(8)\n    ],\n    selectionAttributes: new Float32Array(0)\n  };\n\n  private vertices: any;\n  private numVertices: any;\n  private positionNumComponents: any;\n  private uvNumComponents: any;\n  private positions: any;\n  private uvs: any;\n  private idx: any;\n  private posNdx: any;\n  private uvNdx: any;\n\n  constructor(\n    private _terminal: Terminal,\n    private _colors: IColorSet,\n    private _gl: IWebGL2RenderingContext,\n    private _dimensions: IRenderDimensions)\n  {\n    const gl = this._gl;\n\n    this.positions = new Float32Array(ARRAY_SIZE);\n    this.uvs = new Float32Array(ARRAY_SIZE);\n    this.idx = new Uint32Array(ARRAY_SIZE);\n\t  console.log('positions buffernum: ', this.positions.buffer.byteLength);\n\t  console.log('uvs buffernum: ', this.uvs.buffer.byteLength);\n\n    // Setup empty texture atlas\n    this._atlasTexture = throwIfFalsy(gl.createTexture());\n    gl.bindTexture(gl.TEXTURE_2D, this._atlasTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    this._aframebuffergeometry = new AFRAME.THREE.BufferGeometry();\n\n    this._aframe_pos_att = new AFRAME.THREE.BufferAttribute(this.positions, 3);\n    this._aframe_uv_att = new AFRAME.THREE.BufferAttribute(this.uvs, 2);\n    this._aframe_pos_att.usage = AFRAME.THREE.DynamicDrawUsage;\n    this._aframe_uv_att.usage = AFRAME.THREE.DynamicDrawUsage;\n\n    this._aframebuffergeometry.setAttribute( 'position', this._aframe_pos_att);\n    this._aframebuffergeometry.setAttribute( 'uv', this._aframe_uv_att);\n    this._aframebuffergeometry.dynamic = true;\n    this._aframebuffergeometry.attributes.position.needsUpdate = true;\n    this._aframebuffergeometry.attributes.uv.needsUpdate = true;\n\n    // for (let i in this.idx) { this.idx[i] = i; }\n\n    this._aframebuffergeometry.setIndex(new AFRAME.THREE.BufferAttribute(this.idx, 1));\n    this._aframebuffergeometry.index.needsUpdate = true;\n\n    // Set viewport\n    this.onResize();\n  }\n\n  public updateCell(x: number, y: number, code: number, bg: number, fg: number, chars: string): void\n  {\n    this._updateCell(this.positions, this.uvs, this.idx, x, y, code, bg, fg, chars);\n    this._aframebuffergeometry.attributes.position.needsUpdate = true;\n    this._aframebuffergeometry.attributes.uv.needsUpdate = true;\n    this._aframebuffergeometry.index.needsUpdate = true;\n  }\n\n  public debug(): void\n  {\n    // console.log(this._vertices.pos_attributes);\n  }\n\n  private _updateCell(pos_array_: Float32Array, uv_array_: Float32Array, idx_array_: Uint32Array,\n                      x_: number, y_: number, code_: number | undefined, bg_: number, fg_: number, chars?: string): void\n  {\n    const terminal = this._terminal;\n    const offset = (y_ * terminal.cols + x_) * INDICES_PER_CELL;\n    const uv_idx = (y_ * terminal.cols + x_) * 8;\n\n    // Exit early if this is a null/space character\n    if (code_ === NULL_CELL_CODE || code_ === WHITESPACE_CELL_CODE || code_ === undefined/* This is used for the right side of wide chars */)\n    {\n      // fill(array, 0, i, i + INDICES_PER_CELL - 1 - CELL_POSITION_INDICES);\n      fill(pos_array_, 0, offset, offset + INDICES_PER_CELL - 1 - CELL_POSITION_INDICES);\n      fill(uv_array_, 0, offset, offset + INDICES_PER_CELL - 1 - CELL_POSITION_INDICES);\n      return;\n    }\n\n    let rasterizedGlyph: IRasterizedGlyph; \n   if (!this._atlas) { return; }\n    if (chars && chars.length > 1)\n    { rasterizedGlyph = this._atlas.getRasterizedGlyphCombinedChar(chars, bg_, fg_); }\n    else\n    { rasterizedGlyph = this._atlas.getRasterizedGlyph(code_, bg_, fg_); }\n\n    // Fill empty if no glyph was found\n    if (!rasterizedGlyph)\n    {\n      // fill(array, 0, i, i + INDICES_PER_CELL - 1 - CELL_POSITION_INDICES);\n      fill(pos_array_, 0, offset, offset + INDICES_PER_CELL - 1 - CELL_POSITION_INDICES);\n      fill(uv_array_, 0, offset, offset + INDICES_PER_CELL - 1 - CELL_POSITION_INDICES);\n      return;\n    }\n\n    let fn_scale = this._dimensions.scaledCharHeight / this._dimensions.scaledCanvasHeight;\n    let v_spc = y_ / terminal.rows * this._dimensions.scaledCharHeight;\n    let h_spc = x_ * this._dimensions.scaledCanvasHeight / this._dimensions.scaledCanvasWidth / 2;\n\n    let top = fn_scale * (rasterizedGlyph.offset.y) - v_spc,\n    bottom  = fn_scale * (rasterizedGlyph.offset.y - rasterizedGlyph.size.y) - v_spc,\n    left    = fn_scale * (-rasterizedGlyph.offset.x) + h_spc,\n    right   = fn_scale * (-rasterizedGlyph.offset.x + rasterizedGlyph.size.x) + h_spc;\n\n    // console.log('offset = ', offset);\n\n    pos_array_.set(\n      [\n        left, top, 0,\n        right, top, 0,\n        left, bottom, 0,\n        right, bottom, 0,\n      ], offset);\n\n    let idx_o = (y_ * terminal.cols + x_) * 4;\n    idx_array_.set([idx_o + 2, idx_o + 1, idx_o,\n                    idx_o + 2, idx_o + 3, idx_o + 1],\n                   (y_ * terminal.cols + x_) * 6);\n\n    let uv_top = 1.0 - rasterizedGlyph.texturePositionClipSpace.y;\n    let uv_bottom = uv_top - rasterizedGlyph.sizeClipSpace.y;\n    let uv_left = rasterizedGlyph.texturePositionClipSpace.x;\n    let uv_right = uv_left + rasterizedGlyph.sizeClipSpace.x;\n\n    uv_array_.set(\n      [\n        uv_left, uv_top,\n        uv_right, uv_top,\n        uv_left, uv_bottom,\n        uv_right, uv_bottom,\n      ], uv_idx);\n  }\n\n  private get_pos(array_: Float32Array, offset_: number)\n  {\n    return \"(\" + array_[offset_].toFixed(2) + \", \" + array_[offset_ + 1].toFixed(2) + \", \" +  array_[offset_ + 2].toFixed(2) + \")\";\n  }\n\n  public updateAtlas(): void {\n /*\n    // Bind the texture atlas if it's changed\n    if (this._atlas.hasCanvasChanged) {\n      this._atlas.hasCanvasChanged = false;\n      // gl.uniform1i(this._textureLocation, 0);\n      gl.activeTexture(gl.TEXTURE0 + 0);\n      gl.bindTexture(gl.TEXTURE_2D, this._atlasTexture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._atlas.cacheCanvas);\n      gl.generateMipmap(gl.TEXTURE_2D);\n      }\n      */\n  }\n\n  private _getColorFromAnsiIndex(idx: number): IColor {\n    if (idx >= this._colors.ansi.length) {\n      throw new Error('No color found for idx ' + idx);\n    }\n    return this._colors.ansi[idx];\n  }\n\n  public onResize(): void {\n    const terminal = this._terminal;\n\n    // Update vertices\n    const newCount = terminal.cols * terminal.rows * INDICES_PER_CELL;\n    if (this._vertices.count !== newCount)\n    {\n      this._vertices.count = newCount;\n      this._vertices.attributes = new Float32Array(newCount);\n\n      console.log('new count = ', newCount);\n\n      // Aframe\n      this._vertices.pos_attributes = new Float32Array(newCount * 3);\n      this._vertices.uv_attributes = new Float32Array(newCount * 2);\n\n      for (let i = 0; i < this._vertices.attributesBuffers.length; i++)\n      {\n        this._vertices.attributesBuffers[i] = new Float32Array(newCount);\n      }\n\n      let i = 0;\n      for (let y = 0; y < terminal.rows; y++)\n      {\n        for (let x = 0; x < terminal.cols; x++)\n        {\n          this._vertices.attributes[i + 8] = x / terminal.cols; //XXX\n          this._vertices.attributes[i + 9] = y / terminal.rows;\n          i += INDICES_PER_CELL;\n        }\n      }\n    }\n  }\n\n  public render(renderModel: IRenderModel, isSelectionVisible: boolean): void {\n/*\n    if (!this._atlas) { return; }\n\n    const gl = this._gl;\n\n    // Alternate buffers each frame as the active buffer gets locked while it's in use by the GPU\n    this._activeBuffer = (this._activeBuffer + 1) % 2;\n    const activeBuffer = this._vertices.attributesBuffers[this._activeBuffer];\n\n    // Copy data for each cell of each line up to its line length (the last non-whitespace cell)\n    // from the attributes buffer into activeBuffer, which is the one that gets bound to the GPU.\n    // The reasons for this are as follows:\n    // - So the active buffer can be alternated so we don't get blocked on rendering finishing\n    // - To copy either the normal attributes buffer or the selection attributes buffer when there\n    //   is a selection\n    // - So we don't send vertices for all the line-ending whitespace to the GPU\n    let bufferLength = 0;\n    for (let y = 0; y < renderModel.lineLengths.length; y++)\n    {\n      const si = y * this._terminal.cols * INDICES_PER_CELL;\n      const sub = (isSelectionVisible ? this._vertices.selectionAttributes : this._vertices.attributes).subarray(si, si + renderModel.lineLengths[y] * INDICES_PER_CELL);\n      activeBuffer.set(sub, bufferLength);\n      bufferLength += sub.length;\n    }\n\n    // Bind the texture atlas if it's changed\n    if (this._atlas.hasCanvasChanged) {\n      this._atlas.hasCanvasChanged = false;\n      // gl.uniform1i(this._textureLocation, 0);\n      gl.activeTexture(gl.TEXTURE0 + 0);\n      gl.bindTexture(gl.TEXTURE_2D, this._atlasTexture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._atlas.cacheCanvas);\n      gl.generateMipmap(gl.TEXTURE_2D);\n    }\n\n    // Draw the viewport\n    gl.drawElementsInstanced(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0, bufferLength / INDICES_PER_CELL);\n*/\n  }\n\n  public setAtlas(atlas: WebglCharAtlas): void {\n    const gl = this._gl;\n    this._atlas = atlas;\n\n    gl.bindTexture(gl.TEXTURE_2D, this._atlasTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, atlas.cacheCanvas);\n    gl.generateMipmap(gl.TEXTURE_2D);\n  }\n\n  public setDimensions(dimensions: IRenderDimensions): void {\n     this._dimensions = dimensions;\n  }\n\n  public get getBufferGeometry(): any {\n    return this._aframebuffergeometry;\n  }\n\n  public get shaderMaterial(): any {\n    return this._aframeshadermaterial;\n  }\n\n  public get termIndex(): any {\n    return this.idx;\n  }\n\n  public beginFrame(): boolean {\n    return this._atlas ? this._atlas.beginFrame() : true;\n  }\n\n  public setColors(): void {\n  }\n\n  public updateSelection(model: IRenderModel): void {\n    const terminal = this._terminal;\n\n    this._vertices.selectionAttributes = slice(this._vertices.attributes, 0);\n\n    const bg = (this._colors.selectionOpaque.rgba >>> 8) | Attributes.CM_RGB;\n\n    if (model.selection.columnSelectMode) {\n      const startCol = model.selection.startCol;\n      const width = model.selection.endCol - startCol;\n      const height = model.selection.viewportCappedEndRow - model.selection.viewportCappedStartRow + 1;\n      for (let y = model.selection.viewportCappedStartRow; y < model.selection.viewportCappedStartRow + height; y++) {\n        this._updateSelectionRange(startCol, startCol + width, y, model, bg);\n      }\n    } else {\n      // Draw first row\n      const startCol = model.selection.viewportStartRow === model.selection.viewportCappedStartRow ? model.selection.startCol : 0;\n      const startRowEndCol = model.selection.viewportCappedStartRow === model.selection.viewportCappedEndRow ? model.selection.endCol : terminal.cols;\n      this._updateSelectionRange(startCol, startRowEndCol, model.selection.viewportCappedStartRow, model, bg);\n\n      // Draw middle rows\n      const middleRowsCount = Math.max(model.selection.viewportCappedEndRow - model.selection.viewportCappedStartRow - 1, 0);\n      for (let y = model.selection.viewportCappedStartRow + 1; y <= model.selection.viewportCappedStartRow + middleRowsCount; y++) {\n        this._updateSelectionRange(0, startRowEndCol, y, model, bg);\n      }\n\n      // Draw final row\n      if (model.selection.viewportCappedStartRow !== model.selection.viewportCappedEndRow) {\n        // Only draw viewportEndRow if it's not the same as viewportStartRow\n        const endCol = model.selection.viewportEndRow === model.selection.viewportCappedEndRow ? model.selection.endCol : terminal.cols;\n        this._updateSelectionRange(0, endCol, model.selection.viewportCappedEndRow, model, bg);\n      }\n    }\n  }\n\n  private _updateSelectionRange(startCol: number, endCol: number, y: number, model: IRenderModel, bg: number): void {\n    const terminal = this._terminal;\n    const row = y + terminal.buffer.active.viewportY;\n    let line: IBufferLine | undefined;\n    for (let x = startCol; x < endCol; x++) {\n      const offset = (y * this._terminal.cols + x) * RENDER_MODEL_INDICIES_PER_CELL;\n      const code = model.cells[offset];\n      let fg = model.cells[offset + RENDER_MODEL_FG_OFFSET];\n      if (fg & FgFlags.INVERSE) {\n        const workCell = new AttributeData();\n        workCell.fg = fg;\n        workCell.bg = model.cells[offset + RENDER_MODEL_BG_OFFSET];\n        // Get attributes from fg (excluding inverse) and resolve inverse by pullibng rgb colors\n        // from bg. This is needed since the inverse fg color should be based on the original bg\n        // color, not on the selection color\n        fg = (fg & ~(Attributes.CM_MASK | Attributes.RGB_MASK | FgFlags.INVERSE));\n        switch (workCell.getBgColorMode()) {\n          case Attributes.CM_P16:\n          case Attributes.CM_P256:\n            const c = this._getColorFromAnsiIndex(workCell.getBgColor()).rgba;\n            fg |= (c >> 8) & Attributes.RED_MASK | (c >> 8) & Attributes.GREEN_MASK | (c >> 8) & Attributes.BLUE_MASK;\n          case Attributes.CM_RGB:\n            const arr = AttributeData.toColorRGB(workCell.getBgColor());\n            fg |= arr[0] << Attributes.RED_SHIFT | arr[1] << Attributes.GREEN_SHIFT | arr[2] << Attributes.BLUE_SHIFT;\n          case Attributes.CM_DEFAULT:\n          default:\n            const c2 = this._colors.background.rgba;\n            fg |= (c2 >> 8) & Attributes.RED_MASK | (c2 >> 8) & Attributes.GREEN_MASK | (c2 >> 8) & Attributes.BLUE_MASK;\n        }\n        fg |= Attributes.CM_RGB;\n      }\n      if (code & COMBINED_CHAR_BIT_MASK) {\n        if (!line) {\n          line = terminal.buffer.active.getLine(row);\n        }\n        const chars = line!.getCell(x)!.getChars();\n        // Aframe\n//        this._updateCell(this._vertices.selectionAttributes, x, y, model.cells[offset], bg, fg, chars);\n      } else {\n        // Aframe\n//        this._updateCell(this._vertices.selectionAttributes, x, y, model.cells[offset], bg, fg);\n      }\n    }\n  }\n\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport type TypedArray = Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array;\n\nexport function slice<T extends TypedArray>(array: T, start?: number, end?: number): T {\n  // all modern engines that support .slice\n  if (array.slice) {\n    return array.slice(start, end) as T;\n  }\n  return sliceFallback(array, start, end);\n}\n\nexport function sliceFallback<T extends TypedArray>(array: T, start: number = 0, end: number = array.length): T {\n  if (start < 0) {\n    start = (array.length + start) % array.length;\n  }\n  if (end >= array.length) {\n    end = array.length;\n  } else {\n    end = (array.length + end) % array.length;\n  }\n  start = Math.min(start, end);\n\n  const result: T = new (array.constructor as any)(end - start);\n  for (let i = 0; i < end - start; ++i) {\n    result[i] = array[i + start];\n  }\n  return result;\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { Terminal } from 'xterm';\nimport { BaseRenderLayer } from './BaseRenderLayer';\nimport { INVERTED_DEFAULT_COLOR } from 'browser/renderer/atlas/Constants';\nimport { is256Color } from '../atlas/CharAtlasUtils';\nimport { ITerminal, IColorSet, ILinkifierEvent } from 'browser/Types';\nimport { IRenderDimensions } from 'browser/renderer/Types';\n\nexport class LinkRenderLayer extends BaseRenderLayer {\n  private _state: ILinkifierEvent | undefined;\n\n  constructor(container: HTMLElement, zIndex: number, colors: IColorSet, terminal: ITerminal) {\n    super(container, 'link', zIndex, true, colors);\n    terminal.linkifier.onShowLinkUnderline(e => this._onShowLinkUnderline(e));\n    terminal.linkifier.onHideLinkUnderline(e => this._onHideLinkUnderline(e));\n\n    terminal.linkifier2.onShowLinkUnderline(e => this._onShowLinkUnderline(e));\n    terminal.linkifier2.onHideLinkUnderline(e => this._onHideLinkUnderline(e));\n  }\n\n  public resize(terminal: Terminal, dim: IRenderDimensions): void {\n    super.resize(terminal, dim);\n    // Resizing the canvas discards the contents of the canvas so clear state\n    this._state = undefined;\n  }\n\n  public reset(terminal: Terminal): void {\n    this._clearCurrentLink();\n  }\n\n  private _clearCurrentLink(): void {\n    if (this._state) {\n      this._clearCells(this._state.x1, this._state.y1, this._state.cols - this._state.x1, 1);\n      const middleRowCount = this._state.y2 - this._state.y1 - 1;\n      if (middleRowCount > 0) {\n        this._clearCells(0, this._state.y1 + 1, this._state.cols, middleRowCount);\n      }\n      this._clearCells(0, this._state.y2, this._state.x2, 1);\n      this._state = undefined;\n    }\n  }\n\n  private _onShowLinkUnderline(e: ILinkifierEvent): void {\n    if (e.fg === INVERTED_DEFAULT_COLOR) {\n      this._ctx.fillStyle = this._colors.background.css;\n    } else if (e.fg !== undefined && is256Color(e.fg)) {\n      // 256 color support\n      this._ctx.fillStyle = this._colors.ansi[e.fg!].css;\n    } else {\n      this._ctx.fillStyle = this._colors.foreground.css;\n    }\n\n    if (e.y1 === e.y2) {\n      // Single line link\n      this._fillBottomLineAtCells(e.x1, e.y1, e.x2 - e.x1);\n    } else {\n      // Multi-line link\n      this._fillBottomLineAtCells(e.x1, e.y1, e.cols - e.x1);\n      for (let y = e.y1 + 1; y < e.y2; y++) {\n        this._fillBottomLineAtCells(0, y, e.cols);\n      }\n      this._fillBottomLineAtCells(0, e.y2, e.x2);\n    }\n    this._state = e;\n  }\n\n  private _onHideLinkUnderline(e: ILinkifierEvent): void {\n    this._clearCurrentLink();\n  }\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { ICharAtlasConfig } from './Types';\nimport { DIM_OPACITY } from 'browser/renderer/atlas/Constants';\nimport { IRasterizedGlyph, IBoundingBox, IRasterizedGlyphSet } from '../Types';\nimport { DEFAULT_COLOR, Attributes } from 'common/buffer/Constants';\nimport { throwIfFalsy } from '../WebglUtils';\nimport { IColor } from 'browser/Types';\nimport { IDisposable } from 'xterm';\nimport { AttributeData } from 'common/buffer/AttributeData';\nimport { channels, rgba } from 'browser/Color';\n\n// In practice we're probably never going to exhaust a texture this large. For debugging purposes,\n// however, it can be useful to set this to a really tiny value, to verify that LRU eviction works.\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 1024;\n\n/**\n * The amount of the texture to be filled before throwing it away and starting\n * again. Since the throw away and individual glyph draws don't cost too much,\n * this prevent juggling multiple textures in the GL context.\n */\nconst TEXTURE_CAPACITY = Math.floor(TEXTURE_HEIGHT * 0.8);\n\nconst TRANSPARENT_COLOR = {\n  css: 'rgba(0, 0, 0, 0)',\n  rgba: 0\n};\n\n/**\n * A shared object which is used to draw nothing for a particular cell.\n */\nconst NULL_RASTERIZED_GLYPH: IRasterizedGlyph = {\n  offset: { x: 0, y: 0 },\n  texturePosition: { x: 0, y: 0 },\n  texturePositionClipSpace: { x: 0, y: 0 },\n  size: { x: 0, y: 0 },\n  sizeClipSpace: { x: 0, y: 0 }\n};\n\nconst TMP_CANVAS_GLYPH_PADDING = 2;\n\nexport class WebglCharAtlas implements IDisposable {\n  private _didWarmUp: boolean = false;\n\n  private _cacheMap: { [code: number]: IRasterizedGlyphSet } = {};\n  private _cacheMapCombined: { [chars: string]: IRasterizedGlyphSet } = {};\n\n  // The texture that the atlas is drawn to\n  public cacheCanvas: any;//HTMLCanvasElement;\n  private _cacheCtx: CanvasRenderingContext2D;\n\n  private _tmpCanvas: any; //HTMLCanvasElement;\n  // A temporary context that glyphs are drawn to before being transfered to the atlas.\n  private _tmpCtx: CanvasRenderingContext2D;\n\n  // Since glyphs are expected to be around the same height, the packing\n  // strategy used it to fill a row with glyphs while keeping track of the\n  // tallest glyph in the row. Once the row is full a new row is started at\n  // (0,lastRow+lastRowTallestGlyph).\n  private _currentRowY: number = 0;\n  private _currentRowX: number = 0;\n  private _currentRowHeight: number = 0;\n\n  public hasCanvasChanged = false;\n\n  private _workBoundingBox: IBoundingBox = { top: 0, left: 0, bottom: 0, right: 0 };\n  private _workAttributeData: AttributeData = new AttributeData();\n\n  constructor(\n    document: Document,\n    private _config: ICharAtlasConfig\n  ) {\n    this.cacheCanvas = document.createElement('canvas');\n    this.cacheCanvas.width = TEXTURE_WIDTH;\n    this.cacheCanvas.height = TEXTURE_HEIGHT;\n    // The canvas needs alpha because we use clearColor to convert the background color to alpha.\n    // It might also contain some characters with transparent backgrounds if allowTransparency is\n    // set.\n    this._cacheCtx = throwIfFalsy(this.cacheCanvas.getContext('2d', {alpha: true}));\n\n    this._tmpCanvas = document.createElement('canvas');\n    this._tmpCanvas.width = this._config.scaledCharWidth * 2 + TMP_CANVAS_GLYPH_PADDING * 2;\n    this._tmpCanvas.height = this._config.scaledCharHeight + TMP_CANVAS_GLYPH_PADDING * 2;\n    this._tmpCtx = throwIfFalsy(this._tmpCanvas.getContext('2d', {alpha: this._config.allowTransparency}));\n  }\n\n  public dispose(): void {\n    if (this.cacheCanvas.parentElement) {\n      this.cacheCanvas.parentElement.removeChild(this.cacheCanvas);\n    }\n  }\n\n  public warmUp(): void {\n    if (!this._didWarmUp) {\n      this._doWarmUp();\n      this._didWarmUp = true;\n    }\n  }\n\n  private _doWarmUp(): void {\n    // Pre-fill with ASCII 33-126\n    for (let i = 33; i < 126; i++) {\n      const rasterizedGlyph = this._drawToCache(i, DEFAULT_COLOR, DEFAULT_COLOR);\n      this._cacheMap[i] = {\n        [DEFAULT_COLOR]: {\n          [DEFAULT_COLOR]: rasterizedGlyph\n        }\n      };\n    }\n  }\n\n  public beginFrame(): boolean {\n    if (this._currentRowY > TEXTURE_CAPACITY) {\n      this.clearTexture();\n      this.warmUp();\n      return true;\n    }\n    return false;\n  }\n\n  public clearTexture(): void {\n    if (this._currentRowX === 0 && this._currentRowY === 0) {\n      return;\n    }\n    this._cacheCtx.clearRect(0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT);\n    this._cacheMap = {};\n    this._cacheMapCombined = {};\n    this._currentRowHeight = 0;\n    this._currentRowX = 0;\n    this._currentRowY = 0;\n    this._didWarmUp = false;\n  }\n\n  public getRasterizedGlyphCombinedChar(chars: string, bg: number, fg: number): IRasterizedGlyph {\n    let rasterizedGlyphSet = this._cacheMapCombined[chars];\n    if (!rasterizedGlyphSet) {\n      rasterizedGlyphSet = {};\n      this._cacheMapCombined[chars] = rasterizedGlyphSet;\n    }\n    let rasterizedGlyph: IRasterizedGlyph | undefined;\n    const rasterizedGlyphSetBg = rasterizedGlyphSet[bg];\n    if (rasterizedGlyphSetBg) {\n      rasterizedGlyph = rasterizedGlyphSetBg[fg];\n    }\n    if (!rasterizedGlyph) {\n      rasterizedGlyph = this._drawToCache(chars, bg, fg);\n      if (!rasterizedGlyphSet[bg]) {\n        rasterizedGlyphSet[bg] = {};\n      }\n      rasterizedGlyphSet[bg]![fg] = rasterizedGlyph;\n    }\n    return rasterizedGlyph;\n  }\n\n  /**\n   * Gets the glyphs texture coords, drawing the texture if it's not already\n   */\n  public getRasterizedGlyph(code: number, bg: number, fg: number): IRasterizedGlyph {\n    let rasterizedGlyphSet = this._cacheMap[code];\n    if (!rasterizedGlyphSet) {\n      rasterizedGlyphSet = {};\n      this._cacheMap[code] = rasterizedGlyphSet;\n    }\n    let rasterizedGlyph: IRasterizedGlyph | undefined;\n    const rasterizedGlyphSetBg = rasterizedGlyphSet[bg];\n    if (rasterizedGlyphSetBg) {\n      rasterizedGlyph = rasterizedGlyphSetBg[fg];\n    }\n    if (!rasterizedGlyph) {\n      rasterizedGlyph = this._drawToCache(code, bg, fg);\n      if (!rasterizedGlyphSet[bg]) {\n        rasterizedGlyphSet[bg] = {};\n      }\n      rasterizedGlyphSet[bg]![fg] = rasterizedGlyph;\n    }\n    return rasterizedGlyph;\n  }\n\n  private _getColorFromAnsiIndex(idx: number): IColor {\n    if (idx >= this._config.colors.ansi.length) {\n      throw new Error('No color found for idx ' + idx);\n    }\n    return this._config.colors.ansi[idx];\n  }\n\n  private _getBackgroundColor(bgColorMode: number, bgColor: number, inverse: boolean): IColor {\n    if (this._config.allowTransparency) {\n      // The background color might have some transparency, so we need to render it as fully\n      // transparent in the atlas. Otherwise we'd end up drawing the transparent background twice\n      // around the anti-aliased edges of the glyph, and it would look too dark.\n      return TRANSPARENT_COLOR;\n    }\n\n    switch (bgColorMode) {\n      case Attributes.CM_P16:\n      case Attributes.CM_P256:\n        return this._getColorFromAnsiIndex(bgColor);\n      case Attributes.CM_RGB:\n        const arr = AttributeData.toColorRGB(bgColor);\n        // TODO: This object creation is slow\n        return {\n          rgba: bgColor << 8,\n          css: `#${toPaddedHex(arr[0])}${toPaddedHex(arr[1])}${toPaddedHex(arr[2])}`\n        };\n      case Attributes.CM_DEFAULT:\n      default:\n        if (inverse) {\n          return this._config.colors.foreground;\n        }\n        return this._config.colors.background;\n    }\n  }\n\n  private _getForegroundCss(bg: number, bgColorMode: number, bgColor: number, fg: number, fgColorMode: number, fgColor: number, inverse: boolean, bold: boolean): string {\n    const minimumContrastCss = this._getMinimumContrastCss(bg, bgColorMode, bgColor, fg, fgColorMode, fgColor, inverse, bold);\n    if (minimumContrastCss) {\n      return minimumContrastCss;\n    }\n\n    switch (fgColorMode) {\n      case Attributes.CM_P16:\n      case Attributes.CM_P256:\n        if (this._config.drawBoldTextInBrightColors && bold && fgColor < 8) {\n          fgColor += 8;\n        }\n        return this._getColorFromAnsiIndex(fgColor).css;\n      case Attributes.CM_RGB:\n        const arr = AttributeData.toColorRGB(fgColor);\n        return channels.toCss(arr[0], arr[1], arr[2]);\n      case Attributes.CM_DEFAULT:\n      default:\n        if (inverse) {\n          const bg = this._config.colors.background.css;\n          if (bg.length === 9) {\n            // Remove bg alpha channel if present\n            return bg.substr(0, 7);\n          }\n          return bg;\n        }\n        return this._config.colors.foreground.css;\n    }\n  }\n\n  private _resolveBackgroundRgba(bgColorMode: number, bgColor: number, inverse: boolean): number {\n    switch (bgColorMode) {\n      case Attributes.CM_P16:\n      case Attributes.CM_P256:\n        return this._getColorFromAnsiIndex(bgColor).rgba;\n      case Attributes.CM_RGB:\n        return bgColor << 8;\n      case Attributes.CM_DEFAULT:\n      default:\n        if (inverse) {\n          return this._config.colors.foreground.rgba;\n        }\n        return this._config.colors.background.rgba;\n    }\n  }\n\n  private _resolveForegroundRgba(fgColorMode: number, fgColor: number, inverse: boolean, bold: boolean): number {\n    switch (fgColorMode) {\n      case Attributes.CM_P16:\n      case Attributes.CM_P256:\n        if (this._config.drawBoldTextInBrightColors && bold && fgColor < 8) {\n          fgColor += 8;\n        }\n        return this._getColorFromAnsiIndex(fgColor).rgba;\n      case Attributes.CM_RGB:\n        return fgColor << 8;\n      case Attributes.CM_DEFAULT:\n      default:\n        if (inverse) {\n          return this._config.colors.background.rgba;\n        }\n        return this._config.colors.foreground.rgba;\n    }\n  }\n\n  private _getMinimumContrastCss(bg: number, bgColorMode: number, bgColor: number, fg: number, fgColorMode: number, fgColor: number, inverse: boolean, bold: boolean): string | undefined {\n    if (this._config.minimumContrastRatio === 1) {\n      return undefined;\n    }\n\n    // Try get from cache first\n    const adjustedColor = this._config.colors.contrastCache.getCss(bg, fg);\n    if (adjustedColor !== undefined) {\n      return adjustedColor || undefined;\n    }\n\n    const bgRgba = this._resolveBackgroundRgba(bgColorMode, bgColor, inverse);\n    const fgRgba = this._resolveForegroundRgba(fgColorMode, fgColor, inverse, bold);\n    const result = rgba.ensureContrastRatio(bgRgba, fgRgba, this._config.minimumContrastRatio);\n\n    if (!result) {\n      this._config.colors.contrastCache.setCss(bg, fg, null);\n      return undefined;\n    }\n\n    const css = channels.toCss(\n      (result >> 24) & 0xFF,\n      (result >> 16) & 0xFF,\n      (result >> 8) & 0xFF\n    );\n    this._config.colors.contrastCache.setCss(bg, fg, css);\n\n    return css;\n  }\n\n  private _drawToCache(code: number, bg: number, fg: number): IRasterizedGlyph;\n  private _drawToCache(chars: string, bg: number, fg: number): IRasterizedGlyph;\n  private _drawToCache(codeOrChars: number | string, bg: number, fg: number): IRasterizedGlyph {\n    const chars = typeof codeOrChars === 'number' ? String.fromCharCode(codeOrChars) : codeOrChars;\n\n    this.hasCanvasChanged = true;\n\n    this._tmpCtx.save();\n\n    this._workAttributeData.fg = fg;\n    this._workAttributeData.bg = bg;\n\n    const invisible = !!this._workAttributeData.isInvisible();\n    if (invisible) {\n      return NULL_RASTERIZED_GLYPH;\n    }\n\n    const bold = !!this._workAttributeData.isBold();\n    const inverse = !!this._workAttributeData.isInverse();\n    const dim = !!this._workAttributeData.isDim();\n    const italic = !!this._workAttributeData.isItalic();\n    let fgColor = this._workAttributeData.getFgColor();\n    let fgColorMode = this._workAttributeData.getFgColorMode();\n    let bgColor = this._workAttributeData.getBgColor();\n    let bgColorMode = this._workAttributeData.getBgColorMode();\n    if (inverse) {\n      const temp = fgColor;\n      fgColor = bgColor;\n      bgColor = temp;\n      const temp2 = fgColorMode;\n      fgColorMode = bgColorMode;\n      bgColorMode = temp2;\n    }\n\n    // draw the background\n    const backgroundColor = this._getBackgroundColor(bgColorMode, bgColor, inverse);\n    // Use a 'copy' composite operation to clear any existing glyph out of _tmpCtxWithAlpha, regardless of\n    // transparency in backgroundColor\n    this._tmpCtx.globalCompositeOperation = 'copy';\n    this._tmpCtx.fillStyle = backgroundColor.css;\n    this._tmpCtx.fillRect(0, 0, this._tmpCanvas.width, this._tmpCanvas.height);\n    this._tmpCtx.globalCompositeOperation = 'source-over';\n\n    // draw the foreground/glyph\n    const fontWeight = bold ? this._config.fontWeightBold : this._config.fontWeight;\n    const fontStyle = italic ? 'italic' : '';\n    this._tmpCtx.font =\n      `${fontStyle} ${fontWeight} ${this._config.fontSize * this._config.devicePixelRatio}px ${this._config.fontFamily}`;\n    this._tmpCtx.textBaseline = 'middle';\n\n    this._tmpCtx.fillStyle = this._getForegroundCss(bg, bgColorMode, bgColor, fg, fgColorMode, fgColor, inverse, bold);\n\n    // Apply alpha to dim the character\n    if (dim) {\n      this._tmpCtx.globalAlpha = DIM_OPACITY;\n    }\n\n    // Draw the character\n    this._tmpCtx.fillText(chars, TMP_CANVAS_GLYPH_PADDING, TMP_CANVAS_GLYPH_PADDING + this._config.scaledCharHeight / 2);\n    this._tmpCtx.restore();\n\n    // clear the background from the character to avoid issues with drawing over the previous\n    // character if it extends past it's bounds\n    const imageData = this._tmpCtx.getImageData(\n      0, 0, this._tmpCanvas.width, this._tmpCanvas.height\n    );\n\n    // TODO: Support transparency\n    // let isEmpty = false;\n    // if (!this._config.allowTransparency) {\n    //   isEmpty = clearColor(imageData, backgroundColor);\n    // }\n\n    // Clear out the background color and determine if the glyph is empty.\n    const isEmpty = clearColor(imageData, backgroundColor);\n\n    // Handle empty glyphs\n    if (isEmpty) {\n      return NULL_RASTERIZED_GLYPH;\n    }\n\n    const rasterizedGlyph = this._findGlyphBoundingBox(imageData, this._workBoundingBox);\n    const clippedImageData = this._clipImageData(imageData, this._workBoundingBox);\n\n    // Check if there is enough room in the current row and go to next if needed\n    if (this._currentRowX + this._config.scaledCharWidth > TEXTURE_WIDTH) {\n      this._currentRowX = 0;\n      this._currentRowY += this._currentRowHeight;\n      this._currentRowHeight = 0;\n    }\n\n    // Record texture position\n    rasterizedGlyph.texturePosition.x = this._currentRowX;\n    rasterizedGlyph.texturePosition.y = this._currentRowY;\n    rasterizedGlyph.texturePositionClipSpace.x = this._currentRowX / TEXTURE_WIDTH;\n    rasterizedGlyph.texturePositionClipSpace.y = this._currentRowY / TEXTURE_HEIGHT;\n\n    // Update atlas current row\n    this._currentRowHeight = Math.max(this._currentRowHeight, rasterizedGlyph.size.y);\n    this._currentRowX += rasterizedGlyph.size.x;\n\n    // putImageData doesn't do any blending, so it will overwrite any existing cache entry for us\n    this._cacheCtx.putImageData(clippedImageData, rasterizedGlyph.texturePosition.x, rasterizedGlyph.texturePosition.y);\n\n    return rasterizedGlyph;\n  }\n\n  /**\n   * Given an ImageData object, find the bounding box of the non-transparent\n   * portion of the texture and return an IRasterizedGlyph with these\n   * dimensions.\n   * @param imageData The image data to read.\n   * @param boundingBox An IBoundingBox to put the clipped bounding box values.\n   */\n  private _findGlyphBoundingBox(imageData: ImageData, boundingBox: IBoundingBox): IRasterizedGlyph {\n    boundingBox.top = 0;\n    let found = false;\n    for (let y = 0; y < this._tmpCanvas.height; y++) {\n      for (let x = 0; x < this._tmpCanvas.width; x++) {\n        const alphaOffset = y * this._tmpCanvas.width * 4 + x * 4 + 3;\n        if (imageData.data[alphaOffset] !== 0) {\n          boundingBox.top = y;\n          found = true;\n          break;\n        }\n      }\n      if (found) {\n        break;\n      }\n    }\n    boundingBox.left = 0;\n    found = false;\n    for (let x = 0; x < this._tmpCanvas.width; x++) {\n      for (let y = 0; y < this._tmpCanvas.height; y++) {\n        const alphaOffset = y * this._tmpCanvas.width * 4 + x * 4 + 3;\n        if (imageData.data[alphaOffset] !== 0) {\n          boundingBox.left = x;\n          found = true;\n          break;\n        }\n      }\n      if (found) {\n        break;\n      }\n    }\n    boundingBox.right = this._tmpCanvas.width;\n    found = false;\n    for (let x = this._tmpCanvas.width - 1; x >= 0; x--) {\n      for (let y = 0; y < this._tmpCanvas.height; y++) {\n        const alphaOffset = y * this._tmpCanvas.width * 4 + x * 4 + 3;\n        if (imageData.data[alphaOffset] !== 0) {\n          boundingBox.right = x;\n          found = true;\n          break;\n        }\n      }\n      if (found) {\n        break;\n      }\n    }\n    boundingBox.bottom = this._tmpCanvas.height;\n    found = false;\n    for (let y = this._tmpCanvas.height - 1; y >= 0; y--) {\n      for (let x = 0; x < this._tmpCanvas.width; x++) {\n        const alphaOffset = y * this._tmpCanvas.width * 4 + x * 4 + 3;\n        if (imageData.data[alphaOffset] !== 0) {\n          boundingBox.bottom = y;\n          found = true;\n          break;\n        }\n      }\n      if (found) {\n        break;\n      }\n    }\n    return {\n      texturePosition: { x: 0, y: 0 },\n      texturePositionClipSpace: { x: 0, y: 0 },\n      size: {\n        x: boundingBox.right - boundingBox.left + 1,\n        y: boundingBox.bottom - boundingBox.top + 1\n      },\n      sizeClipSpace: {\n        x: (boundingBox.right - boundingBox.left + 1) / TEXTURE_WIDTH,\n        y: (boundingBox.bottom - boundingBox.top + 1) / TEXTURE_HEIGHT\n      },\n      offset: {\n        x: -boundingBox.left + TMP_CANVAS_GLYPH_PADDING,\n        y: -boundingBox.top + TMP_CANVAS_GLYPH_PADDING\n      }\n    };\n  }\n\n  private _clipImageData(imageData: ImageData, boundingBox: IBoundingBox): ImageData {\n    const width = boundingBox.right - boundingBox.left + 1;\n    const height = boundingBox.bottom - boundingBox.top + 1;\n    const clippedData = new Uint8ClampedArray(width * height * 4);\n    for (let y = boundingBox.top; y <= boundingBox.bottom; y++) {\n      for (let x = boundingBox.left; x <= boundingBox.right; x++) {\n        const oldOffset = y * this._tmpCanvas.width * 4 + x * 4;\n        const newOffset = (y - boundingBox.top) * width * 4 + (x - boundingBox.left) * 4;\n        clippedData[newOffset] = imageData.data[oldOffset];\n        clippedData[newOffset + 1] = imageData.data[oldOffset + 1];\n        clippedData[newOffset + 2] = imageData.data[oldOffset + 2];\n        clippedData[newOffset + 3] = imageData.data[oldOffset + 3];\n      }\n    }\n    return new ImageData(clippedData, width, height);\n  }\n}\n\n/**\n * Makes a partiicular rgb color in an ImageData completely transparent.\n * @returns True if the result is \"empty\", meaning all pixels are fully transparent.\n */\nfunction clearColor(imageData: ImageData, color: IColor): boolean {\n  let isEmpty = true;\n  const r = color.rgba >>> 24;\n  const g = color.rgba >>> 16 & 0xFF;\n  const b = color.rgba >>> 8 & 0xFF;\n  for (let offset = 0; offset < imageData.data.length; offset += 4) {\n    if (imageData.data[offset] === r &&\n        imageData.data[offset + 1] === g &&\n        imageData.data[offset + 2] === b) {\n      imageData.data[offset + 3] = 0;\n    } else {\n      isEmpty = false;\n    }\n  }\n  return isEmpty;\n}\n\nfunction toPaddedHex(c: number): string {\n  const s = c.toString(16);\n  return s.length < 2 ? '0' + s : s;\n}\n","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IColor } from 'browser/Types';\n\n/**\n * Helper functions where the source type is \"channels\" (individual color channels as numbers).\n */\nexport namespace channels {\n  export function toCss(r: number, g: number, b: number, a?: number): string {\n    if (a !== undefined) {\n      return `#${toPaddedHex(r)}${toPaddedHex(g)}${toPaddedHex(b)}${toPaddedHex(a)}`;\n    }\n    return `#${toPaddedHex(r)}${toPaddedHex(g)}${toPaddedHex(b)}`;\n  }\n\n  export function toRgba(r: number, g: number, b: number, a: number = 0xFF): number {\n    // >>> 0 forces an unsigned int\n    return (r << 24 | g << 16 | b << 8 | a) >>> 0;\n  }\n}\n\n/**\n * Helper functions where the source type is `IColor`.\n */\nexport namespace color {\n  export function blend(bg: IColor, fg: IColor): IColor {\n    const a = (fg.rgba & 0xFF) / 255;\n    if (a === 1) {\n      return {\n        css: fg.css,\n        rgba: fg.rgba\n      };\n    }\n    const fgR = (fg.rgba >> 24) & 0xFF;\n    const fgG = (fg.rgba >> 16) & 0xFF;\n    const fgB = (fg.rgba >> 8) & 0xFF;\n    const bgR = (bg.rgba >> 24) & 0xFF;\n    const bgG = (bg.rgba >> 16) & 0xFF;\n    const bgB = (bg.rgba >> 8) & 0xFF;\n    const r = bgR + Math.round((fgR - bgR) * a);\n    const g = bgG + Math.round((fgG - bgG) * a);\n    const b = bgB + Math.round((fgB - bgB) * a);\n    const css = channels.toCss(r, g, b);\n    const rgba = channels.toRgba(r, g, b);\n    return { css, rgba };\n  }\n\n  export function isOpaque(color: IColor): boolean {\n    return (color.rgba & 0xFF) === 0xFF;\n  }\n\n  export function ensureContrastRatio(bg: IColor, fg: IColor, ratio: number): IColor | undefined {\n    const result = rgba.ensureContrastRatio(bg.rgba, fg.rgba, ratio);\n    if (!result) {\n      return undefined;\n    }\n    return rgba.toColor(\n      (result >> 24 & 0xFF),\n      (result >> 16 & 0xFF),\n      (result >> 8  & 0xFF)\n    );\n  }\n\n  export function opaque(color: IColor): IColor {\n    const rgbaColor = (color.rgba | 0xFF) >>> 0;\n    const [r, g, b] = rgba.toChannels(rgbaColor);\n    return {\n      css: channels.toCss(r, g, b),\n      rgba: rgbaColor\n    };\n  }\n\n  export function opacity(color: IColor, opacity: number): IColor {\n    const a = Math.round(opacity * 0xFF);\n    const [r, g, b] = rgba.toChannels(color.rgba);\n    return {\n      css: channels.toCss(r, g, b, a),\n      rgba: channels.toRgba(r, g, b, a)\n    };\n  }\n}\n\n/**\n * Helper functions where the source type is \"css\" (string: '#rgb', '#rgba', '#rrggbb', '#rrggbbaa').\n */\nexport namespace css {\n  export function toColor(css: string): IColor {\n    switch (css.length) {\n      case 7: // #rrggbb\n        return {\n          css,\n          rgba: (parseInt(css.slice(1), 16) << 8 | 0xFF) >>> 0\n        };\n      case 9: // #rrggbbaa\n        return {\n          css,\n          rgba: parseInt(css.slice(1), 16) >>> 0\n        };\n    }\n    throw new Error('css.toColor: Unsupported css format');\n  }\n}\n\n/**\n * Helper functions where the source type is \"rgb\" (number: 0xrrggbb).\n */\nexport namespace rgb {\n  /**\n   * Gets the relative luminance of an RGB color, this is useful in determining the contrast ratio\n   * between two colors.\n   * @param rgb The color to use.\n   * @see https://www.w3.org/TR/WCAG20/#relativeluminancedef\n   */\n  export function relativeLuminance(rgb: number): number {\n    return relativeLuminance2(\n      (rgb >> 16) & 0xFF,\n      (rgb >> 8 ) & 0xFF,\n      (rgb      ) & 0xFF);\n  }\n\n  /**\n   * Gets the relative luminance of an RGB color, this is useful in determining the contrast ratio\n   * between two colors.\n   * @param r The red channel (0x00 to 0xFF).\n   * @param g The green channel (0x00 to 0xFF).\n   * @param b The blue channel (0x00 to 0xFF).\n   * @see https://www.w3.org/TR/WCAG20/#relativeluminancedef\n   */\n  export function relativeLuminance2(r: number, g: number, b: number): number {\n    const rs = r / 255;\n    const gs = g / 255;\n    const bs = b / 255;\n    const rr = rs <= 0.03928 ? rs / 12.92 : Math.pow((rs + 0.055) / 1.055, 2.4);\n    const rg = gs <= 0.03928 ? gs / 12.92 : Math.pow((gs + 0.055) / 1.055, 2.4);\n    const rb = bs <= 0.03928 ? bs / 12.92 : Math.pow((bs + 0.055) / 1.055, 2.4);\n    return rr * 0.2126 + rg * 0.7152 + rb * 0.0722;\n  }\n}\n\n/**\n * Helper functions where the source type is \"rgba\" (number: 0xrrggbbaa).\n */\nexport namespace rgba {\n  export function ensureContrastRatio(bgRgba: number, fgRgba: number, ratio: number): number | undefined {\n    const bgL = rgb.relativeLuminance(bgRgba >> 8);\n    const fgL = rgb.relativeLuminance(fgRgba >> 8);\n    const cr = contrastRatio(bgL, fgL);\n    if (cr < ratio) {\n      if (fgL < bgL) {\n        return reduceLuminance(bgRgba, fgRgba, ratio);\n      }\n      return increaseLuminance(bgRgba, fgRgba, ratio);\n    }\n    return undefined;\n  }\n\n  export function reduceLuminance(bgRgba: number, fgRgba: number, ratio: number): number {\n    // This is a naive but fast approach to reducing luminance as converting to\n    // HSL and back is expensive\n    const bgR = (bgRgba >> 24) & 0xFF;\n    const bgG = (bgRgba >> 16) & 0xFF;\n    const bgB = (bgRgba >>  8) & 0xFF;\n    let fgR = (fgRgba >> 24) & 0xFF;\n    let fgG = (fgRgba >> 16) & 0xFF;\n    let fgB = (fgRgba >>  8) & 0xFF;\n    let cr = contrastRatio(rgb.relativeLuminance2(fgR, fgB, fgG), rgb.relativeLuminance2(bgR, bgG, bgB));\n    while (cr < ratio && (fgR > 0 || fgG > 0 || fgB > 0)) {\n      // Reduce by 10% until the ratio is hit\n      fgR -= Math.max(0, Math.ceil(fgR * 0.1));\n      fgG -= Math.max(0, Math.ceil(fgG * 0.1));\n      fgB -= Math.max(0, Math.ceil(fgB * 0.1));\n      cr = contrastRatio(rgb.relativeLuminance2(fgR, fgB, fgG), rgb.relativeLuminance2(bgR, bgG, bgB));\n    }\n    return (fgR << 24 | fgG << 16 | fgB << 8 | 0xFF) >>> 0;\n  }\n\n  export function increaseLuminance(bgRgba: number, fgRgba: number, ratio: number): number {\n    // This is a naive but fast approach to increasing luminance as converting to\n    // HSL and back is expensive\n    const bgR = (bgRgba >> 24) & 0xFF;\n    const bgG = (bgRgba >> 16) & 0xFF;\n    const bgB = (bgRgba >>  8) & 0xFF;\n    let fgR = (fgRgba >> 24) & 0xFF;\n    let fgG = (fgRgba >> 16) & 0xFF;\n    let fgB = (fgRgba >>  8) & 0xFF;\n    let cr = contrastRatio(rgb.relativeLuminance2(fgR, fgB, fgG), rgb.relativeLuminance2(bgR, bgG, bgB));\n    while (cr < ratio && (fgR < 0xFF || fgG < 0xFF || fgB < 0xFF)) {\n      // Increase by 10% until the ratio is hit\n      fgR = Math.min(0xFF, fgR + Math.ceil((255 - fgR) * 0.1));\n      fgG = Math.min(0xFF, fgG + Math.ceil((255 - fgG) * 0.1));\n      fgB = Math.min(0xFF, fgB + Math.ceil((255 - fgB) * 0.1));\n      cr = contrastRatio(rgb.relativeLuminance2(fgR, fgB, fgG), rgb.relativeLuminance2(bgR, bgG, bgB));\n    }\n    return (fgR << 24 | fgG << 16 | fgB << 8 | 0xFF) >>> 0;\n  }\n\n  export function toChannels(value: number): [number, number, number, number] {\n    return [(value >> 24) & 0xFF, (value >> 16) & 0xFF, (value >> 8) & 0xFF, value & 0xFF];\n  }\n\n  export function toColor(r: number, g: number, b: number): IColor {\n    return {\n      css: channels.toCss(r, g, b),\n      rgba: channels.toRgba(r, g, b)\n    };\n  }\n}\n\nexport function toPaddedHex(c: number): string {\n  const s = c.toString(16);\n  return s.length < 2 ? '0' + s : s;\n}\n\n/**\n * Gets the contrast ratio between two relative luminance values.\n * @param l1 The first relative luminance.\n * @param l2 The first relative luminance.\n * @see https://www.w3.org/TR/WCAG20/#contrast-ratiodef\n */\nexport function contrastRatio(l1: number, l2: number): number {\n  if (l1 < l2) {\n    return (l2 + 0.05) / (l1 + 0.05);\n  }\n  return (l1 + 0.05) / (l2 + 0.05);\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { Terminal } from 'xterm';\nimport { BaseRenderLayer } from './BaseRenderLayer';\nimport { ICellData } from 'common/Types';\nimport { CellData } from 'common/buffer/CellData';\nimport { IColorSet } from 'browser/Types';\nimport { IRenderDimensions, IRequestRedrawEvent } from 'browser/renderer/Types';\nimport { IEventEmitter } from 'common/EventEmitter';\n\ninterface ICursorState {\n  x: number;\n  y: number;\n  isFocused: boolean;\n  style: string;\n  width: number;\n}\n\n/**\n * The time between cursor blinks.\n */\nconst BLINK_INTERVAL = 600;\n\nexport class CursorRenderLayer extends BaseRenderLayer {\n  private _state: ICursorState;\n  private _cursorRenderers: {[key: string]: (terminal: Terminal, x: number, y: number, cell: ICellData) => void};\n  private _cursorBlinkStateManager: CursorBlinkStateManager | undefined;\n  private _cell: ICellData = new CellData();\n\n  constructor(\n    container: HTMLElement,\n    zIndex: number,\n    colors: IColorSet,\n    private _onRequestRefreshRowsEvent: IEventEmitter<IRequestRedrawEvent>\n  ) {\n    super(container, 'cursor', zIndex, true, colors);\n    this._state = {\n      x: 0,\n      y: 0,\n      isFocused: false,\n      style: '',\n      width: 0\n    };\n    this._cursorRenderers = {\n      'bar': this._renderBarCursor.bind(this),\n      'block': this._renderBlockCursor.bind(this),\n      'underline': this._renderUnderlineCursor.bind(this)\n    };\n    // TODO: Consider initial options? Maybe onOptionsChanged should be called at the end of open?\n  }\n\n  public resize(terminal: Terminal, dim: IRenderDimensions): void {\n    super.resize(terminal, dim);\n    // Resizing the canvas discards the contents of the canvas so clear state\n    this._state = {\n      x: 0,\n      y: 0,\n      isFocused: false,\n      style: '',\n      width: 0\n    };\n  }\n\n  public reset(terminal: Terminal): void {\n    this._clearCursor();\n    if (this._cursorBlinkStateManager) {\n      this._cursorBlinkStateManager.dispose();\n      this.onOptionsChanged(terminal);\n    }\n  }\n\n  public onBlur(terminal: Terminal): void {\n    if (this._cursorBlinkStateManager) {\n      this._cursorBlinkStateManager.pause();\n    }\n    this._onRequestRefreshRowsEvent.fire({ start: terminal.buffer.active.cursorY, end: terminal.buffer.active.cursorY });\n  }\n\n  public onFocus(terminal: Terminal): void {\n    if (this._cursorBlinkStateManager) {\n      this._cursorBlinkStateManager.resume(terminal);\n    } else {\n      this._onRequestRefreshRowsEvent.fire({ start: terminal.buffer.active.cursorY, end: terminal.buffer.active.cursorY });\n    }\n  }\n\n  public onOptionsChanged(terminal: Terminal): void {\n    if (terminal.getOption('cursorBlink')) {\n      if (!this._cursorBlinkStateManager) {\n        this._cursorBlinkStateManager = new CursorBlinkStateManager(terminal, () => {\n          this._render(terminal, true);\n        });\n      }\n    } else {\n      this._cursorBlinkStateManager?.dispose();\n      this._cursorBlinkStateManager = undefined;\n    }\n    // Request a refresh from the terminal as management of rendering is being\n    // moved back to the terminal\n    this._onRequestRefreshRowsEvent.fire({ start: terminal.buffer.active.cursorY, end: terminal.buffer.active.cursorY });\n  }\n\n  public onCursorMove(terminal: Terminal): void {\n    if (this._cursorBlinkStateManager) {\n      this._cursorBlinkStateManager.restartBlinkAnimation(terminal);\n    }\n  }\n\n  public onGridChanged(terminal: Terminal, startRow: number, endRow: number): void {\n    if (!this._cursorBlinkStateManager || this._cursorBlinkStateManager.isPaused) {\n      this._render(terminal, false);\n    } else {\n      this._cursorBlinkStateManager.restartBlinkAnimation(terminal);\n    }\n  }\n\n  private _render(terminal: Terminal, triggeredByAnimationFrame: boolean): void {\n    // Don't draw the cursor if it's hidden\n    // TODO: Need to expose API for this\n    if (!(terminal as any)._core._coreService.isCursorInitialized || (terminal as any)._core._coreService.isCursorHidden) {\n      this._clearCursor();\n      return;\n    }\n\n    const cursorY = terminal.buffer.active.baseY + terminal.buffer.active.cursorY;\n    const viewportRelativeCursorY = cursorY - terminal.buffer.active.viewportY;\n\n    // in case cursor.x == cols adjust visual cursor to cols - 1\n    const cursorX = Math.min(terminal.buffer.active.cursorX, terminal.cols - 1);\n\n    // Don't draw the cursor if it's off-screen\n    if (viewportRelativeCursorY < 0 || viewportRelativeCursorY >= terminal.rows) {\n      this._clearCursor();\n      return;\n    }\n\n    // TODO: Need fast buffer API for loading cell\n    (terminal as any)._core.buffer.lines.get(cursorY).loadCell(cursorX, this._cell);\n    if (this._cell.content === undefined) {\n      return;\n    }\n\n    if (!isTerminalFocused(terminal)) {\n      this._clearCursor();\n      this._ctx.save();\n      this._ctx.fillStyle = this._colors.cursor.css;\n      const cursorStyle = terminal.getOption('cursorStyle');\n      if (cursorStyle && cursorStyle !== 'block') {\n        this._cursorRenderers[cursorStyle](terminal, cursorX, viewportRelativeCursorY, this._cell);\n      } else {\n        this._renderBlurCursor(terminal, cursorX, viewportRelativeCursorY, this._cell);\n      }\n      this._ctx.restore();\n      this._state.x = cursorX;\n      this._state.y = viewportRelativeCursorY;\n      this._state.isFocused = false;\n      this._state.style = cursorStyle;\n      this._state.width = this._cell.getWidth();\n      return;\n    }\n\n    // Don't draw the cursor if it's blinking\n    if (this._cursorBlinkStateManager && !this._cursorBlinkStateManager.isCursorVisible) {\n      this._clearCursor();\n      return;\n    }\n\n    if (this._state) {\n      // The cursor is already in the correct spot, don't redraw\n      if (this._state.x === cursorX &&\n          this._state.y === viewportRelativeCursorY &&\n          this._state.isFocused === isTerminalFocused(terminal) &&\n          this._state.style === terminal.getOption('cursorStyle') &&\n          this._state.width === this._cell.getWidth()) {\n        return;\n      }\n      this._clearCursor();\n    }\n\n    this._ctx.save();\n    this._cursorRenderers[terminal.getOption('cursorStyle') || 'block'](terminal, cursorX, viewportRelativeCursorY, this._cell);\n    this._ctx.restore();\n\n    this._state.x = cursorX;\n    this._state.y = viewportRelativeCursorY;\n    this._state.isFocused = false;\n    this._state.style = terminal.getOption('cursorStyle');\n    this._state.width = this._cell.getWidth();\n  }\n\n  private _clearCursor(): void {\n    if (this._state) {\n      this._clearCells(this._state.x, this._state.y, this._state.width, 1);\n      this._state = {\n        x: 0,\n        y: 0,\n        isFocused: false,\n        style: '',\n        width: 0\n      };\n    }\n  }\n\n  private _renderBarCursor(terminal: Terminal, x: number, y: number, cell: ICellData): void {\n    this._ctx.save();\n    this._ctx.fillStyle = this._colors.cursor.css;\n    this._fillLeftLineAtCell(x, y, terminal.getOption('cursorWidth'));\n    this._ctx.restore();\n  }\n\n  private _renderBlockCursor(terminal: Terminal, x: number, y: number, cell: ICellData): void {\n    this._ctx.save();\n    this._ctx.fillStyle = this._colors.cursor.css;\n    this._fillCells(x, y, cell.getWidth(), 1);\n    this._ctx.fillStyle = this._colors.cursorAccent.css;\n    this._fillCharTrueColor(terminal, cell, x, y);\n    this._ctx.restore();\n  }\n\n  private _renderUnderlineCursor(terminal: Terminal, x: number, y: number, cell: ICellData): void {\n    this._ctx.save();\n    this._ctx.fillStyle = this._colors.cursor.css;\n    this._fillBottomLineAtCells(x, y);\n    this._ctx.restore();\n  }\n\n  private _renderBlurCursor(terminal: Terminal, x: number, y: number, cell: ICellData): void {\n    this._ctx.save();\n    this._ctx.strokeStyle = this._colors.cursor.css;\n    this._strokeRectAtCell(x, y, cell.getWidth(), 1);\n    this._ctx.restore();\n  }\n}\n\nclass CursorBlinkStateManager {\n  public isCursorVisible: boolean;\n\n  private _animationFrame: number | undefined;\n  private _blinkStartTimeout: number | undefined;\n  private _blinkInterval: number | undefined;\n\n  /**\n   * The time at which the animation frame was restarted, this is used on the\n   * next render to restart the timers so they don't need to restart the timers\n   * multiple times over a short period.\n   */\n  private _animationTimeRestarted: number | undefined;\n\n  constructor(\n    terminal: Terminal,\n    private _renderCallback: () => void\n  ) {\n    this.isCursorVisible = true;\n    if (isTerminalFocused(terminal)) {\n      this._restartInterval();\n    }\n  }\n\n  public get isPaused(): boolean { return !(this._blinkStartTimeout || this._blinkInterval); }\n\n  public dispose(): void {\n    if (this._blinkInterval) {\n      window.clearInterval(this._blinkInterval);\n      this._blinkInterval = undefined;\n    }\n    if (this._blinkStartTimeout) {\n      window.clearTimeout(this._blinkStartTimeout);\n      this._blinkStartTimeout = undefined;\n    }\n    if (this._animationFrame) {\n      window.cancelAnimationFrame(this._animationFrame);\n      this._animationFrame = undefined;\n    }\n  }\n\n  public restartBlinkAnimation(terminal: Terminal): void {\n    if (this.isPaused) {\n      return;\n    }\n    // Save a timestamp so that the restart can be done on the next interval\n    this._animationTimeRestarted = Date.now();\n    // Force a cursor render to ensure it's visible and in the correct position\n    this.isCursorVisible = true;\n    if (!this._animationFrame) {\n      this._animationFrame = window.requestAnimationFrame(() => {\n        this._renderCallback();\n        this._animationFrame = undefined;\n      });\n    }\n  }\n\n  private _restartInterval(timeToStart: number = BLINK_INTERVAL): void {\n    // Clear any existing interval\n    if (this._blinkInterval) {\n      window.clearInterval(this._blinkInterval);\n    }\n\n    // Setup the initial timeout which will hide the cursor, this is done before\n    // the regular interval is setup in order to support restarting the blink\n    // animation in a lightweight way (without thrashing clearInterval and\n    // setInterval).\n    this._blinkStartTimeout = window.setTimeout(() => {\n      // Check if another animation restart was requested while this was being\n      // started\n      if (this._animationTimeRestarted) {\n        const time = BLINK_INTERVAL - (Date.now() - this._animationTimeRestarted);\n        this._animationTimeRestarted = undefined;\n        if (time > 0) {\n          this._restartInterval(time);\n          return;\n        }\n      }\n\n      // Hide the cursor\n      this.isCursorVisible = false;\n      this._animationFrame = window.requestAnimationFrame(() => {\n        this._renderCallback();\n        this._animationFrame = undefined;\n      });\n\n      // Setup the blink interval\n      this._blinkInterval = window.setInterval(() => {\n        // Adjust the animation time if it was restarted\n        if (this._animationTimeRestarted) {\n          // calc time diff\n          // Make restart interval do a setTimeout initially?\n          const time = BLINK_INTERVAL - (Date.now() - this._animationTimeRestarted);\n          this._animationTimeRestarted = undefined;\n          this._restartInterval(time);\n          return;\n        }\n\n        // Invert visibility and render\n        this.isCursorVisible = !this.isCursorVisible;\n        this._animationFrame = window.requestAnimationFrame(() => {\n          this._renderCallback();\n          this._animationFrame = undefined;\n        });\n      }, BLINK_INTERVAL);\n    }, timeToStart);\n  }\n\n  public pause(): void {\n    this.isCursorVisible = true;\n    if (this._blinkInterval) {\n      window.clearInterval(this._blinkInterval);\n      this._blinkInterval = undefined;\n    }\n    if (this._blinkStartTimeout) {\n      window.clearTimeout(this._blinkStartTimeout);\n      this._blinkStartTimeout = undefined;\n    }\n    if (this._animationFrame) {\n      window.cancelAnimationFrame(this._animationFrame);\n      this._animationFrame = undefined;\n    }\n  }\n\n  public resume(terminal: Terminal): void {\n    // Clear out any existing timers just in case\n    this.pause();\n\n    this._animationTimeRestarted = undefined;\n    this._restartInterval();\n    this.restartBlinkAnimation(terminal);\n  }\n}\n\nfunction isTerminalFocused(terminal: Terminal): boolean {\n  return document.activeElement === terminal.textarea && document.hasFocus();\n}\n","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\n/**\n * Polyfill - Convert UTF32 codepoint into JS string.\n * Note: The built-in String.fromCodePoint happens to be much slower\n *       due to additional sanity checks. We can avoid them since\n *       we always operate on legal UTF32 (granted by the input decoders)\n *       and use this faster version instead.\n */\nexport function stringFromCodePoint(codePoint: number): string {\n  if (codePoint > 0xFFFF) {\n    codePoint -= 0x10000;\n    return String.fromCharCode((codePoint >> 10) + 0xD800) + String.fromCharCode((codePoint % 0x400) + 0xDC00);\n  }\n  return String.fromCharCode(codePoint);\n}\n\n/**\n * Convert UTF32 char codes into JS string.\n * Basically the same as `stringFromCodePoint` but for multiple codepoints\n * in a loop (which is a lot faster).\n */\nexport function utf32ToString(data: Uint32Array, start: number = 0, end: number = data.length): string {\n  let result = '';\n  for (let i = start; i < end; ++i) {\n    let codepoint = data[i];\n    if (codepoint > 0xFFFF) {\n      // JS strings are encoded as UTF16, thus a non BMP codepoint gets converted into a surrogate pair\n      // conversion rules:\n      //  - subtract 0x10000 from code point, leaving a 20 bit number\n      //  - add high 10 bits to 0xD800  --> first surrogate\n      //  - add low 10 bits to 0xDC00   --> second surrogate\n      codepoint -= 0x10000;\n      result += String.fromCharCode((codepoint >> 10) + 0xD800) + String.fromCharCode((codepoint % 0x400) + 0xDC00);\n    } else {\n      result += String.fromCharCode(codepoint);\n    }\n  }\n  return result;\n}\n\n/**\n * StringToUtf32 - decodes UTF16 sequences into UTF32 codepoints.\n * To keep the decoder in line with JS strings it handles single surrogates as UCS2.\n */\nexport class StringToUtf32 {\n  private _interim: number = 0;\n\n  /**\n   * Clears interim and resets decoder to clean state.\n   */\n  public clear(): void {\n    this._interim = 0;\n  }\n\n  /**\n   * Decode JS string to UTF32 codepoints.\n   * The methods assumes stream input and will store partly transmitted\n   * surrogate pairs and decode them with the next data chunk.\n   * Note: The method does no bound checks for target, therefore make sure\n   * the provided input data does not exceed the size of `target`.\n   * Returns the number of written codepoints in `target`.\n   */\n  public decode(input: string, target: Uint32Array): number {\n    const length = input.length;\n\n    if (!length) {\n      return 0;\n    }\n\n    let size = 0;\n    let startPos = 0;\n\n    // handle leftover surrogate high\n    if (this._interim) {\n      const second = input.charCodeAt(startPos++);\n      if (0xDC00 <= second && second <= 0xDFFF) {\n        target[size++] = (this._interim - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n      } else {\n        // illegal codepoint (USC2 handling)\n        target[size++] = this._interim;\n        target[size++] = second;\n      }\n      this._interim = 0;\n    }\n\n    for (let i = startPos; i < length; ++i) {\n      const code = input.charCodeAt(i);\n      // surrogate pair first\n      if (0xD800 <= code && code <= 0xDBFF) {\n        if (++i >= length) {\n          this._interim = code;\n          return size;\n        }\n        const second = input.charCodeAt(i);\n        if (0xDC00 <= second && second <= 0xDFFF) {\n          target[size++] = (code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n        } else {\n          // illegal codepoint (USC2 handling)\n          target[size++] = code;\n          target[size++] = second;\n        }\n        continue;\n      }\n      target[size++] = code;\n    }\n    return size;\n  }\n}\n\n/**\n * Utf8Decoder - decodes UTF8 byte sequences into UTF32 codepoints.\n */\nexport class Utf8ToUtf32 {\n  public interim: Uint8Array = new Uint8Array(3);\n\n  /**\n   * Clears interim bytes and resets decoder to clean state.\n   */\n  public clear(): void {\n    this.interim.fill(0);\n  }\n\n  /**\n   * Decodes UTF8 byte sequences in `input` to UTF32 codepoints in `target`.\n   * The methods assumes stream input and will store partly transmitted bytes\n   * and decode them with the next data chunk.\n   * Note: The method does no bound checks for target, therefore make sure\n   * the provided data chunk does not exceed the size of `target`.\n   * Returns the number of written codepoints in `target`.\n   */\n  public decode(input: Uint8Array, target: Uint32Array): number {\n    const length = input.length;\n\n    if (!length) {\n      return 0;\n    }\n\n    let size = 0;\n    let byte1: number;\n    let byte2: number;\n    let byte3: number;\n    let byte4: number;\n    let codepoint = 0;\n    let startPos = 0;\n\n    // handle leftover bytes\n    if (this.interim[0]) {\n      let discardInterim = false;\n      let cp = this.interim[0];\n      cp &= ((((cp & 0xE0) === 0xC0)) ? 0x1F : (((cp & 0xF0) === 0xE0)) ? 0x0F : 0x07);\n      let pos = 0;\n      let tmp: number;\n      while ((tmp = this.interim[++pos] & 0x3F) && pos < 4) {\n        cp <<= 6;\n        cp |= tmp;\n      }\n      // missing bytes - read ahead from input\n      const type = (((this.interim[0] & 0xE0) === 0xC0)) ? 2 : (((this.interim[0] & 0xF0) === 0xE0)) ? 3 : 4;\n      const missing = type - pos;\n      while (startPos < missing) {\n        if (startPos >= length) {\n          return 0;\n        }\n        tmp = input[startPos++];\n        if ((tmp & 0xC0) !== 0x80) {\n          // wrong continuation, discard interim bytes completely\n          startPos--;\n          discardInterim = true;\n          break;\n        } else {\n          // need to save so we can continue short inputs in next call\n          this.interim[pos++] = tmp;\n          cp <<= 6;\n          cp |= tmp & 0x3F;\n        }\n      }\n      if (!discardInterim) {\n        // final test is type dependent\n        if (type === 2) {\n          if (cp < 0x80) {\n            // wrong starter byte\n            startPos--;\n          } else {\n            target[size++] = cp;\n          }\n        } else if (type === 3) {\n          if (cp < 0x0800 || (cp >= 0xD800 && cp <= 0xDFFF)) {\n            // illegal codepoint\n          } else {\n            target[size++] = cp;\n          }\n        } else {\n          if (cp < 0x010000 || cp > 0x10FFFF) {\n            // illegal codepoint\n          } else {\n            target[size++] = cp;\n          }\n        }\n      }\n      this.interim.fill(0);\n    }\n\n    // loop through input\n    const fourStop = length - 4;\n    let i = startPos;\n    while (i < length) {\n      /**\n       * ASCII shortcut with loop unrolled to 4 consecutive ASCII chars.\n       * This is a compromise between speed gain for ASCII\n       * and penalty for non ASCII:\n       * For best ASCII performance the char should be stored directly into target,\n       * but even a single attempt to write to target and compare afterwards\n       * penalizes non ASCII really bad (-50%), thus we load the char into byteX first,\n       * which reduces ASCII performance by ~15%.\n       * This trial for ASCII reduces non ASCII performance by ~10% which seems acceptible\n       * compared to the gains.\n       * Note that this optimization only takes place for 4 consecutive ASCII chars,\n       * for any shorter it bails out. Worst case - all 4 bytes being read but\n       * thrown away due to the last being a non ASCII char (-10% performance).\n       */\n      while (i < fourStop\n        && !((byte1 = input[i]) & 0x80)\n        && !((byte2 = input[i + 1]) & 0x80)\n        && !((byte3 = input[i + 2]) & 0x80)\n        && !((byte4 = input[i + 3]) & 0x80))\n      {\n        target[size++] = byte1;\n        target[size++] = byte2;\n        target[size++] = byte3;\n        target[size++] = byte4;\n        i += 4;\n      }\n\n      // reread byte1\n      byte1 = input[i++];\n\n      // 1 byte\n      if (byte1 < 0x80) {\n        target[size++] = byte1;\n\n        // 2 bytes\n      } else if ((byte1 & 0xE0) === 0xC0) {\n        if (i >= length) {\n          this.interim[0] = byte1;\n          return size;\n        }\n        byte2 = input[i++];\n        if ((byte2 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        codepoint = (byte1 & 0x1F) << 6 | (byte2 & 0x3F);\n        if (codepoint < 0x80) {\n          // wrong starter byte\n          i--;\n          continue;\n        }\n        target[size++] = codepoint;\n\n        // 3 bytes\n      } else if ((byte1 & 0xF0) === 0xE0) {\n        if (i >= length) {\n          this.interim[0] = byte1;\n          return size;\n        }\n        byte2 = input[i++];\n        if ((byte2 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        if (i >= length) {\n          this.interim[0] = byte1;\n          this.interim[1] = byte2;\n          return size;\n        }\n        byte3 = input[i++];\n        if ((byte3 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        codepoint = (byte1 & 0x0F) << 12 | (byte2 & 0x3F) << 6 | (byte3 & 0x3F);\n        if (codepoint < 0x0800 || (codepoint >= 0xD800 && codepoint <= 0xDFFF)) {\n          // illegal codepoint, no i-- here\n          continue;\n        }\n        target[size++] = codepoint;\n\n        // 4 bytes\n      } else if ((byte1 & 0xF8) === 0xF0) {\n        if (i >= length) {\n          this.interim[0] = byte1;\n          return size;\n        }\n        byte2 = input[i++];\n        if ((byte2 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        if (i >= length) {\n          this.interim[0] = byte1;\n          this.interim[1] = byte2;\n          return size;\n        }\n        byte3 = input[i++];\n        if ((byte3 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        if (i >= length) {\n          this.interim[0] = byte1;\n          this.interim[1] = byte2;\n          this.interim[2] = byte3;\n          return size;\n        }\n        byte4 = input[i++];\n        if ((byte4 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        codepoint = (byte1 & 0x07) << 18 | (byte2 & 0x3F) << 12 | (byte3 & 0x3F) << 6 | (byte4 & 0x3F);\n        if (codepoint < 0x010000 || codepoint > 0x10FFFF) {\n          // illegal codepoint, no i-- here\n          continue;\n        }\n        target[size++] = codepoint;\n      } else {\n        // illegal byte, just skip\n      }\n    }\n    return size;\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { createProgram, expandFloat32Array, PROJECTION_MATRIX, throwIfFalsy } from './WebglUtils';\nimport { IRenderModel, IWebGLVertexArrayObject, IWebGL2RenderingContext, ISelectionRenderModel } from './Types';\nimport { fill } from 'common/TypedArrayUtils';\nimport { Attributes, FgFlags } from 'common/buffer/Constants';\nimport { Terminal } from 'xterm';\nimport { IColorSet, IColor } from 'browser/Types';\nimport { IRenderDimensions } from 'browser/renderer/Types';\nimport { RENDER_MODEL_BG_OFFSET, RENDER_MODEL_FG_OFFSET, RENDER_MODEL_INDICIES_PER_CELL } from './RenderModel';\n\nconst enum VertexAttribLocations {\n  POSITION = 0,\n  SIZE = 1,\n  COLOR = 2,\n  UNIT_QUAD = 3\n}\n\nconst vertexShaderSource = `#version 300 es\nlayout (location = ${VertexAttribLocations.POSITION}) in vec2 a_position;\nlayout (location = ${VertexAttribLocations.SIZE}) in vec2 a_size;\nlayout (location = ${VertexAttribLocations.COLOR}) in vec4 a_color;\nlayout (location = ${VertexAttribLocations.UNIT_QUAD}) in vec2 a_unitquad;\n\nuniform mat4 u_projection;\nuniform vec2 u_resolution;\n\nout vec4 v_color;\n\nvoid main() {\n  vec2 zeroToOne = (a_position + (a_unitquad * a_size)) / u_resolution;\n  gl_Position = u_projection * vec4(zeroToOne, 0.0, 1.0);\n  v_color = a_color;\n}`;\n\nconst fragmentShaderSource = `#version 300 es\nprecision lowp float;\n\nin vec4 v_color;\n\nout vec4 outColor;\n\nvoid main() {\n  outColor = v_color;\n}`;\n\ninterface IVertices {\n  attributes: Float32Array;\n  selection: Float32Array;\n  count: number;\n}\n\nconst INDICES_PER_RECTANGLE = 8;\nconst BYTES_PER_RECTANGLE = INDICES_PER_RECTANGLE * Float32Array.BYTES_PER_ELEMENT;\n\nconst INITIAL_BUFFER_RECTANGLE_CAPACITY = 20 * INDICES_PER_RECTANGLE;\n\nexport class RectangleRenderer {\n\n  private _program: WebGLProgram;\n  private _vertexArrayObject: IWebGLVertexArrayObject;\n  private _resolutionLocation: WebGLUniformLocation;\n  private _attributesBuffer: WebGLBuffer;\n  private _projectionLocation: WebGLUniformLocation;\n  private _bgFloat!: Float32Array;\n  private _selectionFloat!: Float32Array;\n\n  private _vertices: IVertices = {\n    count: 0,\n    attributes: new Float32Array(INITIAL_BUFFER_RECTANGLE_CAPACITY),\n    selection: new Float32Array(3 * INDICES_PER_RECTANGLE)\n  };\n\n  constructor(\n    private _terminal: Terminal,\n    private _colors: IColorSet,\n    private _gl: IWebGL2RenderingContext,\n    private _dimensions: IRenderDimensions\n  ) {\n    const gl = this._gl;\n\n    this._program = throwIfFalsy(createProgram(gl, vertexShaderSource, fragmentShaderSource));\n\n    // Uniform locations\n    this._resolutionLocation = throwIfFalsy(gl.getUniformLocation(this._program, 'u_resolution'));\n    this._projectionLocation = throwIfFalsy(gl.getUniformLocation(this._program, 'u_projection'));\n\n    // Create and set the vertex array object\n    this._vertexArrayObject = gl.createVertexArray();\n    gl.bindVertexArray(this._vertexArrayObject);\n\n    // Setup a_unitquad, this defines the 4 vertices of a rectangle\n    const unitQuadVertices = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n    const unitQuadVerticesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, unitQuadVerticesBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, unitQuadVertices, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(VertexAttribLocations.UNIT_QUAD);\n    gl.vertexAttribPointer(VertexAttribLocations.UNIT_QUAD, 2, this._gl.FLOAT, false, 0, 0);\n\n    // Setup the unit quad element array buffer, this points to indices in\n    // unitQuadVertuces to allow is to draw 2 triangles from the vertices\n    const unitQuadElementIndices = new Uint8Array([0, 1, 3, 0, 2, 3]);\n    const elementIndicesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementIndicesBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, unitQuadElementIndices, gl.STATIC_DRAW);\n\n    // Setup attributes\n    this._attributesBuffer = throwIfFalsy(gl.createBuffer());\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._attributesBuffer);\n    gl.enableVertexAttribArray(VertexAttribLocations.POSITION);\n    gl.vertexAttribPointer(VertexAttribLocations.POSITION, 2, gl.FLOAT, false, BYTES_PER_RECTANGLE, 0);\n    gl.vertexAttribDivisor(VertexAttribLocations.POSITION, 1);\n    gl.enableVertexAttribArray(VertexAttribLocations.SIZE);\n    gl.vertexAttribPointer(VertexAttribLocations.SIZE, 2, gl.FLOAT, false, BYTES_PER_RECTANGLE, 2 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribDivisor(VertexAttribLocations.SIZE, 1);\n    gl.enableVertexAttribArray(VertexAttribLocations.COLOR);\n    gl.vertexAttribPointer(VertexAttribLocations.COLOR, 4, gl.FLOAT, false, BYTES_PER_RECTANGLE, 4 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribDivisor(VertexAttribLocations.COLOR, 1);\n\n    this._updateCachedColors();\n  }\n\n  public render(): void {\n    const gl = this._gl;\n\n    gl.useProgram(this._program);\n\n    gl.bindVertexArray(this._vertexArrayObject);\n\n    gl.uniformMatrix4fv(this._projectionLocation, false, PROJECTION_MATRIX);\n    gl.uniform2f(this._resolutionLocation, gl.canvas.width, gl.canvas.height);\n\n    // Bind attributes buffer and draw\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._attributesBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this._vertices.attributes, gl.DYNAMIC_DRAW);\n    gl.drawElementsInstanced(this._gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0, this._vertices.count);\n\n    // Bind selection buffer and draw\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._attributesBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this._vertices.selection, gl.DYNAMIC_DRAW);\n    gl.drawElementsInstanced(this._gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0, 3);\n  }\n\n  public onResize(): void {\n    this._updateViewportRectangle();\n  }\n\n  public setColors(): void {\n    this._updateCachedColors();\n    this._updateViewportRectangle();\n  }\n\n  private _updateCachedColors(): void {\n    this._bgFloat = this._colorToFloat32Array(this._colors.background);\n    this._selectionFloat = this._colorToFloat32Array(this._colors.selectionOpaque);\n  }\n\n  private _updateViewportRectangle(): void {\n    // Set first rectangle that clears the screen\n    this._addRectangleFloat(\n      this._vertices.attributes,\n      0,\n      0,\n      0,\n      this._terminal.cols * this._dimensions.scaledCellWidth,\n      this._terminal.rows * this._dimensions.scaledCellHeight,\n      this._bgFloat\n    );\n  }\n\n  public updateSelection(model: ISelectionRenderModel): void {\n    const terminal = this._terminal;\n\n    if (!model.hasSelection) {\n      fill(this._vertices.selection, 0, 0);\n      return;\n    }\n\n    if (model.columnSelectMode) {\n      const startCol = model.startCol;\n      const width = model.endCol - startCol;\n      const height = model.viewportCappedEndRow - model.viewportCappedStartRow + 1;\n      this._addRectangleFloat(\n        this._vertices.selection,\n        0,\n        startCol * this._dimensions.scaledCellWidth,\n        model.viewportCappedStartRow * this._dimensions.scaledCellHeight,\n        width * this._dimensions.scaledCellWidth,\n        height * this._dimensions.scaledCellHeight,\n        this._selectionFloat\n      );\n      fill(this._vertices.selection, 0, INDICES_PER_RECTANGLE);\n    } else {\n      // Draw first row\n      const startCol = model.viewportStartRow === model.viewportCappedStartRow ? model.startCol : 0;\n      const startRowEndCol = model.viewportCappedStartRow === model.viewportEndRow ? model.endCol : terminal.cols;\n      this._addRectangleFloat(\n        this._vertices.selection,\n        0,\n        startCol * this._dimensions.scaledCellWidth,\n        model.viewportCappedStartRow * this._dimensions.scaledCellHeight,\n        (startRowEndCol - startCol) * this._dimensions.scaledCellWidth,\n        this._dimensions.scaledCellHeight,\n        this._selectionFloat\n      );\n\n      // Draw middle rows\n      const middleRowsCount = Math.max(model.viewportCappedEndRow - model.viewportCappedStartRow - 1, 0);\n      this._addRectangleFloat(\n        this._vertices.selection,\n        INDICES_PER_RECTANGLE,\n        0,\n        (model.viewportCappedStartRow + 1) * this._dimensions.scaledCellHeight,\n        terminal.cols * this._dimensions.scaledCellWidth,\n        middleRowsCount * this._dimensions.scaledCellHeight,\n        this._selectionFloat\n      );\n\n      // Draw final row\n      if (model.viewportCappedStartRow !== model.viewportCappedEndRow) {\n        // Only draw viewportEndRow if it's not the same as viewportStartRow\n        const endCol = model.viewportEndRow === model.viewportCappedEndRow ? model.endCol : terminal.cols;\n        this._addRectangleFloat(\n          this._vertices.selection,\n          INDICES_PER_RECTANGLE * 2,\n          0,\n          model.viewportCappedEndRow * this._dimensions.scaledCellHeight,\n          endCol * this._dimensions.scaledCellWidth,\n          this._dimensions.scaledCellHeight,\n          this._selectionFloat\n        );\n      } else {\n        fill(this._vertices.selection, 0, INDICES_PER_RECTANGLE * 2);\n      }\n    }\n  }\n\n  public updateBackgrounds(model: IRenderModel): void {\n    const terminal = this._terminal;\n    const vertices = this._vertices;\n\n    let rectangleCount = 1;\n\n    for (let y = 0; y < terminal.rows; y++) {\n      let currentStartX = -1;\n      let currentBg = 0;\n      let currentFg = 0;\n      let currentInverse = false;\n      for (let x = 0; x < terminal.cols; x++) {\n        const modelIndex = ((y * terminal.cols) + x) * RENDER_MODEL_INDICIES_PER_CELL;\n        const bg = model.cells[modelIndex + RENDER_MODEL_BG_OFFSET];\n        const fg = model.cells[modelIndex + RENDER_MODEL_FG_OFFSET];\n        const inverse = !!(fg & FgFlags.INVERSE);\n        if (bg !== currentBg || (fg !== currentFg && (currentInverse || inverse))) {\n          // A rectangle needs to be drawn if going from non-default to another color\n          if (currentBg !== 0 || (currentInverse && currentFg !== 0)) {\n            const offset = rectangleCount++ * INDICES_PER_RECTANGLE;\n            this._updateRectangle(vertices, offset, currentFg, currentBg, currentStartX, x, y);\n          }\n          currentStartX = x;\n          currentBg = bg;\n          currentFg = fg;\n          currentInverse = inverse;\n        }\n      }\n      // Finish rectangle if it's still going\n      if (currentBg !== 0 || (currentInverse && currentFg !== 0)) {\n        const offset = rectangleCount++ * INDICES_PER_RECTANGLE;\n        this._updateRectangle(vertices, offset, currentFg, currentBg, currentStartX, terminal.cols, y);\n      }\n    }\n    vertices.count = rectangleCount;\n  }\n\n  private _updateRectangle(vertices: IVertices, offset: number, fg: number, bg: number, startX: number, endX: number, y: number): void {\n    let rgba: number | undefined;\n    if (fg & FgFlags.INVERSE) {\n      switch (fg & Attributes.CM_MASK) {\n        case Attributes.CM_P16:\n        case Attributes.CM_P256:\n          rgba = this._colors.ansi[fg & Attributes.PCOLOR_MASK].rgba;\n          break;\n        case Attributes.CM_RGB:\n          rgba = (fg & Attributes.RGB_MASK) << 8;\n          break;\n        case Attributes.CM_DEFAULT:\n        default:\n          rgba = this._colors.foreground.rgba;\n      }\n    } else {\n      switch (bg & Attributes.CM_MASK) {\n        case Attributes.CM_P16:\n        case Attributes.CM_P256:\n          rgba = this._colors.ansi[bg & Attributes.PCOLOR_MASK].rgba;\n          break;\n        case Attributes.CM_RGB:\n          rgba = (bg & Attributes.RGB_MASK) << 8;\n          break;\n        case Attributes.CM_DEFAULT:\n        default:\n          rgba = this._colors.background.rgba;\n      }\n    }\n\n    if (vertices.attributes.length < offset + 4) {\n      vertices.attributes = expandFloat32Array(vertices.attributes, this._terminal.rows * this._terminal.cols * INDICES_PER_RECTANGLE);\n    }\n    const x1 = startX * this._dimensions.scaledCellWidth;\n    const y1 = y * this._dimensions.scaledCellHeight;\n    const r = ((rgba >> 24) & 0xFF) / 255;\n    const g = ((rgba >> 16) & 0xFF) / 255;\n    const b = ((rgba >> 8 ) & 0xFF) / 255;\n\n    this._addRectangle(vertices.attributes, offset, x1, y1, (endX - startX) * this._dimensions.scaledCellWidth, this._dimensions.scaledCellHeight, r, g, b, 1);\n  }\n\n  private _addRectangle(array: Float32Array, offset: number, x1: number, y1: number, width: number, height: number, r: number, g: number, b: number, a: number): void {\n    array[offset    ] = x1;\n    array[offset + 1] = y1;\n    array[offset + 2] = width;\n    array[offset + 3] = height;\n    array[offset + 4] = r;\n    array[offset + 5] = g;\n    array[offset + 6] = b;\n    array[offset + 7] = a;\n  }\n\n  private _addRectangleFloat(array: Float32Array, offset: number, x1: number, y1: number, width: number, height: number, color: Float32Array): void {\n    array[offset    ] = x1;\n    array[offset + 1] = y1;\n    array[offset + 2] = width;\n    array[offset + 3] = height;\n    array[offset + 4] = color[0];\n    array[offset + 5] = color[1];\n    array[offset + 6] = color[2];\n    array[offset + 7] = color[3];\n  }\n\n  private _colorToFloat32Array(color: IColor): Float32Array {\n    return new Float32Array([\n      ((color.rgba >> 24) & 0xFF) / 255,\n      ((color.rgba >> 16) & 0xFF) / 255,\n      ((color.rgba >> 8 ) & 0xFF) / 255,\n      ((color.rgba      ) & 0xFF) / 255\n    ]);\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IDisposable } from 'common/Types';\n\n/**\n * A base class that can be extended to provide convenience methods for managing the lifecycle of an\n * object and its components.\n */\nexport abstract class Disposable implements IDisposable {\n  protected _disposables: IDisposable[] = [];\n  protected _isDisposed: boolean = false;\n\n  constructor() {\n  }\n\n  /**\n   * Disposes the object, triggering the `dispose` method on all registered IDisposables.\n   */\n  public dispose(): void {\n    this._isDisposed = true;\n    for (const d of this._disposables) {\n      d.dispose();\n    }\n    this._disposables.length = 0;\n  }\n\n  /**\n   * Registers a disposable object.\n   * @param d The disposable to register.\n   * @returns The disposable.\n   */\n  public register<T extends IDisposable>(d: T): T {\n    this._disposables.push(d);\n    return d;\n  }\n\n  /**\n   * Unregisters a disposable object if it has been registered, if not do\n   * nothing.\n   * @param d The disposable to unregister.\n   */\n  public unregister<T extends IDisposable>(d: T): void {\n    const index = this._disposables.indexOf(d);\n    if (index !== -1) {\n      this._disposables.splice(index, 1);\n    }\n  }\n}\n\n/**\n * Dispose of all disposables in an array and set its length to 0.\n */\nexport function disposeArray(disposables: IDisposable[]): void {\n  for (const d of disposables) {\n    d.dispose();\n  }\n  disposables.length = 0;\n}\n\n/**\n * Creates a disposable that will dispose of an array of disposables when disposed.\n */\nexport function getDisposeArrayDisposable(array: IDisposable[]): IDisposable {\n  return { dispose: () => disposeArray(array) };\n}\n","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IDisposable } from 'common/Types';\n\ninterface IListener<T, U = void> {\n  (arg1: T, arg2: U): void;\n}\n\nexport interface IEvent<T, U = void> {\n  (listener: (arg1: T, arg2: U) => any): IDisposable;\n}\n\nexport interface IEventEmitter<T, U = void> {\n  event: IEvent<T, U>;\n  fire(arg1: T, arg2: U): void;\n  dispose(): void;\n}\n\nexport class EventEmitter<T, U = void> implements IEventEmitter<T, U> {\n  private _listeners: IListener<T, U>[] = [];\n  private _event?: IEvent<T, U>;\n  private _disposed: boolean = false;\n\n  public get event(): IEvent<T, U> {\n    if (!this._event) {\n      this._event = (listener: (arg1: T, arg2: U) => any) => {\n        this._listeners.push(listener);\n        const disposable = {\n          dispose: () => {\n            if (!this._disposed) {\n              for (let i = 0; i < this._listeners.length; i++) {\n                if (this._listeners[i] === listener) {\n                  this._listeners.splice(i, 1);\n                  return;\n                }\n              }\n            }\n          }\n        };\n        return disposable;\n      };\n    }\n    return this._event;\n  }\n\n  public fire(arg1: T, arg2: U): void {\n    const queue: IListener<T, U>[] = [];\n    for (let i = 0; i < this._listeners.length; i++) {\n      queue.push(this._listeners[i]);\n    }\n    for (let i = 0; i < queue.length; i++) {\n      queue[i].call(undefined, arg1, arg2);\n    }\n  }\n\n  public dispose(): void {\n    if (this._listeners) {\n      this._listeners.length = 0;\n    }\n    this._disposed = true;\n  }\n}\n\nexport function forwardEvent<T>(from: IEvent<T>, to: IEventEmitter<T>): IDisposable {\n  return from(e => to.fire(e));\n}\n"],"sourceRoot":""}